<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios++: Scene Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Helios++
   </div>
   <div id="projectbrief">Helios software for LiDAR simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d5/d9c/classScene.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../db/d67/classScene-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Scene Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class representing a scene asset.  
 <a href="../../d5/d9c/classScene.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/d2d/Scene_8h_source.html">Scene.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Scene:</div>
<div class="dyncontent">
<div class="center"><img src="../../d2/d20/classScene__inherit__graph.png" border="0" usemap="#aScene_inherit__map" alt="Inheritance graph"/></div>
<map name="aScene_inherit__map" id="aScene_inherit__map">
<area shape="rect" title="Class representing a scene asset." alt="" coords="23,80,81,107"/>
<area shape="rect" href="../../dd/d34/classStaticScene.html" title="Static scene basic implementation." alt="" coords="5,155,99,181"/>
<area shape="rect" href="../../de/d97/classAsset.html" title="Base class for all assets." alt="" coords="24,5,80,32"/>
<area shape="rect" href="../../de/d74/classDynScene.html" title="Dynamic scene base implementation." alt="" coords="11,229,93,256"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Scene:</div>
<div class="dyncontent">
<div class="center"><img src="../../d5/d11/classScene__coll__graph.png" border="0" usemap="#aScene_coll__map" alt="Collaboration graph"/></div>
<map name="aScene_coll__map" id="aScene_coll__map">
<area shape="rect" title="Class representing a scene asset." alt="" coords="5,200,64,227"/>
<area shape="rect" href="../../de/d97/classAsset.html" title="Base class for all assets." alt="" coords="7,124,63,151"/>
<area shape="rect" title=" " alt="" coords="7,5,62,32"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad10176d75a9cc0da56626f682d083507"><td class="memItemLeft" align="right" valign="top"><a id="ad10176d75a9cc0da56626f682d083507"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#ad10176d75a9cc0da56626f682d083507">Scene</a> ()</td></tr>
<tr class="memdesc:ad10176d75a9cc0da56626f682d083507"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset.">Scene</a> default constructor. <br /></td></tr>
<tr class="separator:ad10176d75a9cc0da56626f682d083507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eca6af7cda6d6bd8bf5ae19597f9ddc"><td class="memItemLeft" align="right" valign="top"><a id="a9eca6af7cda6d6bd8bf5ae19597f9ddc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Scene</b> (<a class="el" href="../../d5/d9c/classScene.html">Scene</a> &amp;s)</td></tr>
<tr class="separator:a9eca6af7cda6d6bd8bf5ae19597f9ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8e9900ddf447c30d4ff869e3f0c152"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#adb8e9900ddf447c30d4ff869e3f0c152">finalizeLoading</a> (bool const safe=false)</td></tr>
<tr class="memdesc:adb8e9900ddf447c30d4ff869e3f0c152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle scene loading finish process.  <a href="../../d5/d9c/classScene.html#adb8e9900ddf447c30d4ff869e3f0c152">More...</a><br /></td></tr>
<tr class="separator:adb8e9900ddf447c30d4ff869e3f0c152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866e2103680b966d076df0121f147e6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a866e2103680b966d076df0121f147e6d">registerParts</a> ()</td></tr>
<tr class="memdesc:a866e2103680b966d076df0121f147e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register all scene parts composing the scene in the parts vector with no repetitions.  <a href="../../d5/d9c/classScene.html#a866e2103680b966d076df0121f147e6d">More...</a><br /></td></tr>
<tr class="separator:a866e2103680b966d076df0121f147e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d6bd40ca4908b40dd1d6e14ccea2c2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#aa9d6bd40ca4908b40dd1d6e14ccea2c2">getAABB</a> ()</td></tr>
<tr class="memdesc:aa9d6bd40ca4908b40dd1d6e14ccea2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the axis aligned bounding box defining scene boundaries.  <a href="../../d5/d9c/classScene.html#aa9d6bd40ca4908b40dd1d6e14ccea2c2">More...</a><br /></td></tr>
<tr class="separator:aa9d6bd40ca4908b40dd1d6e14ccea2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f056f98c3ab727a98cb7c4ff0f4a754"><td class="memItemLeft" align="right" valign="top">glm::dvec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a3f056f98c3ab727a98cb7c4ff0f4a754">getGroundPointAt</a> (glm::dvec3 point)</td></tr>
<tr class="memdesc:a3f056f98c3ab727a98cb7c4ff0f4a754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the ground point at specified XY coordinates.  <a href="../../d5/d9c/classScene.html#a3f056f98c3ab727a98cb7c4ff0f4a754">More...</a><br /></td></tr>
<tr class="separator:a3f056f98c3ab727a98cb7c4ff0f4a754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25064cb65a0d92828fbf4299e847233f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/da3/classRaySceneIntersection.html">RaySceneIntersection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a25064cb65a0d92828fbf4299e847233f">getIntersection</a> (glm::dvec3 const &amp;rayOrigin, glm::dvec3 const &amp;rayDir, bool const groundOnly) const</td></tr>
<tr class="memdesc:a25064cb65a0d92828fbf4299e847233f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the intersection between the ray and the scene, if any.  <a href="../../d5/d9c/classScene.html#a25064cb65a0d92828fbf4299e847233f">More...</a><br /></td></tr>
<tr class="separator:a25064cb65a0d92828fbf4299e847233f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c2a985f4963cd63c708cdb0b58a038"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/da3/classRaySceneIntersection.html">RaySceneIntersection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#ad1c2a985f4963cd63c708cdb0b58a038">getIntersection</a> (vector&lt; double &gt; const &amp;tMinMax, glm::dvec3 const &amp;rayOrigin, glm::dvec3 const &amp;rayDir, bool const groundOnly) const</td></tr>
<tr class="memdesc:ad1c2a985f4963cd63c708cdb0b58a038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like Scene::getIntersection(dvec3 const, dvec3 const, bool const) but receiving precomputed minimum and maximum intersection times with respect to the axis aligned bounding box that bounds the scene.  <a href="../../d5/d9c/classScene.html#ad1c2a985f4963cd63c708cdb0b58a038">More...</a><br /></td></tr>
<tr class="separator:ad1c2a985f4963cd63c708cdb0b58a038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba5957daaf3ae372e54807cf372ac35"><td class="memItemLeft" align="right" valign="top">std::map&lt; double, <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a4ba5957daaf3ae372e54807cf372ac35">getIntersections</a> (glm::dvec3 &amp;rayOrigin, glm::dvec3 &amp;rayDir, bool const groundOnly)</td></tr>
<tr class="memdesc:a4ba5957daaf3ae372e54807cf372ac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain all intersections between the ray and the scene, if any.  <a href="../../d5/d9c/classScene.html#a4ba5957daaf3ae372e54807cf372ac35">More...</a><br /></td></tr>
<tr class="separator:a4ba5957daaf3ae372e54807cf372ac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efb5df7a0b3c59c2a6d0d85c6485a84"><td class="memItemLeft" align="right" valign="top">glm::dvec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a1efb5df7a0b3c59c2a6d0d85c6485a84">getShift</a> ()</td></tr>
<tr class="memdesc:a1efb5df7a0b3c59c2a6d0d85c6485a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the minimum boundaries of the original axis aligned bounding box containing the scene, before it was centered so (0, 0, 0) became its new minimum boundaries.  <a href="../../d5/d9c/classScene.html#a1efb5df7a0b3c59c2a6d0d85c6485a84">More...</a><br /></td></tr>
<tr class="separator:a1efb5df7a0b3c59c2a6d0d85c6485a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da8f4527d42c258d28ec94dea031481"><td class="memItemLeft" align="right" valign="top">glm::dvec3 const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a4da8f4527d42c258d28ec94dea031481">getShiftRef</a> () const</td></tr>
<tr class="memdesc:a4da8f4527d42c258d28ec94dea031481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="../../d5/d9c/classScene.html#a1efb5df7a0b3c59c2a6d0d85c6485a84" title="Obtain the minimum boundaries of the original axis aligned bounding box containing the scene,...">Scene::getShift</a> but returning a const reference instead of a copy.  <a href="../../d5/d9c/classScene.html#a4da8f4527d42c258d28ec94dea031481">More...</a><br /></td></tr>
<tr class="separator:a4da8f4527d42c258d28ec94dea031481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ce55bcb11ce26343b4b72066e0cf5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d2/da0/classVertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#af46ce55bcb11ce26343b4b72066e0cf5">getAllVertices</a> ()</td></tr>
<tr class="memdesc:af46ce55bcb11ce26343b4b72066e0cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain all vertices (without repetitions) composing the scene.  <a href="../../d5/d9c/classScene.html#af46ce55bcb11ce26343b4b72066e0cf5">More...</a><br /></td></tr>
<tr class="separator:af46ce55bcb11ce26343b4b72066e0cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c173e62cd1c1c31cdd05edcafbee0ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a3c173e62cd1c1c31cdd05edcafbee0ab">doForceOnGround</a> ()</td></tr>
<tr class="memdesc:a3c173e62cd1c1c31cdd05edcafbee0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each scene part which is flagged as forceOnGround, it will be vertically translated to closest ground scene part.  <a href="../../d5/d9c/classScene.html#a3c173e62cd1c1c31cdd05edcafbee0ab">More...</a><br /></td></tr>
<tr class="separator:a3c173e62cd1c1c31cdd05edcafbee0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da897e6569fa3058ab91767b25658c0"><td class="memItemLeft" align="right" valign="top">glm::dvec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a6da897e6569fa3058ab91767b25658c0">findForceOnGroundQ</a> (int const searchDepth, glm::dvec3 const minzv, vector&lt; <a class="el" href="../../d2/da0/classVertex.html">Vertex</a> * &gt; &amp;vertices, vector&lt; double &gt; const &amp;o, vector&lt; double &gt; const &amp;v)</td></tr>
<tr class="memdesc:a6da897e6569fa3058ab91767b25658c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assist doForceOnGround function to find an adequate \(q\) for step 4.  <a href="../../d5/d9c/classScene.html#a6da897e6569fa3058ab91767b25658c0">More...</a><br /></td></tr>
<tr class="separator:a6da897e6569fa3058ab91767b25658c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffef7046522c356bef106522079e353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a3ffef7046522c356bef106522079e353">buildKDGrove</a> (bool const safe=false)</td></tr>
<tr class="memdesc:a3ffef7046522c356bef106522079e353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> for the scene, overwriting previous one if any.  <a href="../../d5/d9c/classScene.html#a3ffef7046522c356bef106522079e353">More...</a><br /></td></tr>
<tr class="separator:a3ffef7046522c356bef106522079e353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4937809abfcb355f7a36b207a82a755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#ad4937809abfcb355f7a36b207a82a755">buildKDGroveWithLog</a> (bool const safe=false)</td></tr>
<tr class="memdesc:ad4937809abfcb355f7a36b207a82a755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call buildKDGrove exporting building information through logging system.  <a href="../../d5/d9c/classScene.html#ad4937809abfcb355f7a36b207a82a755">More...</a><br /></td></tr>
<tr class="separator:ad4937809abfcb355f7a36b207a82a755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f14821f45985670b2323dc010357d46"><td class="memItemLeft" align="right" valign="top"><a id="a5f14821f45985670b2323dc010357d46"></a>
virtual std::shared_ptr&lt; <a class="el" href="../../df/d01/classKDGroveRaycaster.html">KDGroveRaycaster</a> &gt; const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getRaycaster</b> () const</td></tr>
<tr class="separator:a5f14821f45985670b2323dc010357d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96110a189ae4bbb60855ecc14afd3138"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="../../de/d89/classKDGroveFactory.html">KDGroveFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a96110a189ae4bbb60855ecc14afd3138">getKDGroveFactory</a> () const</td></tr>
<tr class="memdesc:a96110a189ae4bbb60855ecc14afd3138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> factory used by the scene.  <a href="../../d5/d9c/classScene.html#a96110a189ae4bbb60855ecc14afd3138">More...</a><br /></td></tr>
<tr class="separator:a96110a189ae4bbb60855ecc14afd3138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b11a57368136ed5373c6362da5f732c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a1b11a57368136ed5373c6362da5f732c">setKDGroveFactory</a> (std::shared_ptr&lt; <a class="el" href="../../de/d89/classKDGroveFactory.html">KDGroveFactory</a> &gt; const <a class="el" href="../../d5/d9c/classScene.html#a3468275e1f969eea9aceae7962123483">kdgf</a>)</td></tr>
<tr class="memdesc:a1b11a57368136ed5373c6362da5f732c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> factory to be used by the scene.  <a href="../../d5/d9c/classScene.html#a1b11a57368136ed5373c6362da5f732c">More...</a><br /></td></tr>
<tr class="separator:a1b11a57368136ed5373c6362da5f732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaf897197924c7a5c6affeeccc0c83c"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="../../d9/d76/classKDGrove.html">KDGrove</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a1aaf897197924c7a5c6affeeccc0c83c">getKDGrove</a> () const</td></tr>
<tr class="memdesc:a1aaf897197924c7a5c6affeeccc0c83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> used by the scene.  <a href="../../d5/d9c/classScene.html#a1aaf897197924c7a5c6affeeccc0c83c">More...</a><br /></td></tr>
<tr class="separator:a1aaf897197924c7a5c6affeeccc0c83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c3368fd1ebce8848b9480ce39bfd2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#aa6c3368fd1ebce8848b9480ce39bfd2d">setKDGrove</a> (std::shared_ptr&lt; <a class="el" href="../../d9/d76/classKDGrove.html">KDGrove</a> &gt; const <a class="el" href="../../d5/d9c/classScene.html#a7cf88b807d54fc552db7551a3ab0aae4">kdgrove</a>)</td></tr>
<tr class="memdesc:aa6c3368fd1ebce8848b9480ce39bfd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> to be used by the scene.  <a href="../../d5/d9c/classScene.html#aa6c3368fd1ebce8848b9480ce39bfd2d">More...</a><br /></td></tr>
<tr class="separator:aa6c3368fd1ebce8848b9480ce39bfd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18592eb6dd32e43dd35cd95f22cbbb11"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a18592eb6dd32e43dd35cd95f22cbbb11">getBBox</a> () const</td></tr>
<tr class="memdesc:a18592eb6dd32e43dd35cd95f22cbbb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the scene's bounding box.  <a href="../../d5/d9c/classScene.html#a18592eb6dd32e43dd35cd95f22cbbb11">More...</a><br /></td></tr>
<tr class="separator:a18592eb6dd32e43dd35cd95f22cbbb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1c82c4bcd7b6bb176b29c523c15575"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#acf1c82c4bcd7b6bb176b29c523c15575">setBBox</a> (std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt; const <a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330">bbox</a>)</td></tr>
<tr class="memdesc:acf1c82c4bcd7b6bb176b29c523c15575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene's bounding box.  <a href="../../d5/d9c/classScene.html#acf1c82c4bcd7b6bb176b29c523c15575">More...</a><br /></td></tr>
<tr class="separator:acf1c82c4bcd7b6bb176b29c523c15575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee379217cfb0fc90eb4471274f8de06"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#afee379217cfb0fc90eb4471274f8de06">getBBoxCRS</a> () const</td></tr>
<tr class="memdesc:afee379217cfb0fc90eb4471274f8de06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the scene's coordinate reference system bounding box.  <a href="../../d5/d9c/classScene.html#afee379217cfb0fc90eb4471274f8de06">More...</a><br /></td></tr>
<tr class="separator:afee379217cfb0fc90eb4471274f8de06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c42cb5df37ce7340ef497e84e9eacb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#af4c42cb5df37ce7340ef497e84e9eacb">setBBoxCRS</a> (std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt; const <a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330">bbox</a>)</td></tr>
<tr class="memdesc:af4c42cb5df37ce7340ef497e84e9eacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene's coordinate reference system bounding box.  <a href="../../d5/d9c/classScene.html#af4c42cb5df37ce7340ef497e84e9eacb">More...</a><br /></td></tr>
<tr class="separator:af4c42cb5df37ce7340ef497e84e9eacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8798b09857e4df7adf05dea25210ab"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#afd8798b09857e4df7adf05dea25210ab">hasMovingObjects</a> () const</td></tr>
<tr class="memdesc:afd8798b09857e4df7adf05dea25210ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checke whether the scene contains at least one moving object (true) or not (false)  <a href="../../d5/d9c/classScene.html#afd8798b09857e4df7adf05dea25210ab">More...</a><br /></td></tr>
<tr class="separator:afd8798b09857e4df7adf05dea25210ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782302f4dc1703617d5292251bda044e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a782302f4dc1703617d5292251bda044e">writeObject</a> (std::string path)</td></tr>
<tr class="memdesc:a782302f4dc1703617d5292251bda044e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the scene and write it to given output file.  <a href="../../d5/d9c/classScene.html#a782302f4dc1703617d5292251bda044e">More...</a><br /></td></tr>
<tr class="separator:a782302f4dc1703617d5292251bda044e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae788ef988fdebee152a06adb3974da6a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#ae788ef988fdebee152a06adb3974da6a">doSimStep</a> ()</td></tr>
<tr class="memdesc:ae788ef988fdebee152a06adb3974da6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support simulation step handling from scene side.  <a href="../../d5/d9c/classScene.html#ae788ef988fdebee152a06adb3974da6a">More...</a><br /></td></tr>
<tr class="separator:ae788ef988fdebee152a06adb3974da6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classAsset"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classAsset')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../de/d97/classAsset.html">Asset</a></td></tr>
<tr class="memitem:a9ad0c79df694d3f079daba3eedf0284c inherit pub_methods_classAsset"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classAsset.html#a9ad0c79df694d3f079daba3eedf0284c">getLocationString</a> ()</td></tr>
<tr class="memdesc:a9ad0c79df694d3f079daba3eedf0284c inherit pub_methods_classAsset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain asset location string.  <a href="../../de/d97/classAsset.html#a9ad0c79df694d3f079daba3eedf0284c">More...</a><br /></td></tr>
<tr class="separator:a9ad0c79df694d3f079daba3eedf0284c inherit pub_methods_classAsset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadfa6f04f5d8a5a7411a53399f2cb32 inherit pub_methods_classAsset"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classAsset.html#adadfa6f04f5d8a5a7411a53399f2cb32">isEgg</a> () const</td></tr>
<tr class="memdesc:adadfa6f04f5d8a5a7411a53399f2cb32 inherit pub_methods_classAsset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the asset is an <a class="el" href="../../da/dea/classEggAsset.html" title="An EggAsset is an asset that can hatch to its full class.">EggAsset</a> or not.  <a href="../../de/d97/classAsset.html#adadfa6f04f5d8a5a7411a53399f2cb32">More...</a><br /></td></tr>
<tr class="separator:adadfa6f04f5d8a5a7411a53399f2cb32 inherit pub_methods_classAsset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1ce25df38164ed98cf695bc8042bc6a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d5/d9c/classScene.html">Scene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a1ce25df38164ed98cf695bc8042bc6a5">readObject</a> (std::string path)</td></tr>
<tr class="memdesc:a1ce25df38164ed98cf695bc8042bc6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read serialized scene from given file.  <a href="../../d5/d9c/classScene.html#a1ce25df38164ed98cf695bc8042bc6a5">More...</a><br /></td></tr>
<tr class="separator:a1ce25df38164ed98cf695bc8042bc6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7006d57329f8e8d8563e9ff54ddcb2fc"><td class="memItemLeft" align="right" valign="top"><a id="a7006d57329f8e8d8563e9ff54ddcb2fc"></a>
std::vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a7006d57329f8e8d8563e9ff54ddcb2fc">primitives</a></td></tr>
<tr class="memdesc:a7006d57329f8e8d8563e9ff54ddcb2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of primitives composing the scene. <br /></td></tr>
<tr class="separator:a7006d57329f8e8d8563e9ff54ddcb2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc4bc214f0f830bb96ad276c0bdce98"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../dd/dc4/classScenePart.html">ScenePart</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a3cc4bc214f0f830bb96ad276c0bdce98">parts</a></td></tr>
<tr class="memdesc:a3cc4bc214f0f830bb96ad276c0bdce98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parts composing the scene with no repeats.  <a href="../../d5/d9c/classScene.html#a3cc4bc214f0f830bb96ad276c0bdce98">More...</a><br /></td></tr>
<tr class="separator:a3cc4bc214f0f830bb96ad276c0bdce98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classAsset"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classAsset')"><img src="../../closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="../../de/d97/classAsset.html">Asset</a></td></tr>
<tr class="memitem:ac37173d6b01d7b8caa7bd786b8de2269 inherit pub_attribs_classAsset"><td class="memItemLeft" align="right" valign="top"><a id="ac37173d6b01d7b8caa7bd786b8de2269"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classAsset.html#ac37173d6b01d7b8caa7bd786b8de2269">id</a> = &quot;&quot;</td></tr>
<tr class="memdesc:ac37173d6b01d7b8caa7bd786b8de2269 inherit pub_attribs_classAsset"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/d97/classAsset.html" title="Base class for all assets.">Asset</a> identifier. <br /></td></tr>
<tr class="separator:ac37173d6b01d7b8caa7bd786b8de2269 inherit pub_attribs_classAsset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7c46a97929723eed3a5f73a3542bb9 inherit pub_attribs_classAsset"><td class="memItemLeft" align="right" valign="top"><a id="aaa7c46a97929723eed3a5f73a3542bb9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classAsset.html#aaa7c46a97929723eed3a5f73a3542bb9">name</a> = &quot;Unnamed <a class="el" href="../../de/d97/classAsset.html">Asset</a>&quot;</td></tr>
<tr class="memdesc:aaa7c46a97929723eed3a5f73a3542bb9 inherit pub_attribs_classAsset"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/d97/classAsset.html" title="Base class for all assets.">Asset</a> name. <br /></td></tr>
<tr class="separator:aaa7c46a97929723eed3a5f73a3542bb9 inherit pub_attribs_classAsset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9b323b6f7e7f343dacb278d3610645 inherit pub_attribs_classAsset"><td class="memItemLeft" align="right" valign="top"><a id="a8a9b323b6f7e7f343dacb278d3610645"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classAsset.html#a8a9b323b6f7e7f343dacb278d3610645">sourceFilePath</a> = &quot;&quot;</td></tr>
<tr class="memdesc:a8a9b323b6f7e7f343dacb278d3610645 inherit pub_attribs_classAsset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to asset file. <br /></td></tr>
<tr class="separator:a8a9b323b6f7e7f343dacb278d3610645 inherit pub_attribs_classAsset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3468275e1f969eea9aceae7962123483"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../de/d89/classKDGroveFactory.html">KDGroveFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a3468275e1f969eea9aceae7962123483">kdgf</a></td></tr>
<tr class="memdesc:a3468275e1f969eea9aceae7962123483"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> factory used to build the scene <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a>.  <a href="../../d5/d9c/classScene.html#a3468275e1f969eea9aceae7962123483">More...</a><br /></td></tr>
<tr class="separator:a3468275e1f969eea9aceae7962123483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf88b807d54fc552db7551a3ab0aae4"><td class="memItemLeft" align="right" valign="top"><a id="a7cf88b807d54fc552db7551a3ab0aae4"></a>
std::shared_ptr&lt; <a class="el" href="../../d9/d76/classKDGrove.html">KDGrove</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a7cf88b807d54fc552db7551a3ab0aae4">kdgrove</a></td></tr>
<tr class="memdesc:a7cf88b807d54fc552db7551a3ab0aae4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> containing a KDTree for each scene part to speed-up ray-primitive intersection check computations. <br /></td></tr>
<tr class="separator:a7cf88b807d54fc552db7551a3ab0aae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012be28a1b960338f634d5fec54c5330"><td class="memItemLeft" align="right" valign="top"><a id="a012be28a1b960338f634d5fec54c5330"></a>
std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330">bbox</a></td></tr>
<tr class="memdesc:a012be28a1b960338f634d5fec54c5330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis aligned bounding box defining scene boundaries. <br /></td></tr>
<tr class="separator:a012be28a1b960338f634d5fec54c5330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6443452016957950e3a7260dcc0076f1"><td class="memItemLeft" align="right" valign="top"><a id="a6443452016957950e3a7260dcc0076f1"></a>
std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a6443452016957950e3a7260dcc0076f1">bbox_crs</a></td></tr>
<tr class="memdesc:a6443452016957950e3a7260dcc0076f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Original axis aligned bounding box defining scene boundaries before centering it. <br /></td></tr>
<tr class="separator:a6443452016957950e3a7260dcc0076f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4d9a2ecbfe18318a5953905fa57fb9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../df/d01/classKDGroveRaycaster.html">KDGroveRaycaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#aac4d9a2ecbfe18318a5953905fa57fb9">raycaster</a></td></tr>
<tr class="memdesc:aac4d9a2ecbfe18318a5953905fa57fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raycaster based on <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a>.  <a href="../../d5/d9c/classScene.html#aac4d9a2ecbfe18318a5953905fa57fb9">More...</a><br /></td></tr>
<tr class="separator:aac4d9a2ecbfe18318a5953905fa57fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4d6039c2337a5085570ab6a9b8cb7683"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a4d6039c2337a5085570ab6a9b8cb7683"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a4d6039c2337a5085570ab6a9b8cb7683">save</a> (Archive &amp;ar, unsigned int const version) const</td></tr>
<tr class="memdesc:a4d6039c2337a5085570ab6a9b8cb7683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle scene save operation.  <a href="../../d5/d9c/classScene.html#a4d6039c2337a5085570ab6a9b8cb7683">More...</a><br /></td></tr>
<tr class="separator:a4d6039c2337a5085570ab6a9b8cb7683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68d340293560035fb043da042a26e85"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ac68d340293560035fb043da042a26e85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#ac68d340293560035fb043da042a26e85">load</a> (Archive &amp;ar, unsigned int const fileVersion)</td></tr>
<tr class="memdesc:ac68d340293560035fb043da042a26e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle scene load operation.  <a href="../../d5/d9c/classScene.html#ac68d340293560035fb043da042a26e85">More...</a><br /></td></tr>
<tr class="separator:ac68d340293560035fb043da042a26e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362e319a7d418a6905a6aa3b82065a5a"><td class="memItemLeft" align="right" valign="top"><a id="a362e319a7d418a6905a6aa3b82065a5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_SERIALIZATION_SPLIT_MEMBER</b> ()</td></tr>
<tr class="separator:a362e319a7d418a6905a6aa3b82065a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top"><a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::serialization::access</b></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing a scene asset. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3ffef7046522c356bef106522079e353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffef7046522c356bef106522079e353">&#9670;&nbsp;</a></span>buildKDGrove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::buildKDGrove </td>
          <td>(</td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>safe</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> for the scene, overwriting previous one if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">safe</td><td>The same safe as the one received by finalizeSceneLoading </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Scene::finalizeSceneLoading </dd>
<dd>
<a class="el" href="../../d5/d9c/classScene.html#ad4937809abfcb355f7a36b207a82a755" title="Call buildKDGrove exporting building information through logging system.">Scene::buildKDGroveWithLog</a> </dd></dl>

</div>
</div>
<a id="ad4937809abfcb355f7a36b207a82a755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4937809abfcb355f7a36b207a82a755">&#9670;&nbsp;</a></span>buildKDGroveWithLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::buildKDGroveWithLog </td>
          <td>(</td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>safe</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call buildKDGrove exporting building information through logging system. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a3ffef7046522c356bef106522079e353" title="Build the KDGrove for the scene, overwriting previous one if any.">Scene::buildKDGrove</a> </dd></dl>

</div>
</div>
<a id="a3c173e62cd1c1c31cdd05edcafbee0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c173e62cd1c1c31cdd05edcafbee0ab">&#9670;&nbsp;</a></span>doForceOnGround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::doForceOnGround </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each scene part which is flagged as forceOnGround, it will be vertically translated to closest ground scene part. </p>
<p>This function requires that there is at least one scene part flagged as ground, otherwise it is not possible to apply it. The algorithm can be described in 5 steps:</p>
<ol type="1">
<li>For any ground scene part, find its min \(a_i = (a_{ix}, a_{iy}, a_{iz})\) and max \(b_i = (b_{ix}, b_{iy}, b_{iz})\) vertices.</li>
<li><p class="startli">Let the scene part to be placed on ground be defined by its \(m\) vertices, such that \(Q = \left\{q_1, \ldots, q_m\right\}\). Also, let it be represented by its minimum \(z\) vertex \(q_* = (q_{*x}, q_{*y}, q_{*z}) \). Thus, the first found ground scene part such that \(q_*\) is inside its \(\mathbb{R}^{2}\) boundaries is considered as the ground reference. More formally, it must be satisfied that:</p>
<p class="formulaDsp">
\[ q_{*x} \in [a_{ix}, b_{ix}] \land q_{*y} \in [a_{iy}, b_{iy}] \]
</p>
</li>
<li><p class="startli">Find the best fitting plane \(\pi\) with respect to vertices of ground reference, which orthonormal vector is noted as \(\hat{v}\)</p>
<p class="formulaDsp">
\[ \pi = \left\{ p=(x, y, z) : \left\langle{\overrightarrow{op}, \hat{v}}\right\rangle = 0 \right\} \]
</p>
</li>
<li><p class="startli">Compute the vertical projection of \(q\) on best fitting ground plane \(\pi\) as follows:</p>
<p class="formulaDsp">
\[ \begin{array}{lll} \mathcal{P}^{z}_{\pi}(q) &amp;=&amp; \left( q_{x}, q_{y}, \frac{ \hat{v}_x o_x + \hat{v}_y o_y + \hat{v}_z o_z - \hat{v}_x q_{x} - \hat{v}_y q_{y} } {\hat{v}_z} \right) \\ &amp;=&amp; \left( q_{x}, q_{y}, \frac{ \left\langle{\hat{v}, \vec{o}}\right\rangle - \hat{v}_x q_{x} - \hat{v}_y q_{y} }{\hat{v}_z} \right) \\ &amp;=&amp; (p_x, p_y, p_z) \\ &amp;=&amp; p \end{array} \]
</p>
<p class="startli">Where \(q\) varies depending on search depth, as explained in parameter documentation at the <a class="el" href="../../d5/d9c/classScene.html#a6da897e6569fa3058ab91767b25658c0" title="Assist doForceOnGround function to find an adequate  for step 4.">Scene::findForceOnGroundQ</a> function.</p>
</li>
<li><p class="startli">Let \(\Delta_z = q_{*z} - p_z\) be the magnitude of vertical translation for the entire scene part. Now, each vertex defining the scene part must be translated so:</p>
<p class="formulaDsp">
\[ \forall q_i \in Q,\, q&#39;_i = (q_{ix}, q_{iy}, q_{iz} - \Delta_z) \]
</p>
</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a6da897e6569fa3058ab91767b25658c0" title="Assist doForceOnGround function to find an adequate  for step 4.">Scene::findForceOnGroundQ</a> </dd></dl>

</div>
</div>
<a id="ae788ef988fdebee152a06adb3974da6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae788ef988fdebee152a06adb3974da6a">&#9670;&nbsp;</a></span>doSimStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Scene::doSimStep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Support simulation step handling from scene side. </p>
<p>For basic scenes and static scenes, there is nothing to do. However, dynamic scenes are expected to override this method to provide simulation level dynamism.</p>
<dl class="section return"><dt>Returns</dt><dd>True if scene was updated, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d74/classDynScene.html#a192d62758850392937ae69532ff0c462" title="Do corresponding computations for the dynamic scene at current simulation step, if any.">DynScene::doSimStep</a> </dd></dl>

<p>Reimplemented in <a class="el" href="../../de/d74/classDynScene.html#a192d62758850392937ae69532ff0c462">DynScene</a>.</p>

</div>
</div>
<a id="adb8e9900ddf447c30d4ff869e3f0c152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8e9900ddf447c30d4ff869e3f0c152">&#9670;&nbsp;</a></span>finalizeLoading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scene::finalizeLoading </td>
          <td>(</td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>safe</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle scene loading finish process. </p>
<p>Computations such as primitives update and centering the scene (all its vertices) so the axis aligned bounding box defining its boundaries start at (0, 0, 0) and also KDTree building are performed here</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">safe</td><td>Enable safe mode (true) or disable it (false). Safe mode is mainly useful for debugging purposes because it prevents certain changes such as modification of primitives ordering. Whenever safe mode is not necessary, it is recommended to set it to false as enabling it might lead to a slowdown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if scene loading was successfully finished, false otherwise </dd></dl>

</div>
</div>
<a id="a6da897e6569fa3058ab91767b25658c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da897e6569fa3058ab91767b25658c0">&#9670;&nbsp;</a></span>findForceOnGroundQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::dvec3 Scene::findForceOnGroundQ </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>searchDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::dvec3 const&#160;</td>
          <td class="paramname"><em>minzv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../d2/da0/classVertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assist doForceOnGround function to find an adequate \(q\) for step 4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchDepth</td><td>The search strategy specification. This function should never be called with searchDepth 0, that case must be skipped at <a class="el" href="../../d5/d9c/classScene.html#a3c173e62cd1c1c31cdd05edcafbee0ab" title="For each scene part which is flagged as forceOnGround, it will be vertically translated to closest gr...">Scene::doForceOnGround</a> directly. Search depth corresponds with the scene part's forceOnGround attribute</td></tr>
  </table>
  </dd>
</dl>
<p>If it is 0 the force on ground process will be skipped. If it is 1, a specific algorithm based on \(q=q_*\) as min \(z\) point will be used. If it is \(&gt;1\), then it specifies the number of search steps to be performed to find \(q\) on a discrete linear search with searchDepth steps. If it is -1, then \( q = \mathrm{argmin}_{q \in Q} \;\;\; q_z - \frac{\left\langle{\hat{v}, \vec{o}}\right\rangle - \left( \hat{v}_x q_x + \hat{v}_y q_y \right)}{\hat{v}_z} \) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minzv</td><td>The \(q_*\) that is used as \(q\) if searchDepth is 1 </td></tr>
    <tr><td class="paramname">vertices</td><td>All vertices defining the scene part to be placed on ground </td></tr>
    <tr><td class="paramname">o</td><td>A point contained in the best fitting ground plane </td></tr>
    <tr><td class="paramname">v</td><td>The normal vector of the best fitting ground plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a3c173e62cd1c1c31cdd05edcafbee0ab" title="For each scene part which is flagged as forceOnGround, it will be vertically translated to closest gr...">Scene::doForceOnGround</a> </dd></dl>

</div>
</div>
<a id="aa9d6bd40ca4908b40dd1d6e14ccea2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d6bd40ca4908b40dd1d6e14ccea2c2">&#9670;&nbsp;</a></span>getAABB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt; Scene::getAABB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the axis aligned bounding box defining scene boundaries. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330" title="Axis aligned bounding box defining scene boundaries.">Scene::bbox</a> </dd></dl>

</div>
</div>
<a id="af46ce55bcb11ce26343b4b72066e0cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46ce55bcb11ce26343b4b72066e0cf5">&#9670;&nbsp;</a></span>getAllVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="../../d2/da0/classVertex.html">Vertex</a> * &gt; Scene::getAllVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain all vertices (without repetitions) composing the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>All vertices (without repetitions) composing the scene </dd></dl>

</div>
</div>
<a id="a18592eb6dd32e43dd35cd95f22cbbb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18592eb6dd32e43dd35cd95f22cbbb11">&#9670;&nbsp;</a></span>getBBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="../../d2/d1a/classAABB.html">AABB</a>&gt; Scene::getBBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the scene's bounding box. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset.">Scene</a>'s bounding box </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330" title="Axis aligned bounding box defining scene boundaries.">Scene::bbox</a> </dd></dl>

</div>
</div>
<a id="afee379217cfb0fc90eb4471274f8de06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee379217cfb0fc90eb4471274f8de06">&#9670;&nbsp;</a></span>getBBoxCRS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="../../d2/d1a/classAABB.html">AABB</a>&gt; Scene::getBBoxCRS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the scene's coordinate reference system bounding box. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset.">Scene</a>'s coordinate reference system bounding box </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330" title="Axis aligned bounding box defining scene boundaries.">Scene::bbox</a> </dd></dl>

</div>
</div>
<a id="a3f056f98c3ab727a98cb7c4ff0f4a754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f056f98c3ab727a98cb7c4ff0f4a754">&#9670;&nbsp;</a></span>getGroundPointAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::dvec3 Scene::getGroundPointAt </td>
          <td>(</td>
          <td class="paramtype">glm::dvec3&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the ground point at specified XY coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point definint the XY coordinates for which the ground point shall be obtained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Intersected ground point </dd></dl>

</div>
</div>
<a id="a25064cb65a0d92828fbf4299e847233f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25064cb65a0d92828fbf4299e847233f">&#9670;&nbsp;</a></span>getIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="../../dc/da3/classRaySceneIntersection.html">RaySceneIntersection</a> &gt; Scene::getIntersection </td>
          <td>(</td>
          <td class="paramtype">glm::dvec3 const &amp;&#160;</td>
          <td class="paramname"><em>rayOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::dvec3 const &amp;&#160;</td>
          <td class="paramname"><em>rayDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>groundOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the intersection between the ray and the scene, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rayOrigin</td><td>Ray origin 3D coordinates </td></tr>
    <tr><td class="paramname">rayDir</td><td>Ray 3D director vector </td></tr>
    <tr><td class="paramname">groundOnly</td><td>Flag to specify if only ground points must be considered (true) or not (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Obtained intersection, nullptr if no intersection was detected </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/da3/classRaySceneIntersection.html" title="Class representing a the intersection of a ray over a scene made of primitives.">RaySceneIntersection</a> </dd>
<dd>
<a class="el" href="../../da/d81/classKDTreeRaycaster.html" title="Class representing a KDTree ray caster.">KDTreeRaycaster</a> </dd>
<dd>
<a class="el" href="../../da/d81/classKDTreeRaycaster.html#aac2bc3f3bd12f1b334496e4b2cc260ee">KDTreeRaycaster::search</a> </dd></dl>

</div>
</div>
<a id="ad1c2a985f4963cd63c708cdb0b58a038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c2a985f4963cd63c708cdb0b58a038">&#9670;&nbsp;</a></span>getIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/da3/classRaySceneIntersection.html">RaySceneIntersection</a> &gt; Scene::getIntersection </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tMinMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::dvec3 const &amp;&#160;</td>
          <td class="paramname"><em>rayOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::dvec3 const &amp;&#160;</td>
          <td class="paramname"><em>rayDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>groundOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like Scene::getIntersection(dvec3 const, dvec3 const, bool const) but receiving precomputed minimum and maximum intersection times with respect to the axis aligned bounding box that bounds the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tMinMax</td><td>The minimum and maximum intersection times </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Scene::getIntersection(dvec3 const, dvec3 const, bool const) </dd></dl>

</div>
</div>
<a id="a4ba5957daaf3ae372e54807cf372ac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba5957daaf3ae372e54807cf372ac35">&#9670;&nbsp;</a></span>getIntersections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; double, <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> * &gt; Scene::getIntersections </td>
          <td>(</td>
          <td class="paramtype">glm::dvec3 &amp;&#160;</td>
          <td class="paramname"><em>rayOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::dvec3 &amp;&#160;</td>
          <td class="paramname"><em>rayDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>groundOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain all intersections between the ray and the scene, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rayOrigin</td><td>Ray origin 3D coordinates </td></tr>
    <tr><td class="paramname">rayDir</td><td>Ray 3D director vector </td></tr>
    <tr><td class="paramname">groundOnly</td><td>Flag to specify if only ground points must be considered (true) or not (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map of all primitives intersected by the ray, which key is the distance with respect to ray origin </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/da3/classRaySceneIntersection.html" title="Class representing a the intersection of a ray over a scene made of primitives.">RaySceneIntersection</a> </dd>
<dd>
<a class="el" href="../../da/d81/classKDTreeRaycaster.html" title="Class representing a KDTree ray caster.">KDTreeRaycaster</a> </dd>
<dd>
<a class="el" href="../../da/d81/classKDTreeRaycaster.html#a0dfe186a398e4131f4a11963cf8d3224">KDTreeRaycaster::searchAll</a> </dd></dl>

</div>
</div>
<a id="a1aaf897197924c7a5c6affeeccc0c83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aaf897197924c7a5c6affeeccc0c83c">&#9670;&nbsp;</a></span>getKDGrove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="../../d9/d76/classKDGrove.html">KDGrove</a>&gt; Scene::getKDGrove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> used by the scene. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> used by the scene </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a7cf88b807d54fc552db7551a3ab0aae4" title="KDGrove containing a KDTree for each scene part to speed-up ray-primitive intersection check computat...">Scene::kdgrove</a> </dd></dl>

</div>
</div>
<a id="a96110a189ae4bbb60855ecc14afd3138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96110a189ae4bbb60855ecc14afd3138">&#9670;&nbsp;</a></span>getKDGroveFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="../../de/d89/classKDGroveFactory.html">KDGroveFactory</a>&gt; Scene::getKDGroveFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> factory used by the scene. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> factory used by the scene </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a3468275e1f969eea9aceae7962123483" title="The KDGrove factory used to build the scene KDGrove.">Scene::kdgf</a> </dd></dl>

</div>
</div>
<a id="a1efb5df7a0b3c59c2a6d0d85c6485a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efb5df7a0b3c59c2a6d0d85c6485a84">&#9670;&nbsp;</a></span>getShift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::dvec3 Scene::getShift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the minimum boundaries of the original axis aligned bounding box containing the scene, before it was centered so (0, 0, 0) became its new minimum boundaries. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimum boundaries of the original axis aligned bounding box, before translating to (0, 0, 0) </dd></dl>

</div>
</div>
<a id="a4da8f4527d42c258d28ec94dea031481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da8f4527d42c258d28ec94dea031481">&#9670;&nbsp;</a></span>getShiftRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::dvec3 const&amp; Scene::getShiftRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="../../d5/d9c/classScene.html#a1efb5df7a0b3c59c2a6d0d85c6485a84" title="Obtain the minimum boundaries of the original axis aligned bounding box containing the scene,...">Scene::getShift</a> but returning a const reference instead of a copy. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a1efb5df7a0b3c59c2a6d0d85c6485a84" title="Obtain the minimum boundaries of the original axis aligned bounding box containing the scene,...">Scene::getShift</a> </dd></dl>

</div>
</div>
<a id="afd8798b09857e4df7adf05dea25210ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8798b09857e4df7adf05dea25210ab">&#9670;&nbsp;</a></span>hasMovingObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Scene::hasMovingObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checke whether the scene contains at least one moving object (true) or not (false) </p>
<dl class="section return"><dt>Returns</dt><dd>True if scene hast at least one moving objects, false otherwise </dd></dl>

</div>
</div>
<a id="ac68d340293560035fb043da042a26e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68d340293560035fb043da042a26e85">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const&#160;</td>
          <td class="paramname"><em>fileVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle scene load operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>Type of rendering </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Specific rendering for the stream of bytes </td></tr>
    <tr><td class="paramname">s</td><td><a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset.">Scene</a> to be loaded </td></tr>
    <tr><td class="paramname">version</td><td>Version number for the <a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset.">Scene</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ce25df38164ed98cf695bc8042bc6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce25df38164ed98cf695bc8042bc6a5">&#9670;&nbsp;</a></span>readObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d9c/classScene.html">Scene</a> * Scene::readObject </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read serialized scene from given file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to file where a serialized scene is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Imported scene </dd></dl>

</div>
</div>
<a id="a866e2103680b966d076df0121f147e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866e2103680b966d076df0121f147e6d">&#9670;&nbsp;</a></span>registerParts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::registerParts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register all scene parts composing the scene in the parts vector with no repetitions. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a3cc4bc214f0f830bb96ad276c0bdce98" title="Parts composing the scene with no repeats.">Scene::parts</a> </dd></dl>

</div>
</div>
<a id="a4d6039c2337a5085570ab6a9b8cb7683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6039c2337a5085570ab6a9b8cb7683">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle scene save operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>Type of rendering </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Specific rendering for the stream of bytes </td></tr>
    <tr><td class="paramname">s</td><td><a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset.">Scene</a> to be saved </td></tr>
    <tr><td class="paramname">version</td><td>Version number for the <a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset.">Scene</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf1c82c4bcd7b6bb176b29c523c15575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1c82c4bcd7b6bb176b29c523c15575">&#9670;&nbsp;</a></span>setBBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scene::setBBox </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt; const&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scene's bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>New bounding box for the scene </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330" title="Axis aligned bounding box defining scene boundaries.">Scene::bbox</a> </dd></dl>

</div>
</div>
<a id="af4c42cb5df37ce7340ef497e84e9eacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c42cb5df37ce7340ef497e84e9eacb">&#9670;&nbsp;</a></span>setBBoxCRS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scene::setBBoxCRS </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt; const&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scene's coordinate reference system bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>New coordinate reference system bounding box for the scene </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330" title="Axis aligned bounding box defining scene boundaries.">Scene::bbox</a> </dd></dl>

</div>
</div>
<a id="aa6c3368fd1ebce8848b9480ce39bfd2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c3368fd1ebce8848b9480ce39bfd2d">&#9670;&nbsp;</a></span>setKDGrove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scene::setKDGrove </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d9/d76/classKDGrove.html">KDGrove</a> &gt; const&#160;</td>
          <td class="paramname"><em>kdgrove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> to be used by the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdgrove</td><td>New <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> to be used by the scene </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Scene::kdtree </dd></dl>

</div>
</div>
<a id="a1b11a57368136ed5373c6362da5f732c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b11a57368136ed5373c6362da5f732c">&#9670;&nbsp;</a></span>setKDGroveFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scene::setKDGroveFactory </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/d89/classKDGroveFactory.html">KDGroveFactory</a> &gt; const&#160;</td>
          <td class="paramname"><em>kdgf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> factory to be used by the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdgf</td><td>New <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> factory to be used by the scene </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a3468275e1f969eea9aceae7962123483" title="The KDGrove factory used to build the scene KDGrove.">Scene::kdgf</a> </dd></dl>

</div>
</div>
<a id="a782302f4dc1703617d5292251bda044e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782302f4dc1703617d5292251bda044e">&#9670;&nbsp;</a></span>writeObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::writeObject </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize the scene and write it to given output file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to output file where serialized scene shall be stored </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../dd/d34/classStaticScene.html#a72bbc2d954c30d0ea5017e69bf1ee047">StaticScene</a>, and <a class="el" href="../../de/d74/classDynScene.html#a529a2939ee6a7fb973ad19cc298d6ff1">DynScene</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3468275e1f969eea9aceae7962123483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3468275e1f969eea9aceae7962123483">&#9670;&nbsp;</a></span>kdgf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="../../de/d89/classKDGroveFactory.html">KDGroveFactory</a>&gt; Scene::kdgf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a> factory used to build the scene <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d89/classKDGroveFactory.html">KDGroveFactory</a> </dd>
<dd>
<a class="el" href="../../d5/d9c/classScene.html#a7cf88b807d54fc552db7551a3ab0aae4" title="KDGrove containing a KDTree for each scene part to speed-up ray-primitive intersection check computat...">Scene::kdgrove</a> </dd></dl>

</div>
</div>
<a id="a3cc4bc214f0f830bb96ad276c0bdce98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc4bc214f0f830bb96ad276c0bdce98">&#9670;&nbsp;</a></span>parts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="../../dd/dc4/classScenePart.html">ScenePart</a>&gt; &gt; Scene::parts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parts composing the scene with no repeats. </p>
<p>Please avoid manually computing this vector. If it is necessary to initialize or update it, call registerParts instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a866e2103680b966d076df0121f147e6d" title="Register all scene parts composing the scene in the parts vector with no repetitions.">Scene::registerParts</a> </dd></dl>

</div>
</div>
<a id="aac4d9a2ecbfe18318a5953905fa57fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4d9a2ecbfe18318a5953905fa57fb9">&#9670;&nbsp;</a></span>raycaster</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="../../df/d01/classKDGroveRaycaster.html">KDGroveRaycaster</a>&gt; Scene::raycaster</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raycaster based on <a class="el" href="../../d9/d76/classKDGrove.html" title="Grove of KDTrees. It supports both static and dynamic KDTrees, handling each accordingly.">KDGrove</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a7cf88b807d54fc552db7551a3ab0aae4" title="KDGrove containing a KDTree for each scene part to speed-up ray-primitive intersection check computat...">Scene::kdgrove</a> </dd>
<dd>
<a class="el" href="../../d5/d9c/classScene.html#a25064cb65a0d92828fbf4299e847233f" title="Obtain the intersection between the ray and the scene, if any.">Scene::getIntersection</a> </dd>
<dd>
<a class="el" href="../../d5/d9c/classScene.html#a4ba5957daaf3ae372e54807cf372ac35" title="Obtain all intersections between the ray and the scene, if any.">Scene::getIntersections</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/scene/<a class="el" href="../../d5/d2d/Scene_8h_source.html">Scene.h</a></li>
<li>src/scene/Scene.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d5/d9c/classScene.html">Scene</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
