<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios++: Scene Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Helios++
   </div>
   <div id="projectbrief">Helios software for LiDAR simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d5/d9c/classScene.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../db/d67/classScene-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Scene Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class representing a scene asset.  
 <a href="../../d5/d9c/classScene.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/d2d/Scene_8h_source.html">Scene.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Scene:</div>
<div class="dyncontent">
<div class="center"><img src="../../d2/d20/classScene__inherit__graph.png" border="0" usemap="#Scene_inherit__map" alt="Inheritance graph"/></div>
<map name="Scene_inherit__map" id="Scene_inherit__map">
<area shape="rect" id="node3" href="../../dd/d34/classStaticScene.html" title="Static scene basic implementation. " alt="" coords="5,155,99,181"/>
<area shape="rect" id="node2" href="../../de/d97/classAsset.html" title="Base class for all assets. " alt="" coords="24,5,80,32"/>
<area shape="rect" id="node4" href="../../de/d74/classDynScene.html" title="Dynamic scene base implementation. " alt="" coords="11,229,93,256"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Scene:</div>
<div class="dyncontent">
<div class="center"><img src="../../d5/d11/classScene__coll__graph.png" border="0" usemap="#Scene_coll__map" alt="Collaboration graph"/></div>
<map name="Scene_coll__map" id="Scene_coll__map">
<area shape="rect" id="node2" href="../../de/d97/classAsset.html" title="Base class for all assets. " alt="" coords="7,124,63,151"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad10176d75a9cc0da56626f682d083507"><td class="memItemLeft" align="right" valign="top"><a id="ad10176d75a9cc0da56626f682d083507"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#ad10176d75a9cc0da56626f682d083507">Scene</a> ()</td></tr>
<tr class="memdesc:ad10176d75a9cc0da56626f682d083507"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset. ">Scene</a> default constructor. <br /></td></tr>
<tr class="separator:ad10176d75a9cc0da56626f682d083507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eca6af7cda6d6bd8bf5ae19597f9ddc"><td class="memItemLeft" align="right" valign="top"><a id="a9eca6af7cda6d6bd8bf5ae19597f9ddc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Scene</b> (<a class="el" href="../../d5/d9c/classScene.html">Scene</a> &amp;s)</td></tr>
<tr class="separator:a9eca6af7cda6d6bd8bf5ae19597f9ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8e9900ddf447c30d4ff869e3f0c152"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#adb8e9900ddf447c30d4ff869e3f0c152">finalizeLoading</a> (bool const safe=false)</td></tr>
<tr class="memdesc:adb8e9900ddf447c30d4ff869e3f0c152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle scene loading finish process.  <a href="#adb8e9900ddf447c30d4ff869e3f0c152">More...</a><br /></td></tr>
<tr class="separator:adb8e9900ddf447c30d4ff869e3f0c152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866e2103680b966d076df0121f147e6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a866e2103680b966d076df0121f147e6d">registerParts</a> ()</td></tr>
<tr class="memdesc:a866e2103680b966d076df0121f147e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register all scene parts composing the scene in the parts vector with no repetitions.  <a href="#a866e2103680b966d076df0121f147e6d">More...</a><br /></td></tr>
<tr class="separator:a866e2103680b966d076df0121f147e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d6bd40ca4908b40dd1d6e14ccea2c2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#aa9d6bd40ca4908b40dd1d6e14ccea2c2">getAABB</a> ()</td></tr>
<tr class="memdesc:aa9d6bd40ca4908b40dd1d6e14ccea2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the axis aligned bounding box defining scene boundaries.  <a href="#aa9d6bd40ca4908b40dd1d6e14ccea2c2">More...</a><br /></td></tr>
<tr class="separator:aa9d6bd40ca4908b40dd1d6e14ccea2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f056f98c3ab727a98cb7c4ff0f4a754"><td class="memItemLeft" align="right" valign="top">glm::dvec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a3f056f98c3ab727a98cb7c4ff0f4a754">getGroundPointAt</a> (glm::dvec3 point)</td></tr>
<tr class="memdesc:a3f056f98c3ab727a98cb7c4ff0f4a754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the ground point at specified XY coordinates.  <a href="#a3f056f98c3ab727a98cb7c4ff0f4a754">More...</a><br /></td></tr>
<tr class="separator:a3f056f98c3ab727a98cb7c4ff0f4a754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4780b1867590175d6e48f2550b4ccdf4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/da3/classRaySceneIntersection.html">RaySceneIntersection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a4780b1867590175d6e48f2550b4ccdf4">getIntersection</a> (glm::dvec3 &amp;rayOrigin, glm::dvec3 &amp;rayDir, bool groundOnly)</td></tr>
<tr class="memdesc:a4780b1867590175d6e48f2550b4ccdf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the intersection between the ray and the scene, if any.  <a href="#a4780b1867590175d6e48f2550b4ccdf4">More...</a><br /></td></tr>
<tr class="separator:a4780b1867590175d6e48f2550b4ccdf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0493bdc9aa66ed4143dac01d3ceeda4e"><td class="memItemLeft" align="right" valign="top">std::map&lt; double, <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a0493bdc9aa66ed4143dac01d3ceeda4e">getIntersections</a> (glm::dvec3 &amp;rayOrigin, glm::dvec3 &amp;rayDir, bool groundOnly)</td></tr>
<tr class="memdesc:a0493bdc9aa66ed4143dac01d3ceeda4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain all intersections between the ray and the scene, if any.  <a href="#a0493bdc9aa66ed4143dac01d3ceeda4e">More...</a><br /></td></tr>
<tr class="separator:a0493bdc9aa66ed4143dac01d3ceeda4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efb5df7a0b3c59c2a6d0d85c6485a84"><td class="memItemLeft" align="right" valign="top">glm::dvec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a1efb5df7a0b3c59c2a6d0d85c6485a84">getShift</a> ()</td></tr>
<tr class="memdesc:a1efb5df7a0b3c59c2a6d0d85c6485a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the minimum boundaries of the original axis aligned bounding box containing the scene, before it was centered so (0, 0, 0) became its new minimum boundaries.  <a href="#a1efb5df7a0b3c59c2a6d0d85c6485a84">More...</a><br /></td></tr>
<tr class="separator:a1efb5df7a0b3c59c2a6d0d85c6485a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ce55bcb11ce26343b4b72066e0cf5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d2/da0/classVertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#af46ce55bcb11ce26343b4b72066e0cf5">getAllVertices</a> ()</td></tr>
<tr class="memdesc:af46ce55bcb11ce26343b4b72066e0cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain all vertices (without repetitions) composing the scene.  <a href="#af46ce55bcb11ce26343b4b72066e0cf5">More...</a><br /></td></tr>
<tr class="separator:af46ce55bcb11ce26343b4b72066e0cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c173e62cd1c1c31cdd05edcafbee0ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a3c173e62cd1c1c31cdd05edcafbee0ab">doForceOnGround</a> ()</td></tr>
<tr class="memdesc:a3c173e62cd1c1c31cdd05edcafbee0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each scene part which is flagged as forceOnGround, it will be vertically translated to closest ground scene part.  <a href="#a3c173e62cd1c1c31cdd05edcafbee0ab">More...</a><br /></td></tr>
<tr class="separator:a3c173e62cd1c1c31cdd05edcafbee0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd93c3c45cb22ba6fa6c6f7da1dcb01"><td class="memItemLeft" align="right" valign="top">glm::dvec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#abbd93c3c45cb22ba6fa6c6f7da1dcb01">findForceOnGroundQ</a> (int const searchDepth, glm::dvec3 const minzv, vector&lt; <a class="el" href="../../d2/da0/classVertex.html">Vertex</a> *&gt; &amp;vertices, vector&lt; double &gt; const &amp;o, vector&lt; double &gt; const &amp;v)</td></tr>
<tr class="memdesc:abbd93c3c45cb22ba6fa6c6f7da1dcb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assist doForceOnGround function to find an adequate \(q\) for step 4.  <a href="#abbd93c3c45cb22ba6fa6c6f7da1dcb01">More...</a><br /></td></tr>
<tr class="separator:abbd93c3c45cb22ba6fa6c6f7da1dcb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7059974718edb201526fb4075ec7eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#af7059974718edb201526fb4075ec7eb7">buildKDTree</a> (bool const safe=false)</td></tr>
<tr class="memdesc:af7059974718edb201526fb4075ec7eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the KDTree for the scene, overwriting previous one if any.  <a href="#af7059974718edb201526fb4075ec7eb7">More...</a><br /></td></tr>
<tr class="separator:af7059974718edb201526fb4075ec7eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f559623cbaa92f0245162dc90b33769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a2f559623cbaa92f0245162dc90b33769">buildKDTreeWithLog</a> (bool const safe=false)</td></tr>
<tr class="memdesc:a2f559623cbaa92f0245162dc90b33769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call buildKDTree exporting building information through logging system.  <a href="#a2f559623cbaa92f0245162dc90b33769">More...</a><br /></td></tr>
<tr class="separator:a2f559623cbaa92f0245162dc90b33769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac283c25701a6addafe99071740a15058"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#ac283c25701a6addafe99071740a15058">getKDTreeFactory</a> () const</td></tr>
<tr class="memdesc:ac283c25701a6addafe99071740a15058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the KDTree factory used by the scene.  <a href="#ac283c25701a6addafe99071740a15058">More...</a><br /></td></tr>
<tr class="separator:ac283c25701a6addafe99071740a15058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9fc8b80b0e0841421549f1b752f2c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#aed9fc8b80b0e0841421549f1b752f2c9">setKDTreeFactory</a> (std::shared_ptr&lt; <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a> &gt; const <a class="el" href="../../d5/d9c/classScene.html#a5b4ca990006db81ed71b4850923b1414">kdtf</a>)</td></tr>
<tr class="memdesc:aed9fc8b80b0e0841421549f1b752f2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the KDTree factory to be used by the scene.  <a href="#aed9fc8b80b0e0841421549f1b752f2c9">More...</a><br /></td></tr>
<tr class="separator:aed9fc8b80b0e0841421549f1b752f2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c95521ec543d494b99f44be0c9042ac"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a2c95521ec543d494b99f44be0c9042ac">getKDTree</a> () const</td></tr>
<tr class="memdesc:a2c95521ec543d494b99f44be0c9042ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the KDTree used by the scene.  <a href="#a2c95521ec543d494b99f44be0c9042ac">More...</a><br /></td></tr>
<tr class="separator:a2c95521ec543d494b99f44be0c9042ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4ea56f0bda2d033133cb02b8f38888"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a4f4ea56f0bda2d033133cb02b8f38888">setKDTree</a> (std::shared_ptr&lt; <a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> &gt; const <a class="el" href="../../d5/d9c/classScene.html#a4d1d59711628b8599f766b0700a02b2f">kdtree</a>)</td></tr>
<tr class="memdesc:a4f4ea56f0bda2d033133cb02b8f38888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the KDTree to be used by the scene.  <a href="#a4f4ea56f0bda2d033133cb02b8f38888">More...</a><br /></td></tr>
<tr class="separator:a4f4ea56f0bda2d033133cb02b8f38888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18592eb6dd32e43dd35cd95f22cbbb11"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a18592eb6dd32e43dd35cd95f22cbbb11">getBBox</a> () const</td></tr>
<tr class="memdesc:a18592eb6dd32e43dd35cd95f22cbbb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the scene's bounding box.  <a href="#a18592eb6dd32e43dd35cd95f22cbbb11">More...</a><br /></td></tr>
<tr class="separator:a18592eb6dd32e43dd35cd95f22cbbb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1c82c4bcd7b6bb176b29c523c15575"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#acf1c82c4bcd7b6bb176b29c523c15575">setBBox</a> (std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt; const <a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330">bbox</a>)</td></tr>
<tr class="memdesc:acf1c82c4bcd7b6bb176b29c523c15575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene's bounding box.  <a href="#acf1c82c4bcd7b6bb176b29c523c15575">More...</a><br /></td></tr>
<tr class="separator:acf1c82c4bcd7b6bb176b29c523c15575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee379217cfb0fc90eb4471274f8de06"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#afee379217cfb0fc90eb4471274f8de06">getBBoxCRS</a> () const</td></tr>
<tr class="memdesc:afee379217cfb0fc90eb4471274f8de06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the scene's coordinate reference system bounding box.  <a href="#afee379217cfb0fc90eb4471274f8de06">More...</a><br /></td></tr>
<tr class="separator:afee379217cfb0fc90eb4471274f8de06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c42cb5df37ce7340ef497e84e9eacb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#af4c42cb5df37ce7340ef497e84e9eacb">setBBoxCRS</a> (std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt; const <a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330">bbox</a>)</td></tr>
<tr class="memdesc:af4c42cb5df37ce7340ef497e84e9eacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene's coordinate reference system bounding box.  <a href="#af4c42cb5df37ce7340ef497e84e9eacb">More...</a><br /></td></tr>
<tr class="separator:af4c42cb5df37ce7340ef497e84e9eacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782302f4dc1703617d5292251bda044e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a782302f4dc1703617d5292251bda044e">writeObject</a> (std::string path)</td></tr>
<tr class="memdesc:a782302f4dc1703617d5292251bda044e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the scene and write it to given output file.  <a href="#a782302f4dc1703617d5292251bda044e">More...</a><br /></td></tr>
<tr class="separator:a782302f4dc1703617d5292251bda044e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classAsset"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classAsset')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../de/d97/classAsset.html">Asset</a></td></tr>
<tr class="memitem:a9ad0c79df694d3f079daba3eedf0284c inherit pub_methods_classAsset"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classAsset.html#a9ad0c79df694d3f079daba3eedf0284c">getLocationString</a> ()</td></tr>
<tr class="memdesc:a9ad0c79df694d3f079daba3eedf0284c inherit pub_methods_classAsset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain asset location string.  <a href="../../de/d97/classAsset.html#a9ad0c79df694d3f079daba3eedf0284c">More...</a><br /></td></tr>
<tr class="separator:a9ad0c79df694d3f079daba3eedf0284c inherit pub_methods_classAsset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1ce25df38164ed98cf695bc8042bc6a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d5/d9c/classScene.html">Scene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a1ce25df38164ed98cf695bc8042bc6a5">readObject</a> (std::string path)</td></tr>
<tr class="memdesc:a1ce25df38164ed98cf695bc8042bc6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read serialized scene from given file.  <a href="#a1ce25df38164ed98cf695bc8042bc6a5">More...</a><br /></td></tr>
<tr class="separator:a1ce25df38164ed98cf695bc8042bc6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7006d57329f8e8d8563e9ff54ddcb2fc"><td class="memItemLeft" align="right" valign="top"><a id="a7006d57329f8e8d8563e9ff54ddcb2fc"></a>
std::vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a7006d57329f8e8d8563e9ff54ddcb2fc">primitives</a></td></tr>
<tr class="memdesc:a7006d57329f8e8d8563e9ff54ddcb2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of primitives composing the scene. <br /></td></tr>
<tr class="separator:a7006d57329f8e8d8563e9ff54ddcb2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc4bc214f0f830bb96ad276c0bdce98"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../dd/dc4/classScenePart.html">ScenePart</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a3cc4bc214f0f830bb96ad276c0bdce98">parts</a></td></tr>
<tr class="memdesc:a3cc4bc214f0f830bb96ad276c0bdce98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parts composing the scene with no repeats.  <a href="#a3cc4bc214f0f830bb96ad276c0bdce98">More...</a><br /></td></tr>
<tr class="separator:a3cc4bc214f0f830bb96ad276c0bdce98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classAsset"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classAsset')"><img src="../../closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="../../de/d97/classAsset.html">Asset</a></td></tr>
<tr class="memitem:ac37173d6b01d7b8caa7bd786b8de2269 inherit pub_attribs_classAsset"><td class="memItemLeft" align="right" valign="top"><a id="ac37173d6b01d7b8caa7bd786b8de2269"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classAsset.html#ac37173d6b01d7b8caa7bd786b8de2269">id</a> = &quot;&quot;</td></tr>
<tr class="memdesc:ac37173d6b01d7b8caa7bd786b8de2269 inherit pub_attribs_classAsset"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/d97/classAsset.html" title="Base class for all assets. ">Asset</a> identifier. <br /></td></tr>
<tr class="separator:ac37173d6b01d7b8caa7bd786b8de2269 inherit pub_attribs_classAsset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7c46a97929723eed3a5f73a3542bb9 inherit pub_attribs_classAsset"><td class="memItemLeft" align="right" valign="top"><a id="aaa7c46a97929723eed3a5f73a3542bb9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classAsset.html#aaa7c46a97929723eed3a5f73a3542bb9">name</a> = &quot;Unnamed <a class="el" href="../../de/d97/classAsset.html">Asset</a>&quot;</td></tr>
<tr class="memdesc:aaa7c46a97929723eed3a5f73a3542bb9 inherit pub_attribs_classAsset"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/d97/classAsset.html" title="Base class for all assets. ">Asset</a> name. <br /></td></tr>
<tr class="separator:aaa7c46a97929723eed3a5f73a3542bb9 inherit pub_attribs_classAsset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9b323b6f7e7f343dacb278d3610645 inherit pub_attribs_classAsset"><td class="memItemLeft" align="right" valign="top"><a id="a8a9b323b6f7e7f343dacb278d3610645"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classAsset.html#a8a9b323b6f7e7f343dacb278d3610645">sourceFilePath</a> = &quot;&quot;</td></tr>
<tr class="memdesc:a8a9b323b6f7e7f343dacb278d3610645 inherit pub_attribs_classAsset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to asset file. <br /></td></tr>
<tr class="separator:a8a9b323b6f7e7f343dacb278d3610645 inherit pub_attribs_classAsset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5b4ca990006db81ed71b4850923b1414"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a5b4ca990006db81ed71b4850923b1414">kdtf</a></td></tr>
<tr class="memdesc:a5b4ca990006db81ed71b4850923b1414"><td class="mdescLeft">&#160;</td><td class="mdescRight">The KDTree factory used to build the scene KDTree.  <a href="#a5b4ca990006db81ed71b4850923b1414">More...</a><br /></td></tr>
<tr class="separator:a5b4ca990006db81ed71b4850923b1414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1d59711628b8599f766b0700a02b2f"><td class="memItemLeft" align="right" valign="top"><a id="a4d1d59711628b8599f766b0700a02b2f"></a>
std::shared_ptr&lt; <a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a4d1d59711628b8599f766b0700a02b2f">kdtree</a></td></tr>
<tr class="memdesc:a4d1d59711628b8599f766b0700a02b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">KDTree splitting scene points/vertices to speed-up intersection computations. <br /></td></tr>
<tr class="separator:a4d1d59711628b8599f766b0700a02b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012be28a1b960338f634d5fec54c5330"><td class="memItemLeft" align="right" valign="top"><a id="a012be28a1b960338f634d5fec54c5330"></a>
std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330">bbox</a></td></tr>
<tr class="memdesc:a012be28a1b960338f634d5fec54c5330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis aligned bounding box defining scene boundaries. <br /></td></tr>
<tr class="separator:a012be28a1b960338f634d5fec54c5330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6443452016957950e3a7260dcc0076f1"><td class="memItemLeft" align="right" valign="top"><a id="a6443452016957950e3a7260dcc0076f1"></a>
std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a6443452016957950e3a7260dcc0076f1">bbox_crs</a></td></tr>
<tr class="memdesc:a6443452016957950e3a7260dcc0076f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Original axis aligned bounding box defining scene boundaries before centering it. <br /></td></tr>
<tr class="separator:a6443452016957950e3a7260dcc0076f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4d6039c2337a5085570ab6a9b8cb7683"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a4d6039c2337a5085570ab6a9b8cb7683"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#a4d6039c2337a5085570ab6a9b8cb7683">save</a> (Archive &amp;ar, unsigned int const version) const</td></tr>
<tr class="memdesc:a4d6039c2337a5085570ab6a9b8cb7683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle scene save operation.  <a href="#a4d6039c2337a5085570ab6a9b8cb7683">More...</a><br /></td></tr>
<tr class="separator:a4d6039c2337a5085570ab6a9b8cb7683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68d340293560035fb043da042a26e85"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ac68d340293560035fb043da042a26e85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d9c/classScene.html#ac68d340293560035fb043da042a26e85">load</a> (Archive &amp;ar, unsigned int const fileVersion)</td></tr>
<tr class="memdesc:ac68d340293560035fb043da042a26e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle scene load operation.  <a href="#ac68d340293560035fb043da042a26e85">More...</a><br /></td></tr>
<tr class="separator:ac68d340293560035fb043da042a26e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362e319a7d418a6905a6aa3b82065a5a"><td class="memItemLeft" align="right" valign="top"><a id="a362e319a7d418a6905a6aa3b82065a5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_SERIALIZATION_SPLIT_MEMBER</b> ()</td></tr>
<tr class="separator:a362e319a7d418a6905a6aa3b82065a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top"><a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::serialization::access</b></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing a scene asset. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af7059974718edb201526fb4075ec7eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7059974718edb201526fb4075ec7eb7">&#9670;&nbsp;</a></span>buildKDTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::buildKDTree </td>
          <td>(</td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>safe</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the KDTree for the scene, overwriting previous one if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">safe</td><td>The same safe as the one received by finalizeSceneLoading </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Scene::finalizeSceneLoading </dd></dl>

</div>
</div>
<a id="a2f559623cbaa92f0245162dc90b33769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f559623cbaa92f0245162dc90b33769">&#9670;&nbsp;</a></span>buildKDTreeWithLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::buildKDTreeWithLog </td>
          <td>(</td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>safe</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call buildKDTree exporting building information through logging system. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#af7059974718edb201526fb4075ec7eb7" title="Build the KDTree for the scene, overwriting previous one if any. ">Scene::buildKDTree</a> </dd></dl>

</div>
</div>
<a id="a3c173e62cd1c1c31cdd05edcafbee0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c173e62cd1c1c31cdd05edcafbee0ab">&#9670;&nbsp;</a></span>doForceOnGround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::doForceOnGround </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each scene part which is flagged as forceOnGround, it will be vertically translated to closest ground scene part. </p>
<p>This function requires that there is at least one scene part flagged as ground, otherwise it is not possible to apply it. The algorithm can be described in 5 steps:</p>
<ol type="1">
<li>For any ground scene part, find its min \(a_i = (a_{ix}, a_{iy}, a_{iz})\) and max \(b_i = (b_{ix}, b_{iy}, b_{iz})\) vertices.</li>
<li><p class="startli">Let the scene part to be placed on ground be defined by its \(m\) vertices, such that \(Q = \left\{q_1, \ldots, q_m\right\}\). Also, let it be represented by its minimum \(z\) vertex \(q_* = (q_{*x}, q_{*y}, q_{*z}) \). Thus, the first found ground scene part such that \(q_*\) is inside its \(\mathbb{R}^{2}\) boundaries is considered as the ground reference. More formally, it must be satisfied that:</p>
<p class="formulaDsp">
\[ q_{*x} \in [a_{ix}, b_{ix}] \land q_{*y} \in [a_{iy}, b_{iy}] \]
</p>
</li>
<li><p class="startli">Find the best fitting plane \(\pi\) with respect to vertices of ground reference, which orthonormal vector is noted as \(\hat{v}\)</p>
<p class="formulaDsp">
\[ \pi = \left\{ p=(x, y, z) : \left\langle{\overrightarrow{op}, \hat{v}}\right\rangle = 0 \right\} \]
</p>
</li>
<li><p class="startli">Compute the vertical projection of \(q\) on best fitting ground plane \(\pi\) as follows:</p>
<p class="formulaDsp">
\[ \begin{array}{lll} \mathcal{P}^{z}_{\pi}(q) &amp;=&amp; \left( q_{x}, q_{y}, \frac{ \hat{v}_x o_x + \hat{v}_y o_y + \hat{v}_z o_z - \hat{v}_x q_{x} - \hat{v}_y q_{y} } {\hat{v}_z} \right) \\ &amp;=&amp; \left( q_{x}, q_{y}, \frac{ \left\langle{\hat{v}, \vec{o}}\right\rangle - \hat{v}_x q_{x} - \hat{v}_y q_{y} }{\hat{v}_z} \right) \\ &amp;=&amp; (p_x, p_y, p_z) \\ &amp;=&amp; p \end{array} \]
</p>
<p class="startli">Where \(q\) varies depending on search depth, as explained in parameter documentation at the <a class="el" href="../../d5/d9c/classScene.html#abbd93c3c45cb22ba6fa6c6f7da1dcb01" title="Assist doForceOnGround function to find an adequate  for step 4. ">Scene::findForceOnGroundQ</a> function.</p>
</li>
<li><p class="startli">Let \(\Delta_z = q_{*z} - p_z\) be the magnitude of vertical translation for the entire scene part. Now, each vertex defining the scene part must be translated so:</p>
<p class="formulaDsp">
\[ \forall q_i \in Q,\, q&#39;_i = (q_{ix}, q_{iy}, q_{iz} - \Delta_z) \]
</p>
</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#abbd93c3c45cb22ba6fa6c6f7da1dcb01" title="Assist doForceOnGround function to find an adequate  for step 4. ">Scene::findForceOnGroundQ</a> </dd></dl>

</div>
</div>
<a id="adb8e9900ddf447c30d4ff869e3f0c152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8e9900ddf447c30d4ff869e3f0c152">&#9670;&nbsp;</a></span>finalizeLoading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scene::finalizeLoading </td>
          <td>(</td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>safe</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle scene loading finish process. </p>
<p>Computations such as primitives update and centering the scene (all its vertices) so the axis aligned bounding box defining its boundaries start at (0, 0, 0) and also KDTree building are performed here</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">safe</td><td>Enable safe mode (true) or disable it (false). Safe mode is mainly useful for debugging purposes because it prevents certain changes such as modification of primitives ordering. Whenever safe mode is not necessary, it is recommended to set it to false as enabling it might lead to a slowdown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if scene loading was successfully finished, false otherwise </dd></dl>

</div>
</div>
<a id="abbd93c3c45cb22ba6fa6c6f7da1dcb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd93c3c45cb22ba6fa6c6f7da1dcb01">&#9670;&nbsp;</a></span>findForceOnGroundQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::dvec3 Scene::findForceOnGroundQ </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>searchDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::dvec3 const&#160;</td>
          <td class="paramname"><em>minzv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../d2/da0/classVertex.html">Vertex</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assist doForceOnGround function to find an adequate \(q\) for step 4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchDepth</td><td>The search strategy specification. This function should never be called with searchDepth 0, that case must be skipped at <a class="el" href="../../d5/d9c/classScene.html#a3c173e62cd1c1c31cdd05edcafbee0ab" title="For each scene part which is flagged as forceOnGround, it will be vertically translated to closest gr...">Scene::doForceOnGround</a> directly. Search depth corresponds with the scene part's forceOnGround attribute</td></tr>
  </table>
  </dd>
</dl>
<p>If it is 0 the force on ground process will be skipped. If it is 1, a specific algorithm based on \(q=q_*\) as min \(z\) point will be used. If it is \(&gt;1\), then it specifies the number of search steps to be performed to find \(q\) on a discrete linear search with searchDepth steps. If it is -1, then \( q = \mathrm{argmin}_{q \in Q} \;\;\; q_z - \frac{\left\langle{\hat{v}, \vec{o}}\right\rangle - \left( \hat{v}_x q_x + \hat{v}_y q_y \right)}{\hat{v}_z} \) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minzv</td><td>The \(q_*\) that is used as \(q\) if searchDepth is 1 </td></tr>
    <tr><td class="paramname">vertices</td><td>All vertices defining the scene part to be placed on ground </td></tr>
    <tr><td class="paramname">o</td><td>A point contained in the best fitting ground plane </td></tr>
    <tr><td class="paramname">v</td><td>The normal vector of the best fitting ground plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a3c173e62cd1c1c31cdd05edcafbee0ab" title="For each scene part which is flagged as forceOnGround, it will be vertically translated to closest gr...">Scene::doForceOnGround</a> </dd></dl>

</div>
</div>
<a id="aa9d6bd40ca4908b40dd1d6e14ccea2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d6bd40ca4908b40dd1d6e14ccea2c2">&#9670;&nbsp;</a></span>getAABB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt; Scene::getAABB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the axis aligned bounding box defining scene boundaries. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330" title="Axis aligned bounding box defining scene boundaries. ">Scene::bbox</a> </dd></dl>

</div>
</div>
<a id="af46ce55bcb11ce26343b4b72066e0cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46ce55bcb11ce26343b4b72066e0cf5">&#9670;&nbsp;</a></span>getAllVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="../../d2/da0/classVertex.html">Vertex</a> * &gt; Scene::getAllVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain all vertices (without repetitions) composing the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>All vertices (without repetitions) composing the scene </dd></dl>

</div>
</div>
<a id="a18592eb6dd32e43dd35cd95f22cbbb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18592eb6dd32e43dd35cd95f22cbbb11">&#9670;&nbsp;</a></span>getBBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="../../d2/d1a/classAABB.html">AABB</a>&gt; Scene::getBBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the scene's bounding box. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset. ">Scene</a>'s bounding box </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330" title="Axis aligned bounding box defining scene boundaries. ">Scene::bbox</a> </dd></dl>

</div>
</div>
<a id="afee379217cfb0fc90eb4471274f8de06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee379217cfb0fc90eb4471274f8de06">&#9670;&nbsp;</a></span>getBBoxCRS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="../../d2/d1a/classAABB.html">AABB</a>&gt; Scene::getBBoxCRS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the scene's coordinate reference system bounding box. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset. ">Scene</a>'s coordinate reference system bounding box </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330" title="Axis aligned bounding box defining scene boundaries. ">Scene::bbox</a> </dd></dl>

</div>
</div>
<a id="a3f056f98c3ab727a98cb7c4ff0f4a754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f056f98c3ab727a98cb7c4ff0f4a754">&#9670;&nbsp;</a></span>getGroundPointAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::dvec3 Scene::getGroundPointAt </td>
          <td>(</td>
          <td class="paramtype">glm::dvec3&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the ground point at specified XY coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point definint the XY coordinates for which the ground point shall be obtained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Intersected ground point </dd></dl>

</div>
</div>
<a id="a4780b1867590175d6e48f2550b4ccdf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4780b1867590175d6e48f2550b4ccdf4">&#9670;&nbsp;</a></span>getIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="../../dc/da3/classRaySceneIntersection.html">RaySceneIntersection</a> &gt; Scene::getIntersection </td>
          <td>(</td>
          <td class="paramtype">glm::dvec3 &amp;&#160;</td>
          <td class="paramname"><em>rayOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::dvec3 &amp;&#160;</td>
          <td class="paramname"><em>rayDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>groundOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the intersection between the ray and the scene, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rayOrigin</td><td>Ray origin 3D coordinates </td></tr>
    <tr><td class="paramname">rayDir</td><td>Ray 3D director vector </td></tr>
    <tr><td class="paramname">groundOnly</td><td>Flag to specify if only ground points must be considered (true) or not (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Obtained intersection, nullptr if no intersection was detected </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/da3/classRaySceneIntersection.html" title="Class representing a the intersection of a ray over a scene made of primitives. ">RaySceneIntersection</a> </dd>
<dd>
<a class="el" href="../../da/d81/classKDTreeRaycaster.html" title="Class representing a KDTree ray caster. ">KDTreeRaycaster</a> </dd>
<dd>
<a class="el" href="../../da/d81/classKDTreeRaycaster.html#a5a8b58991ee1ae6a83bd3c6b16529f5a" title="Search first intersection for specified ray. ">KDTreeRaycaster::search</a> </dd></dl>

</div>
</div>
<a id="a0493bdc9aa66ed4143dac01d3ceeda4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0493bdc9aa66ed4143dac01d3ceeda4e">&#9670;&nbsp;</a></span>getIntersections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; double, <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> * &gt; Scene::getIntersections </td>
          <td>(</td>
          <td class="paramtype">glm::dvec3 &amp;&#160;</td>
          <td class="paramname"><em>rayOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::dvec3 &amp;&#160;</td>
          <td class="paramname"><em>rayDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>groundOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain all intersections between the ray and the scene, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rayOrigin</td><td>Ray origin 3D coordinates </td></tr>
    <tr><td class="paramname">rayDir</td><td>Ray 3D director vector </td></tr>
    <tr><td class="paramname">groundOnly</td><td>Flag to specify if only ground points must be considered (true) or not (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map of all primitives intersected by the ray, which key is the distance with respect to ray origin </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/da3/classRaySceneIntersection.html" title="Class representing a the intersection of a ray over a scene made of primitives. ">RaySceneIntersection</a> </dd>
<dd>
<a class="el" href="../../da/d81/classKDTreeRaycaster.html" title="Class representing a KDTree ray caster. ">KDTreeRaycaster</a> </dd>
<dd>
<a class="el" href="../../da/d81/classKDTreeRaycaster.html#a305b4a9dde6253f61a8a3ef4ee230964" title="Search all intersections for specified ray. ">KDTreeRaycaster::searchAll</a> </dd></dl>

</div>
</div>
<a id="a2c95521ec543d494b99f44be0c9042ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c95521ec543d494b99f44be0c9042ac">&#9670;&nbsp;</a></span>getKDTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a>&gt; Scene::getKDTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the KDTree used by the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>KDTree used by the scene </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a4d1d59711628b8599f766b0700a02b2f" title="KDTree splitting scene points/vertices to speed-up intersection computations. ">Scene::kdtree</a> </dd></dl>

</div>
</div>
<a id="ac283c25701a6addafe99071740a15058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac283c25701a6addafe99071740a15058">&#9670;&nbsp;</a></span>getKDTreeFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a>&gt; Scene::getKDTreeFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the KDTree factory used by the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>KDTree factory used by the scene </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a5b4ca990006db81ed71b4850923b1414" title="The KDTree factory used to build the scene KDTree. ">Scene::kdtf</a> </dd></dl>

</div>
</div>
<a id="a1efb5df7a0b3c59c2a6d0d85c6485a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efb5df7a0b3c59c2a6d0d85c6485a84">&#9670;&nbsp;</a></span>getShift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::dvec3 Scene::getShift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the minimum boundaries of the original axis aligned bounding box containing the scene, before it was centered so (0, 0, 0) became its new minimum boundaries. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimum boundaries of the original axis aligned bounding box, before translating to (0, 0, 0) </dd></dl>

</div>
</div>
<a id="ac68d340293560035fb043da042a26e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68d340293560035fb043da042a26e85">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const&#160;</td>
          <td class="paramname"><em>fileVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle scene load operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>Type of rendering </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Specific rendering for the stream of bytes </td></tr>
    <tr><td class="paramname">s</td><td><a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset. ">Scene</a> to be loaded </td></tr>
    <tr><td class="paramname">version</td><td>Version number for the <a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset. ">Scene</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ce25df38164ed98cf695bc8042bc6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce25df38164ed98cf695bc8042bc6a5">&#9670;&nbsp;</a></span>readObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d9c/classScene.html">Scene</a> * Scene::readObject </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read serialized scene from given file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to file where a serialized scene is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Imported scene </dd></dl>

</div>
</div>
<a id="a866e2103680b966d076df0121f147e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866e2103680b966d076df0121f147e6d">&#9670;&nbsp;</a></span>registerParts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::registerParts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register all scene parts composing the scene in the parts vector with no repetitions. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a3cc4bc214f0f830bb96ad276c0bdce98" title="Parts composing the scene with no repeats. ">Scene::parts</a> </dd></dl>

</div>
</div>
<a id="a4d6039c2337a5085570ab6a9b8cb7683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6039c2337a5085570ab6a9b8cb7683">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle scene save operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>Type of rendering </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Specific rendering for the stream of bytes </td></tr>
    <tr><td class="paramname">s</td><td><a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset. ">Scene</a> to be saved </td></tr>
    <tr><td class="paramname">version</td><td>Version number for the <a class="el" href="../../d5/d9c/classScene.html" title="Class representing a scene asset. ">Scene</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf1c82c4bcd7b6bb176b29c523c15575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1c82c4bcd7b6bb176b29c523c15575">&#9670;&nbsp;</a></span>setBBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scene::setBBox </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt; const&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scene's bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>New bounding box for the scene </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330" title="Axis aligned bounding box defining scene boundaries. ">Scene::bbox</a> </dd></dl>

</div>
</div>
<a id="af4c42cb5df37ce7340ef497e84e9eacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c42cb5df37ce7340ef497e84e9eacb">&#9670;&nbsp;</a></span>setBBoxCRS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scene::setBBoxCRS </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d2/d1a/classAABB.html">AABB</a> &gt; const&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scene's coordinate reference system bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>New coordinate reference system bounding box for the scene </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a012be28a1b960338f634d5fec54c5330" title="Axis aligned bounding box defining scene boundaries. ">Scene::bbox</a> </dd></dl>

</div>
</div>
<a id="a4f4ea56f0bda2d033133cb02b8f38888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4ea56f0bda2d033133cb02b8f38888">&#9670;&nbsp;</a></span>setKDTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scene::setKDTree </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> &gt; const&#160;</td>
          <td class="paramname"><em>kdtree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the KDTree to be used by the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdtree</td><td>New KDTree to be used by the scene </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a4d1d59711628b8599f766b0700a02b2f" title="KDTree splitting scene points/vertices to speed-up intersection computations. ">Scene::kdtree</a> </dd></dl>

</div>
</div>
<a id="aed9fc8b80b0e0841421549f1b752f2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9fc8b80b0e0841421549f1b752f2c9">&#9670;&nbsp;</a></span>setKDTreeFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scene::setKDTreeFactory </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a> &gt; const&#160;</td>
          <td class="paramname"><em>kdtf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the KDTree factory to be used by the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdtf</td><td>New KDTree factory to be used by the scene </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a5b4ca990006db81ed71b4850923b1414" title="The KDTree factory used to build the scene KDTree. ">Scene::kdtf</a> </dd></dl>

</div>
</div>
<a id="a782302f4dc1703617d5292251bda044e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782302f4dc1703617d5292251bda044e">&#9670;&nbsp;</a></span>writeObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::writeObject </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize the scene and write it to given output file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to output file where serialized scene shall be stored </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../de/d74/classDynScene.html#a529a2939ee6a7fb973ad19cc298d6ff1">DynScene</a>, and <a class="el" href="../../dd/d34/classStaticScene.html#a72bbc2d954c30d0ea5017e69bf1ee047">StaticScene</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5b4ca990006db81ed71b4850923b1414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4ca990006db81ed71b4850923b1414">&#9670;&nbsp;</a></span>kdtf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a>&gt; Scene::kdtf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The KDTree factory used to build the scene KDTree. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> </dd>
<dd>
<a class="el" href="../../d5/d9c/classScene.html#a4d1d59711628b8599f766b0700a02b2f" title="KDTree splitting scene points/vertices to speed-up intersection computations. ">Scene::kdtree</a> </dd></dl>

</div>
</div>
<a id="a3cc4bc214f0f830bb96ad276c0bdce98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc4bc214f0f830bb96ad276c0bdce98">&#9670;&nbsp;</a></span>parts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="../../dd/dc4/classScenePart.html">ScenePart</a>&gt; &gt; Scene::parts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parts composing the scene with no repeats. </p>
<p>Please avoid manually computing this vector. If it is necessary to initialize or update it, call registerParts instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d9c/classScene.html#a866e2103680b966d076df0121f147e6d" title="Register all scene parts composing the scene in the parts vector with no repetitions. ">Scene::registerParts</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/scene/<a class="el" href="../../d5/d2d/Scene_8h_source.html">Scene.h</a></li>
<li>src/scene/Scene.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d5/d9c/classScene.html">Scene</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
