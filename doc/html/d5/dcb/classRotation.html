<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios++: Rotation Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Helios++
   </div>
   <div id="projectbrief">Helios software for LiDAR simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d5/dcb/classRotation.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d9/d2e/classRotation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Rotation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d0/d8f/Rotation_8h_source.html">Rotation.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a08122d3aaff1a1730ad1619f6c9d5bc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a08122d3aaff1a1730ad1619f6c9d5bc4">Rotation</a> (double <a class="el" href="../../d5/dcb/classRotation.html#a6c39c454146bff776b7f3eb8aa4e7c3e">q0</a>, double q1, double q2, double q3, bool needsNormalization)</td></tr>
<tr class="separator:a08122d3aaff1a1730ad1619f6c9d5bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0092b2c6341076e44764c0f82b7c17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a6f0092b2c6341076e44764c0f82b7c17">Rotation</a> (glm::dvec3 axis, double angle)</td></tr>
<tr class="separator:a6f0092b2c6341076e44764c0f82b7c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760ed1b234e6e0cf82bc0ebd8e0f189d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a760ed1b234e6e0cf82bc0ebd8e0f189d">Rotation</a> (glm::dvec3 u, glm::dvec3 v)</td></tr>
<tr class="separator:a760ed1b234e6e0cf82bc0ebd8e0f189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5540b52dbf3cbbf8a6b5061f8da1e296"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a5540b52dbf3cbbf8a6b5061f8da1e296">Rotation</a> (<a class="el" href="../../d6/d7f/classRotationOrder.html">RotationOrder</a> order, double alpha1, double alpha2, double alpha3)</td></tr>
<tr class="separator:a5540b52dbf3cbbf8a6b5061f8da1e296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac791775db4fbf230aff28874e7e9dca6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#ac791775db4fbf230aff28874e7e9dca6">getQ0</a> ()</td></tr>
<tr class="memdesc:ac791775db4fbf230aff28874e7e9dca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scalar coordinate of the quaternion.  <a href="#ac791775db4fbf230aff28874e7e9dca6">More...</a><br /></td></tr>
<tr class="separator:ac791775db4fbf230aff28874e7e9dca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887ec86c8ed3d6e62fc8eeef0f9816b9"><td class="memItemLeft" align="right" valign="top"><a id="a887ec86c8ed3d6e62fc8eeef0f9816b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setQ0</b> (double <a class="el" href="../../d5/dcb/classRotation.html#a6c39c454146bff776b7f3eb8aa4e7c3e">q0</a>)</td></tr>
<tr class="separator:a887ec86c8ed3d6e62fc8eeef0f9816b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0796ec81edaeac64002c4abd878db6b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a0796ec81edaeac64002c4abd878db6b0">getQ1</a> ()</td></tr>
<tr class="memdesc:a0796ec81edaeac64002c4abd878db6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first coordinate of the vectorial part of the quaternion.  <a href="#a0796ec81edaeac64002c4abd878db6b0">More...</a><br /></td></tr>
<tr class="separator:a0796ec81edaeac64002c4abd878db6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cbf1d5d5c6f9232143005f993196f8"><td class="memItemLeft" align="right" valign="top"><a id="a78cbf1d5d5c6f9232143005f993196f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setQ1</b> (double q1)</td></tr>
<tr class="separator:a78cbf1d5d5c6f9232143005f993196f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43cd8328054b2b325dc9f8929105a1c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#ac43cd8328054b2b325dc9f8929105a1c">getQ2</a> ()</td></tr>
<tr class="memdesc:ac43cd8328054b2b325dc9f8929105a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the second coordinate of the vectorial part of the quaternion.  <a href="#ac43cd8328054b2b325dc9f8929105a1c">More...</a><br /></td></tr>
<tr class="separator:ac43cd8328054b2b325dc9f8929105a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740be985bf7b44ec368bf7da025372d9"><td class="memItemLeft" align="right" valign="top"><a id="a740be985bf7b44ec368bf7da025372d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setQ2</b> (double q2)</td></tr>
<tr class="separator:a740be985bf7b44ec368bf7da025372d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3c97c843b1964f5bdb923981e16d67"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a1d3c97c843b1964f5bdb923981e16d67">getQ3</a> ()</td></tr>
<tr class="memdesc:a1d3c97c843b1964f5bdb923981e16d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the third coordinate of the vectorial part of the quaternion.  <a href="#a1d3c97c843b1964f5bdb923981e16d67">More...</a><br /></td></tr>
<tr class="separator:a1d3c97c843b1964f5bdb923981e16d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4809ed22049560aa6ed0d2c49d43983"><td class="memItemLeft" align="right" valign="top"><a id="aa4809ed22049560aa6ed0d2c49d43983"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setQ3</b> (double q3)</td></tr>
<tr class="separator:aa4809ed22049560aa6ed0d2c49d43983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae920f72866cd231100ccbff1c4e88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a8ae920f72866cd231100ccbff1c4e88c">revert</a> ()</td></tr>
<tr class="separator:a8ae920f72866cd231100ccbff1c4e88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc01ec734755fcbfca249f2f400e7ed"><td class="memItemLeft" align="right" valign="top">glm::dvec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a0bc01ec734755fcbfca249f2f400e7ed">getAxis</a> ()</td></tr>
<tr class="separator:a0bc01ec734755fcbfca249f2f400e7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032220d2fefefa8ed30a9cb959d984bc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a032220d2fefefa8ed30a9cb959d984bc">getAngle</a> ()</td></tr>
<tr class="separator:a032220d2fefefa8ed30a9cb959d984bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7507e20aee7e95bac7334d3b81b0089e"><td class="memItemLeft" align="right" valign="top">double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a7507e20aee7e95bac7334d3b81b0089e">getMatrix</a> ()</td></tr>
<tr class="separator:a7507e20aee7e95bac7334d3b81b0089e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab5e08522074fa3c1fa3d48e328608f"><td class="memItemLeft" align="right" valign="top">glm::dvec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#aaab5e08522074fa3c1fa3d48e328608f">applyTo</a> (glm::dvec3 u)</td></tr>
<tr class="separator:aaab5e08522074fa3c1fa3d48e328608f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a041aaf8965c0861739e4e735155389"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a3a041aaf8965c0861739e4e735155389">applyTo</a> (double *in, double *out)</td></tr>
<tr class="separator:a3a041aaf8965c0861739e4e735155389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cf2e57d5f9e550f81da26c0e9f692f"><td class="memItemLeft" align="right" valign="top">glm::dvec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#ac2cf2e57d5f9e550f81da26c0e9f692f">applyInverseTo</a> (glm::dvec3 u)</td></tr>
<tr class="separator:ac2cf2e57d5f9e550f81da26c0e9f692f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b380e6de65e16c39850af3f46fc8739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a5b380e6de65e16c39850af3f46fc8739">applyInverseTo</a> (double *in, double *out)</td></tr>
<tr class="separator:a5b380e6de65e16c39850af3f46fc8739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ddc7d952f29cc2e10aa503dff64656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#ac5ddc7d952f29cc2e10aa503dff64656">applyTo</a> (<a class="el" href="../../d5/dcb/classRotation.html">Rotation</a> r)</td></tr>
<tr class="separator:ac5ddc7d952f29cc2e10aa503dff64656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831a880a832d291597f0b6eecdbe4a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a831a880a832d291597f0b6eecdbe4a63">applyInverseTo</a> (<a class="el" href="../../d5/dcb/classRotation.html">Rotation</a> r)</td></tr>
<tr class="separator:a831a880a832d291597f0b6eecdbe4a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8718c8999caf7ccb1999b0e4c8b1f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a4f8718c8999caf7ccb1999b0e4c8b1f1">getAngles</a> (<a class="el" href="../../d6/d7f/classRotationOrder.html">RotationOrder</a> const *order, double &amp;roll, double &amp;pitch, double &amp;yaw)</td></tr>
<tr class="memdesc:a4f8718c8999caf7ccb1999b0e4c8b1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the roll, pitch and yaw for the <a class="el" href="../../d5/dcb/classRotation.html">Rotation</a>.  <a href="#a4f8718c8999caf7ccb1999b0e4c8b1f1">More...</a><br /></td></tr>
<tr class="separator:a4f8718c8999caf7ccb1999b0e4c8b1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2317fe5bb7d8bb04b6a3c2d0791fa0a"><td class="memItemLeft" align="right" valign="top"><a id="af2317fe5bb7d8bb04b6a3c2d0791fa0a"></a>
<a class="el" href="../../d8/dd2/classPythonDVec3.html">PythonDVec3</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAxisPython</b> ()</td></tr>
<tr class="separator:af2317fe5bb7d8bb04b6a3c2d0791fa0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acf3431fc2755747177ec61e1e8e44c39"><td class="memTemplParams" colspan="2"><a id="acf3431fc2755747177ec61e1e8e44c39"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:acf3431fc2755747177ec61e1e8e44c39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:acf3431fc2755747177ec61e1e8e44c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6c39c454146bff776b7f3eb8aa4e7c3e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a6c39c454146bff776b7f3eb8aa4e7c3e">q0</a></td></tr>
<tr class="separator:a6c39c454146bff776b7f3eb8aa4e7c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7f6e8cc083ba3fa77835e416bb6684"><td class="memItemLeft" align="right" valign="top"><a id="a6d7f6e8cc083ba3fa77835e416bb6684"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>q1</b></td></tr>
<tr class="separator:a6d7f6e8cc083ba3fa77835e416bb6684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd5213e8282409208561a0c55dc9994"><td class="memItemLeft" align="right" valign="top"><a id="abbd5213e8282409208561a0c55dc9994"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>q2</b></td></tr>
<tr class="separator:abbd5213e8282409208561a0c55dc9994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236b3ed42a7a01b022a7068daaf9611a"><td class="memItemLeft" align="right" valign="top"><a id="a236b3ed42a7a01b022a7068daaf9611a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>q3</b></td></tr>
<tr class="separator:a236b3ed42a7a01b022a7068daaf9611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top"><a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::serialization::access</b></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132b66ceacc31c253b7844699fccfe49"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcb/classRotation.html#a132b66ceacc31c253b7844699fccfe49">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="../../d5/dcb/classRotation.html">Rotation</a> &amp;r)</td></tr>
<tr class="separator:a132b66ceacc31c253b7844699fccfe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements rotations in a three-dimensional space.</p>
<p>Rotations can be represented by several different mathematical entities (matrices, axe and angle, Cardan or Euler angles, quaternions). This class presents an higher level abstraction, more user-oriented and hiding this implementation details. Well, for the curious, we use quaternions for the internal representation. The user can build a rotation from any of these representations, and any of these representations can be retrieved from a <code><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a></code> instance (see the various constructors and getters). In addition, a rotation can also be built implicitly from a set of vectors and their image.</p>
<p>This implies that this class can be used to convert from one representation to another one. For example, converting a rotation matrix into a set of Cardan angles from can be done using the following single line of code:</p>
<pre>
double[] angles = new <a class="el" href="../../d5/dcb/classRotation.html">Rotation</a>(matrix, 1.0e-10).getAngles(<a class="el" href="../../d6/d7f/classRotationOrder.html#a130a32ecc8022dec8e4ca4e71682afaf">RotationOrder.XYZ</a>);
</pre> <p>Focus is oriented on what a rotation <em>do</em> rather than on its underlying representation. Once it has been built, and regardless of its internal representation, a rotation is an <em>operator</em> which basically transforms three dimensional <a class="el" href="../../">vectors</a> into other three dimensional <a class="el" href="../../">vectors</a>. Depending on the application, the meaning of these vectors may vary and the semantics of the rotation also.</p>
<p>For example in an spacecraft attitude simulation tool, users will often consider the vectors are fixed (say the Earth direction for example) and the frames change. The rotation transforms the coordinates of the vector in inertial frame into the coordinates of the same vector in satellite frame. In this case, the rotation implicitly defines the relation between the two frames.</p>
<p>Another example could be a telescope control application, where the rotation would transform the sighting direction at rest into the desired observing direction when the telescope is pointed towards an object of interest. In this case the rotation transforms the direction at rest in a topocentric frame into the sighting direction in the same topocentric frame. This implies in this case the frame is fixed and the vector moves.</p>
<p>In many case, both approaches will be combined. In our telescope example, we will probably also need to transform the observing direction in the topocentric frame into the observing direction in inertial frame taking into account the observatory location and the Earth rotation, which would essentially be an application of the first approach.</p>
<p>These examples show that a rotation is what the user wants it to be. This class does not push the user towards one specific definition and hence does not provide methods like <code>projectVectorIntoDestinationFrame</code> or <code>computeTransformedDirection</code>. It provides simpler and more generic methods: <a class="el" href="../../">applyTo(Vector3D)</a> and <a class="el" href="../../">applyInverseTo(Vector3D)</a>.</p>
<p>Since a rotation is basically a vectorial operator, several rotations can be composed together and the composite operation <code>r = r<sub>1</sub> o r<sub>2</sub></code> (which means that for each vector <code>u</code>, <code>r(u) = r<sub>1</sub>(r<sub>2</sub>(u))</code>) is also a rotation. Hence we can consider that in addition to vectors, a rotation can be applied to other rotations as well (or to itself). With our previous notations, we would say we can apply <code>r<sub>1</sub></code> to <code>r<sub>2</sub></code> and the result we get is <code>r = r<sub>1</sub> o r<sub>2</sub></code>. For this purpose, the class provides the methods: <a class="el" href="../../d5/dcb/classRotation.html#ac5ddc7d952f29cc2e10aa503dff64656">applyTo(Rotation)</a> and <a class="el" href="../../d5/dcb/classRotation.html#a831a880a832d291597f0b6eecdbe4a63">applyInverseTo(Rotation)</a>.</p>
<p>Rotations are guaranteed to be immutable objects.</p>
<dl class="section see"><dt>See also</dt><dd>Vector3D </dd>
<dd>
<a class="el" href="../../d6/d7f/classRotationOrder.html">RotationOrder</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.2 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a08122d3aaff1a1730ad1619f6c9d5bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08122d3aaff1a1730ad1619f6c9d5bc4">&#9670;&nbsp;</a></span>Rotation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Rotation::Rotation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>needsNormalization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build a rotation from the quaternion coordinates. </p>
<p>A rotation can be built from a <em>normalized</em> quaternion, i.e. a quaternion for which q<sub>0</sub><sup>2</sup> + q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> + q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized, the constructor can normalize it in a preprocessing step.</p>
<p>Note that some conventions put the scalar part of the quaternion as the 4<sup>th</sup> component and the vector part as the first three components. This is <em>not</em> our convention. We put the scalar part as the first component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q0</td><td>scalar part of the quaternion </td></tr>
    <tr><td class="paramname">q1</td><td>first coordinate of the vectorial part of the quaternion </td></tr>
    <tr><td class="paramname">q2</td><td>second coordinate of the vectorial part of the quaternion </td></tr>
    <tr><td class="paramname">q3</td><td>third coordinate of the vectorial part of the quaternion </td></tr>
    <tr><td class="paramname">needsNormalization</td><td>if true, the coordinates are considered not to be normalized, a normalization preprocessing step is performed before using them </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f0092b2c6341076e44764c0f82b7c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0092b2c6341076e44764c0f82b7c17">&#9670;&nbsp;</a></span>Rotation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Rotation::Rotation </td>
          <td>(</td>
          <td class="paramtype">glm::dvec3&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build a rotation from an axis and an angle. </p>
<p>We use the convention that angles are oriented according to the effect of the rotation on vectors around the axis. That means that if (i, j, k) is a direct frame and if we first provide +k as the axis and &pi;/2 as the angle to this constructor, and then <a class="el" href="../../">apply</a> the instance to +i, we will get +j.</p>
<p>Another way to represent our convention is to say that a rotation of angle &theta; about the unit vector (x, y, z) is the same as the rotation build from quaternion components { cos(-&theta;/2), x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }. Note the minus sign on the angle!</p>
<p>On the one hand this convention is consistent with a vectorial perspective (moving vectors in fixed frames), on the other hand it is different from conventions with a frame perspective (fixed vectors viewed from different frames) like the ones used for example in spacecraft attitude community or in the graphics community.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>axis around which to rotate </td></tr>
    <tr><td class="paramname">angle</td><td>rotation angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">MathIllegalArgumentException</td><td>if the axis norm is zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a760ed1b234e6e0cf82bc0ebd8e0f189d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760ed1b234e6e0cf82bc0ebd8e0f189d">&#9670;&nbsp;</a></span>Rotation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Rotation::Rotation </td>
          <td>(</td>
          <td class="paramtype">glm::dvec3&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::dvec3&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build one of the rotations that transform one vector into another one.</p>
<p>Except for a possible scale factor, if the instance were applied to the vector u it will produce the vector v. There is an infinite number of such rotations, this constructor choose the one with the smallest associated angle (i.e. the one whose axis is orthogonal to the (u, v) plane). If u and v are colinear, an arbitrary rotation axis is chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>originWaypoint vector </td></tr>
    <tr><td class="paramname">v</td><td>desired image of u by the rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">MathArithmeticException</td><td>if the norm of one of the vectors is zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5540b52dbf3cbbf8a6b5061f8da1e296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5540b52dbf3cbbf8a6b5061f8da1e296">&#9670;&nbsp;</a></span>Rotation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Rotation::Rotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d7f/classRotationOrder.html">RotationOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build a rotation from three Cardan or Euler elementary rotations.</p>
<p>Cardan rotations are three successive rotations around the canonical axes X, Y and Z, each axis being used once. There are 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler rotations are three successive rotations around the canonical axes X, Y and Z, the first and last rotations being around the same axis. There are 6 such sets of rotations (XYX, XZX, YXY, YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>
<p>Beware that many people routinely use the term Euler angles even for what really are Cardan angles (this confusion is especially widespread in the aerospace business where Roll, Pitch and Yaw angles are often wrongly tagged as Euler angles).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>order of rotations to use </td></tr>
    <tr><td class="paramname">alpha1</td><td>angle of the first elementary rotation </td></tr>
    <tr><td class="paramname">alpha2</td><td>angle of the second elementary rotation </td></tr>
    <tr><td class="paramname">alpha3</td><td>angle of the third elementary rotation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2cf2e57d5f9e550f81da26c0e9f692f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cf2e57d5f9e550f81da26c0e9f692f">&#9670;&nbsp;</a></span>applyInverseTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::dvec3 Rotation::applyInverseTo </td>
          <td>(</td>
          <td class="paramtype">glm::dvec3&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the inverse of the rotation to a vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>vector to apply the inverse of the rotation to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new vector which such that u is its image by the rotation </dd></dl>

</div>
</div>
<a id="a5b380e6de65e16c39850af3f46fc8739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b380e6de65e16c39850af3f46fc8739">&#9670;&nbsp;</a></span>applyInverseTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rotation::applyInverseTo </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the inverse of the rotation to a vector stored in an array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>an array with three items which stores vector to rotate </td></tr>
    <tr><td class="paramname">out</td><td>an array with three items to put result to (it can be the same array as in) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a831a880a832d291597f0b6eecdbe4a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831a880a832d291597f0b6eecdbe4a63">&#9670;&nbsp;</a></span>applyInverseTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a> Rotation::applyInverseTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the inverse of the instance to another rotation. Applying the inverse of the instance to a rotation is computing the composition in an order compliant with the following rule : let u be any vector and v its image by r (i.e. r.applyTo(u) = v), let w be the inverse image of v by the instance (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where comp = applyInverseTo(r). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>rotation to apply the rotation to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new rotation which is the composition of r by the inverse of the instance </dd></dl>

</div>
</div>
<a id="aaab5e08522074fa3c1fa3d48e328608f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab5e08522074fa3c1fa3d48e328608f">&#9670;&nbsp;</a></span>applyTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::dvec3 Rotation::applyTo </td>
          <td>(</td>
          <td class="paramtype">glm::dvec3&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the rotation to a vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>vector to apply the rotation to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new vector which is the image of u by the rotation </dd></dl>

</div>
</div>
<a id="a3a041aaf8965c0861739e4e735155389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a041aaf8965c0861739e4e735155389">&#9670;&nbsp;</a></span>applyTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rotation::applyTo </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the rotation to a vector stored in an array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>an array with three items which stores vector to rotate </td></tr>
    <tr><td class="paramname">out</td><td>an array with three items to put result to (it can be the same array as in) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5ddc7d952f29cc2e10aa503dff64656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ddc7d952f29cc2e10aa503dff64656">&#9670;&nbsp;</a></span>applyTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a> Rotation::applyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the instance to another rotation. Applying the instance to a rotation is computing the composition in an order compliant with the following rule : let u be any vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u), where comp = applyTo(r). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>rotation to apply the rotation to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new rotation which is the composition of r by the instance </dd></dl>

</div>
</div>
<a id="a032220d2fefefa8ed30a9cb959d984bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032220d2fefefa8ed30a9cb959d984bc">&#9670;&nbsp;</a></span>getAngle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Rotation::getAngle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the angle of the rotation. </p><dl class="section return"><dt>Returns</dt><dd>angle of the rotation (between 0 and &pi;) </dd></dl>
<dl class="section see"><dt>See also</dt><dd>#Rotation(Vector3D, double) </dd></dl>

</div>
</div>
<a id="a4f8718c8999caf7ccb1999b0e4c8b1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8718c8999caf7ccb1999b0e4c8b1f1">&#9670;&nbsp;</a></span>getAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rotation::getAngles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d7f/classRotationOrder.html">RotationOrder</a> const *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the roll, pitch and yaw for the <a class="el" href="../../d5/dcb/classRotation.html">Rotation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">order</td><td><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a> order to use </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">roll</td><td>Roll angle (standard roll for XYZ order) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pitch</td><td>Pitch angle (standard pitch for XYZ order) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">yaw</td><td>Yaw angle (standard yaw for XYZ order) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bc01ec734755fcbfca249f2f400e7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc01ec734755fcbfca249f2f400e7ed">&#9670;&nbsp;</a></span>getAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::dvec3 Rotation::getAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the normalized axis of the rotation. </p><dl class="section return"><dt>Returns</dt><dd>normalized axis of the rotation </dd></dl>
<dl class="section see"><dt>See also</dt><dd>#Rotation(Vector3D, double) </dd></dl>

</div>
</div>
<a id="a7507e20aee7e95bac7334d3b81b0089e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7507e20aee7e95bac7334d3b81b0089e">&#9670;&nbsp;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ** Rotation::getMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the 3X3 matrix corresponding to the instance </p><dl class="section return"><dt>Returns</dt><dd>the matrix corresponding to the instance </dd></dl>

</div>
</div>
<a id="ac791775db4fbf230aff28874e7e9dca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac791775db4fbf230aff28874e7e9dca6">&#9670;&nbsp;</a></span>getQ0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Rotation::getQ0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scalar coordinate of the quaternion. </p>
<p>Identity rotation. </p><dl class="section return"><dt>Returns</dt><dd>scalar coordinate of the quaternion </dd></dl>

</div>
</div>
<a id="a0796ec81edaeac64002c4abd878db6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0796ec81edaeac64002c4abd878db6b0">&#9670;&nbsp;</a></span>getQ1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Rotation::getQ1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first coordinate of the vectorial part of the quaternion. </p>
<dl class="section return"><dt>Returns</dt><dd>first coordinate of the vectorial part of the quaternion </dd></dl>

</div>
</div>
<a id="ac43cd8328054b2b325dc9f8929105a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43cd8328054b2b325dc9f8929105a1c">&#9670;&nbsp;</a></span>getQ2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Rotation::getQ2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the second coordinate of the vectorial part of the quaternion. </p>
<dl class="section return"><dt>Returns</dt><dd>second coordinate of the vectorial part of the quaternion </dd></dl>

</div>
</div>
<a id="a1d3c97c843b1964f5bdb923981e16d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3c97c843b1964f5bdb923981e16d67">&#9670;&nbsp;</a></span>getQ3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Rotation::getQ3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the third coordinate of the vectorial part of the quaternion. </p>
<dl class="section return"><dt>Returns</dt><dd>third coordinate of the vectorial part of the quaternion </dd></dl>

</div>
</div>
<a id="a8ae920f72866cd231100ccbff1c4e88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae920f72866cd231100ccbff1c4e88c">&#9670;&nbsp;</a></span>revert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a> Rotation::revert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Revert a rotation. Build a rotation which reverse the effect of another rotation. This means that if r(u) = v, then r.revert(v) = u. The instance is not changed. </p><dl class="section return"><dt>Returns</dt><dd>a new rotation whose effect is the reverse of the effect of the instance </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a132b66ceacc31c253b7844699fccfe49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132b66ceacc31c253b7844699fccfe49">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perfect orthogonality on a 3X3 matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>initial matrix (not exactly orthogonal) </td></tr>
    <tr><td class="paramname">threshold</td><td>convergence threshold for the iterative orthogonality correction (convergence is reached when the difference between two steps of the Frobenius norm of the correction is below this threshold) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an orthogonal matrix close to m </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NotARotationMatrixException</td><td>if the matrix cannot be orthogonalized with the given threshold after 10 iterations Compute the <em>distance</em> between two rotations. </td></tr>
  </table>
  </dd>
</dl>
<p>The <em>distance</em> is intended here as a way to check if two rotations are almost similar (i.e. they transform vectors the same way) or very different. It is mathematically defined as the angle of the rotation r that prepended to one of the rotations gives the other one:</p>
<pre>
       r<sub>1</sub>(r) = r<sub>2</sub>
</pre> <p>This distance is an angle between 0 and &pi;. Its value is the smallest possible upper bound of the angle in radians between r<sub>1</sub>(v) and r<sub>2</sub>(v) for all possible vectors v. This upper bound is reached for some v. The distance is equal to 0 if and only if the two rotations are identical.</p>
<p>Comparing two rotations should always be done using this value rather than for example comparing the components of the quaternions. It is much more stable, and has a geometric meaning. Also comparing quaternions components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64) and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite their components are different (they are exact opposites).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>first rotation </td></tr>
    <tr><td class="paramname">r2</td><td>second rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>distance</em> between r1 and r2 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6c39c454146bff776b7f3eb8aa4e7c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c39c454146bff776b7f3eb8aa4e7c3e">&#9670;&nbsp;</a></span>q0</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Rotation::q0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar coordinate of the quaternion. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/maths/<a class="el" href="../../d0/d8f/Rotation_8h_source.html">Rotation.h</a></li>
<li>src/maths/Rotation.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d5/dcb/classRotation.html">Rotation</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
