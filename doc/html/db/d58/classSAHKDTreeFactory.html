<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios++: SAHKDTreeFactory Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Helios++
   </div>
   <div id="projectbrief">Helios software for LiDAR simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('db/d58/classSAHKDTreeFactory.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d9/df8/classSAHKDTreeFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAHKDTreeFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class providing building methods for k-dimensional trees with surface area heuristic (SAH)  
 <a href="../../db/d58/classSAHKDTreeFactory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/dc4/SAHKDTreeFactory_8h_source.html">SAHKDTreeFactory.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAHKDTreeFactory:</div>
<div class="dyncontent">
<div class="center"><img src="../../d9/d31/classSAHKDTreeFactory__inherit__graph.png" border="0" usemap="#SAHKDTreeFactory_inherit__map" alt="Inheritance graph"/></div>
<map name="SAHKDTreeFactory_inherit__map" id="SAHKDTreeFactory_inherit__map">
<area shape="rect" id="node4" href="../../df/d30/classAxisSAHKDTreeFactory.html" title="Class providing building methods for k&#45;dimensional trees with surface area heuristic and greedy selec..." alt="" coords="5,229,171,256"/>
<area shape="rect" id="node2" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k&#45;dimensional trees. " alt="" coords="13,80,163,107"/>
<area shape="rect" id="node3" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k&#45;dimensional trees..." alt="" coords="33,5,143,32"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SAHKDTreeFactory:</div>
<div class="dyncontent">
<div class="center"><img src="../../d9/dd5/classSAHKDTreeFactory__coll__graph.png" border="0" usemap="#SAHKDTreeFactory_coll__map" alt="Collaboration graph"/></div>
<map name="SAHKDTreeFactory_coll__map" id="SAHKDTreeFactory_coll__map">
<area shape="rect" id="node2" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k&#45;dimensional trees. " alt="" coords="5,275,156,301"/>
<area shape="rect" id="node3" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k&#45;dimensional trees..." alt="" coords="25,184,136,211"/>
<area shape="rect" id="node4" href="../../d8/d94/classKDTreeNode.html" title="Class representing a KDTree node. " alt="" coords="181,275,279,301"/>
<area shape="rect" id="node5" href="../../d7/d98/classIBinaryTreeNode.html" title="Binary tree node interface that must be implemented by any class providing binary tree node based fun..." alt="" coords="165,184,285,211"/>
<area shape="rect" id="node6" href="../../d2/d1a/classAABB.html" title="Class representing an Axis Aligned Bounding Box (AABB) " alt="" coords="309,184,367,211"/>
<area shape="rect" id="node7" href="../../df/de1/classPrimitive.html" title="Abstract class defining the common behavior for all primitives. " alt="" coords="268,95,341,121"/>
<area shape="rect" id="node8" href="../../d2/da0/classVertex.html" title="Class representing a vertex. " alt="" coords="365,95,425,121"/>
<area shape="rect" id="node9" href="../../db/d02/classColor4f.html" title="Class representing a color with 4 float components: RGBA. " alt="" coords="363,5,427,32"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b542136f4c7cbf63ac51ea1005ff544"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1b542136f4c7cbf63ac51ea1005ff544">SAHKDTreeFactory</a> (size_t const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37">lossNodes</a>=21, double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d">ci</a>=1, double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a">cl</a>=1, double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b">co</a>=1)</td></tr>
<tr class="memdesc:a1b542136f4c7cbf63ac51ea1005ff544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface area heuristic KDTree factory default constructor.  <a href="#a1b542136f4c7cbf63ac51ea1005ff544">More...</a><br /></td></tr>
<tr class="separator:a1b542136f4c7cbf63ac51ea1005ff544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22c06947f61f871156922122c41084d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d">defineSplit</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, int const depth) const override</td></tr>
<tr class="memdesc:aa22c06947f61f871156922122c41084d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the split axis and position for current node.  <a href="#aa22c06947f61f871156922122c41084d">More...</a><br /></td></tr>
<tr class="separator:aa22c06947f61f871156922122c41084d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4a9fd27edb126bcbc9fc5020ef9f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15">computeKDTreeStats</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root) const override</td></tr>
<tr class="memdesc:aca4a9fd27edb126bcbc9fc5020ef9f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in defineSplit function.  <a href="#aca4a9fd27edb126bcbc9fc5020ef9f15">More...</a><br /></td></tr>
<tr class="separator:aca4a9fd27edb126bcbc9fc5020ef9f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fea9ed6b51759b86a8bab4a223f9e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae8fea9ed6b51759b86a8bab4a223f9e1">buildChildrenNodes</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const depth, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;rightPrimitives) override</td></tr>
<tr class="memdesc:ae8fea9ed6b51759b86a8bab4a223f9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build children nodes using \(C_T\) heuristic to handle KDTree in-depth partitioning.  <a href="#ae8fea9ed6b51759b86a8bab4a223f9e1">More...</a><br /></td></tr>
<tr class="separator:ae8fea9ed6b51759b86a8bab4a223f9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa181a6c477c5b55b514f9b12a70b31"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a0fa181a6c477c5b55b514f9b12a70b31">getInteriorCost</a> () const</td></tr>
<tr class="memdesc:a0fa181a6c477c5b55b514f9b12a70b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the cost-weight of interior nodes.  <a href="#a0fa181a6c477c5b55b514f9b12a70b31">More...</a><br /></td></tr>
<tr class="separator:a0fa181a6c477c5b55b514f9b12a70b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac761118b31a69f0a5e76fcaff98d4036"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac761118b31a69f0a5e76fcaff98d4036">setInteriorCost</a> (double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d">ci</a>)</td></tr>
<tr class="memdesc:ac761118b31a69f0a5e76fcaff98d4036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cost-weight of interior nodes.  <a href="#ac761118b31a69f0a5e76fcaff98d4036">More...</a><br /></td></tr>
<tr class="separator:ac761118b31a69f0a5e76fcaff98d4036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfd3132e5cfa427663f3c84b2d93175"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cfd3132e5cfa427663f3c84b2d93175">getLeafCost</a> () const</td></tr>
<tr class="memdesc:a8cfd3132e5cfa427663f3c84b2d93175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the cost-weight for leaf nodes.  <a href="#a8cfd3132e5cfa427663f3c84b2d93175">More...</a><br /></td></tr>
<tr class="separator:a8cfd3132e5cfa427663f3c84b2d93175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7073d3b60fce9cd0f92fcb56deed6e9c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a7073d3b60fce9cd0f92fcb56deed6e9c">setLeafCost</a> (double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a">cl</a>)</td></tr>
<tr class="memdesc:a7073d3b60fce9cd0f92fcb56deed6e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cost-weight for leaf nodes.  <a href="#a7073d3b60fce9cd0f92fcb56deed6e9c">More...</a><br /></td></tr>
<tr class="separator:a7073d3b60fce9cd0f92fcb56deed6e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ba0e95461b489801cb085937f030a6"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a57ba0e95461b489801cb085937f030a6">getObjectCost</a> () const</td></tr>
<tr class="memdesc:a57ba0e95461b489801cb085937f030a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the cost-weight of testing an object for intersection.  <a href="#a57ba0e95461b489801cb085937f030a6">More...</a><br /></td></tr>
<tr class="separator:a57ba0e95461b489801cb085937f030a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa589ffb6e5cee46ea3c35fafb34e5038"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa589ffb6e5cee46ea3c35fafb34e5038">setObjectCost</a> (double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b">co</a>)</td></tr>
<tr class="memdesc:aa589ffb6e5cee46ea3c35fafb34e5038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cost-weight of testing an object for intersection.  <a href="#aa589ffb6e5cee46ea3c35fafb34e5038">More...</a><br /></td></tr>
<tr class="separator:aa589ffb6e5cee46ea3c35fafb34e5038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimpleKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimpleKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html">SimpleKDTreeFactory</a></td></tr>
<tr class="memitem:abd0ddd1777cecd176f94a14da1537bd9 inherit pub_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a id="abd0ddd1777cecd176f94a14da1537bd9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abd0ddd1777cecd176f94a14da1537bd9">SimpleKDTreeFactory</a> ()=default</td></tr>
<tr class="memdesc:abd0ddd1777cecd176f94a14da1537bd9 inherit pub_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k-dimensional trees. ">SimpleKDTreeFactory</a> default constructor. <br /></td></tr>
<tr class="separator:abd0ddd1777cecd176f94a14da1537bd9 inherit pub_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15ff698fd31b9b6476778c76ddcad31 inherit pub_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#af15ff698fd31b9b6476778c76ddcad31">makeFromPrimitives</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) override</td></tr>
<tr class="memdesc:af15ff698fd31b9b6476778c76ddcad31 inherit pub_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a simple KDTree from given primitives.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#af15ff698fd31b9b6476778c76ddcad31">More...</a><br /></td></tr>
<tr class="separator:af15ff698fd31b9b6476778c76ddcad31 inherit pub_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:abd874b2cfb07c46a974ebc6e9cacff3b inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a id="abd874b2cfb07c46a974ebc6e9cacff3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#abd874b2cfb07c46a974ebc6e9cacff3b">KDTreeFactory</a> ()=default</td></tr>
<tr class="memdesc:abd874b2cfb07c46a974ebc6e9cacff3b inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">K dimensional tree factory default constructor. <br /></td></tr>
<tr class="separator:abd874b2cfb07c46a974ebc6e9cacff3b inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8cee7ca7d48bb5c0edfbfef43814c549"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549">splitLoss</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const splitAxis, double const splitPos, double const r) const</td></tr>
<tr class="memdesc:a8cee7ca7d48bb5c0edfbfef43814c549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the loss function for the splitting hyperplane.  <a href="#a8cee7ca7d48bb5c0edfbfef43814c549">More...</a><br /></td></tr>
<tr class="separator:a8cee7ca7d48bb5c0edfbfef43814c549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac123def37ff4bc4598d7d09bcbfff59c"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac123def37ff4bc4598d7d09bcbfff59c">findSplitPositionBySAH</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives) const</td></tr>
<tr class="memdesc:ac123def37ff4bc4598d7d09bcbfff59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best split position using Surface Area Heuristic (SAH) as described in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a>.  <a href="#ac123def37ff4bc4598d7d09bcbfff59c">More...</a><br /></td></tr>
<tr class="separator:ac123def37ff4bc4598d7d09bcbfff59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c68f728b01e8123c188f9c06b58cbe7"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1c68f728b01e8123c188f9c06b58cbe7">heuristicILOT</a> (double &amp;hi, double &amp;hl, double &amp;ho, double &amp;ht, double const surfaceAreaRoot, double const surfaceAreaInterior, double const surfaceAreaLeaf, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:a1c68f728b01e8123c188f9c06b58cbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(C_T\) heuristic preserving partials result of interest.  <a href="#a1c68f728b01e8123c188f9c06b58cbe7">More...</a><br /></td></tr>
<tr class="separator:a1c68f728b01e8123c188f9c06b58cbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade176397ca04cd7460e49eec33f76b91"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ade176397ca04cd7460e49eec33f76b91">cumulativeILOT</a> (double &amp;hi, double &amp;hl, double &amp;ho, double &amp;ht, double const _hi, double const _hl, double const _ho, double const saRoot) const</td></tr>
<tr class="memdesc:ade176397ca04cd7460e49eec33f76b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cumulative of \(C_T\) heuristic ILOT.  <a href="#ade176397ca04cd7460e49eec33f76b91">More...</a><br /></td></tr>
<tr class="separator:ade176397ca04cd7460e49eec33f76b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a64d58b146834e8fb804d25dc66a92a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9a64d58b146834e8fb804d25dc66a92a">internalizeILOT</a> (double &amp;hi, double &amp;hl, double &amp;ho, double &amp;ht, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;rightPrimitives)</td></tr>
<tr class="memdesc:a9a64d58b146834e8fb804d25dc66a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ILOT corresponding to internalization (make interior) of given node and its corresponding left and right splits.  <a href="#a9a64d58b146834e8fb804d25dc66a92a">More...</a><br /></td></tr>
<tr class="separator:a9a64d58b146834e8fb804d25dc66a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb53bebdca06fea392f30075915ccdf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf">toILOTCache</a> (double const I, double const L, double const O, double const T)</td></tr>
<tr class="memdesc:abfb53bebdca06fea392f30075915ccdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ILOT cache from given values.  <a href="#abfb53bebdca06fea392f30075915ccdf">More...</a><br /></td></tr>
<tr class="separator:abfb53bebdca06fea392f30075915ccdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651693da9d8e1431bfcdc40673471e62"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62">fromILOTCache</a> (double &amp;I, double &amp;L, double &amp;O, double &amp;T) const</td></tr>
<tr class="memdesc:a651693da9d8e1431bfcdc40673471e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set references from ILOT cache.  <a href="#a651693da9d8e1431bfcdc40673471e62">More...</a><br /></td></tr>
<tr class="separator:a651693da9d8e1431bfcdc40673471e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f058348ffc9432e614672e0ce4b6e80"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a4f058348ffc9432e614672e0ce4b6e80">initILOT</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *root, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives)</td></tr>
<tr class="memdesc:a4f058348ffc9432e614672e0ce4b6e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the ILOT cache from given root node.  <a href="#a4f058348ffc9432e614672e0ce4b6e80">More...</a><br /></td></tr>
<tr class="separator:a4f058348ffc9432e614672e0ce4b6e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSimpleKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSimpleKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html">SimpleKDTreeFactory</a></td></tr>
<tr class="memitem:a2ffeb366f3239f47ae0f8aad14e69a0a inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a2ffeb366f3239f47ae0f8aad14e69a0a">buildRecursive</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; primitives, int const depth)</td></tr>
<tr class="memdesc:a2ffeb366f3239f47ae0f8aad14e69a0a inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively build a KDTree for given primitives.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a2ffeb366f3239f47ae0f8aad14e69a0a">More...</a><br /></td></tr>
<tr class="separator:a2ffeb366f3239f47ae0f8aad14e69a0a inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a2b1d37c6dfe2b97a502a85e6154c5 inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#ab3a2b1d37c6dfe2b97a502a85e6154c5">populateSplits</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const splitAxis, double const splitPos, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives) const</td></tr>
<tr class="memdesc:ab3a2b1d37c6dfe2b97a502a85e6154c5 inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate list of primitives for left and right splits from given primitives of node being splitted.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#ab3a2b1d37c6dfe2b97a502a85e6154c5">More...</a><br /></td></tr>
<tr class="separator:ab3a2b1d37c6dfe2b97a502a85e6154c5 inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc932ae3ef28f324a656add6c1ac5bd inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd">computeNodeBoundaries</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:abbc932ae3ef28f324a656add6c1ac5bd inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute min and max position and surface area of bounding cuboid for given node.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd">More...</a><br /></td></tr>
<tr class="separator:abbc932ae3ef28f324a656add6c1ac5bd inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa4bc15caaa3456f80cbcd729434e1d37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37">lossNodes</a></td></tr>
<tr class="memdesc:aa4bc15caaa3456f80cbcd729434e1d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many loss nodes must be computed when optimizing the loss function \(\mathcal{L}_2\) to determine the best split position for a given KDTree node.  <a href="#aa4bc15caaa3456f80cbcd729434e1d37">More...</a><br /></td></tr>
<tr class="separator:aa4bc15caaa3456f80cbcd729434e1d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4924bf2b271633b2faeb94bb09ab7d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d">ci</a></td></tr>
<tr class="memdesc:a6c4924bf2b271633b2faeb94bb09ab7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost-weight for traversing interior nodes.  <a href="#a6c4924bf2b271633b2faeb94bb09ab7d">More...</a><br /></td></tr>
<tr class="separator:a6c4924bf2b271633b2faeb94bb09ab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafa7895196056285055f316cd8daf3a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a">cl</a></td></tr>
<tr class="memdesc:acafa7895196056285055f316cd8daf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost-weight for traversing leaf nodes.  <a href="#acafa7895196056285055f316cd8daf3a">More...</a><br /></td></tr>
<tr class="separator:acafa7895196056285055f316cd8daf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142e8bb1c4a2d1ed9adf95f71712199b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b">co</a></td></tr>
<tr class="memdesc:a142e8bb1c4a2d1ed9adf95f71712199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost-weight for testing an object for intersection.  <a href="#a142e8bb1c4a2d1ed9adf95f71712199b">More...</a><br /></td></tr>
<tr class="separator:a142e8bb1c4a2d1ed9adf95f71712199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80997d3fd5920a2420bd5d6cec3f7f97"><td class="memItemLeft" align="right" valign="top"><a id="a80997d3fd5920a2420bd5d6cec3f7f97"></a>
<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a80997d3fd5920a2420bd5d6cec3f7f97">cacheRoot</a> = nullptr</td></tr>
<tr class="memdesc:a80997d3fd5920a2420bd5d6cec3f7f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache pointer to root node of current KDTree being built. <br /></td></tr>
<tr class="separator:a80997d3fd5920a2420bd5d6cec3f7f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64b42cd6f03a2dcf6ba826af2333ba6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6">cacheI</a></td></tr>
<tr class="memdesc:ab64b42cd6f03a2dcf6ba826af2333ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid interior cost.  <a href="#ab64b42cd6f03a2dcf6ba826af2333ba6">More...</a><br /></td></tr>
<tr class="separator:ab64b42cd6f03a2dcf6ba826af2333ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e33369b2f14231102100027a2e4983"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983">cacheL</a></td></tr>
<tr class="memdesc:ae6e33369b2f14231102100027a2e4983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid leaves cost.  <a href="#ae6e33369b2f14231102100027a2e4983">More...</a><br /></td></tr>
<tr class="separator:ae6e33369b2f14231102100027a2e4983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9276d22252cc81236f52d89cf4ed63db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db">cacheO</a></td></tr>
<tr class="memdesc:a9276d22252cc81236f52d89cf4ed63db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid object cost.  <a href="#a9276d22252cc81236f52d89cf4ed63db">More...</a><br /></td></tr>
<tr class="separator:a9276d22252cc81236f52d89cf4ed63db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab269aee31019615eb45303713ee5b1ee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab269aee31019615eb45303713ee5b1ee">cacheT</a></td></tr>
<tr class="memdesc:ab269aee31019615eb45303713ee5b1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid tree cost.  <a href="#ab269aee31019615eb45303713ee5b1ee">More...</a><br /></td></tr>
<tr class="separator:ab269aee31019615eb45303713ee5b1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7bbb4cb358a300d406ee3688ccc97d27"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a7bbb4cb358a300d406ee3688ccc97d27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a7bbb4cb358a300d406ee3688ccc97d27">serialize</a> (Archive &amp;ar, unsigned int const version)</td></tr>
<tr class="memdesc:a7bbb4cb358a300d406ee3688ccc97d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a surface area heuristic KDTree factory to a stream of bytes.  <a href="#a7bbb4cb358a300d406ee3688ccc97d27">More...</a><br /></td></tr>
<tr class="separator:a7bbb4cb358a300d406ee3688ccc97d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top"><a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::serialization::access</b></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class providing building methods for k-dimensional trees with surface area heuristic (SAH) </p>
<dl class="section author"><dt>Author</dt><dd>Alberto M. Esmoris Pena </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0</dd></dl>
<p>The surface area heuristic KDTree factory defines the split point from the fact that an optimal performance point must be between the median of the distribution and the geometric center.</p>
<p>Let \(C_i\), \(C_l\) and \(C_o\) be the cost-weight for traversing interior nodes, traversing leaf nodes and testing an object for intersection respectively. Also, let \(N_i\), \(N_l\) and \(N_o\) number of interior nodes, number of leaf nodes and number of objects. Considering \(S_A(i)\) the surface area of the i-th interior node, \(S_A(l)\) the surface area of the l-th leaf node and generically \(S_A(x)\) the surface area of the \(x\) object or the \(x\) set of objects. It is now possible to define the cost of the tree where \(R\) is the root node as follows, where \(N_o(l)\) is the number of objects in the \(l\)-th leaf:</p>
<p class="formulaDsp">
\[ C_T = \frac{ C_i \sum_{i=1}^{N_i}{S_A(i)} + C_l \sum_{l=1}^{N_l}{S_A(l)} + C_o \sum_{l=1}^{N_l}{S_A(l) N_o(l)} } {S_A(R)} \]
</p>
<p>Alternatively, let \(S_l(o)\) be the set of leaves in which object \(o\) resides so the cost of the tree can be also defined as:</p>
<p class="formulaDsp">
\[ C&#39;_T = \frac{ C_i \sum_{i=1}^{N_i}{S_A(i)} + C_l \sum_{l=1}^{N_l}{S_A(l)} + C_o \sum_{o=1}^{N_o}{S_A[S_l(o)]} } {S_A(R)} \]
</p>
<p>The main difference between \(C_T\) and \(C&#39;_T\) would be that the second one fits better the case where a ray is not going to intersect multiple times the same object.</p>
<p>Now, let \(r\) be the normalized position of the splitting hyperplane for node \(N\) so \(r=0\) is the lower limit, \(r=1\) is the upper limit and \(r=\frac{1}{2}\) is the center. Moreover, let \(L_r\) and \(R_r\) the left and right parts for the \(r\) split position and \(N_o(L_r)\) and \(N_o(R_r)\) be the number of objects at the left and right splits respectively. In consequence, following loss function arises:</p>
<p class="formulaDsp">
\[ \mathcal{L}(r) = S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r) - S_A(N)N_o(N) \]
</p>
<p>Alternatively, considering the term \(-S_A(r)n\) is the amount of work saved by making the node an interior one (so the minus sign), it can be treated as a constant so for the sake of simplicity it would lead to:</p>
<p class="formulaDsp">
\[ \begin{array}{lll} \mathcal{L}(r) &amp;=&amp; S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r) \\ &amp;=&amp; rS_A(N)N_o(L_r) + (1-r)S_A(N)N_o(R_r) \\ &amp;=&amp; S_A(N) \left[rN_o(L_r) + (1-r)N_o(R_r)\right] \end{array} \]
</p>
<p>Differentiating with respect to \(r\) leads to: </p><p class="formulaDsp">
\[ \frac{d\mathcal{L}}{dr} = \left(2N_o(L_r) - N_o(N)\right)\frac{d}{dr}S_A(L_r) + \left[ S_A(L_r) - S_A(R_r) \right] \frac{d}{dr}N_o(L_r) \]
</p>
<p>Although \(N_o(L_r)\) is a discontinuous function, which implies \(\frac{d}{dr}N_o(L_r)\) is not defined, it is known that is always nonnegative which is enough to define a valid minimization criteria. In consequence, it is possible to analyze different scenarios. First, consider the case where the median lies somewhere satisfying \(r &lt; \frac{1}{2}\). Thus, \(\frac{d}{dr}\mathcal{L}(r) &lt; 0\) at the left side because \(N_o(L_r) &lt; \frac{n}{2}\) and \(S_A(L_r) &lt; S_A(R_r)\). On the other hand, \(\frac{d}{dr}\mathcal{L}(r) &gt; 0\) at the right side because \(N_o(L_r) &lt; \frac{n}{2}\) and \(S_A(L_r) &gt; S_A(R_r)\). So the minimum must occur between the object median and the spatial median if the object median is to the left of the spatial median. It is easy to see that an analogous argument applies for the case where the object median is to the right of the spatial median. Then, the optimum split must lie between the object median and the spatial median (center).</p>
<p>To clarify, the object median is understood as related to the splitting plane that places one half of the objects on each side of the plane. While the spatial median \(\mu\) for a given KDTree node in \(\mathbb{R}^{n}\) with \(a = (a_1, \ldots, a_n)\) as minimum vertex and \(b = (b_1, \ldots, b_n)\) as maximum vertex is:</p>
<p class="formulaDsp">
\[ \mu = \frac{a+b}{2} = \left(\frac{a_1+b_1}{2}, \ldots, \frac{a_n+b_n}{2}\right) \]
</p>
<p><em>For a more detailed explanation refer to "Heuristics for ray tracing
 using space subdivision" by J. David MacDonald and Kellogg S. Booth. </em></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k-dimensional trees. ">SimpleKDTreeFactory</a> </dd>
<dd>
<a class="el" href="../../df/d30/classAxisSAHKDTreeFactory.html" title="Class providing building methods for k-dimensional trees with surface area heuristic and greedy selec...">AxisSAHKDTreeFactory</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1b542136f4c7cbf63ac51ea1005ff544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b542136f4c7cbf63ac51ea1005ff544">&#9670;&nbsp;</a></span>SAHKDTreeFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SAHKDTreeFactory::SAHKDTreeFactory </td>
          <td>(</td>
          <td class="paramtype">size_t const&#160;</td>
          <td class="paramname"><em>lossNodes</em> = <code>21</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>ci</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>cl</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>co</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Surface area heuristic KDTree factory default constructor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d" title="Cost-weight for traversing interior nodes. ">SAHKDTreeFactory::ci</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a" title="Cost-weight for traversing leaf nodes. ">SAHKDTreeFactory::cl</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b" title="Cost-weight for testing an object for intersection. ">SAHKDTreeFactory::co</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae8fea9ed6b51759b86a8bab4a223f9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fea9ed6b51759b86a8bab4a223f9e1">&#9670;&nbsp;</a></span>buildChildrenNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::buildChildrenNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build children nodes using \(C_T\) heuristic to handle KDTree in-depth partitioning. </p>
<p>If root node, then by default assume it is a leaf node containing all primitives: </p><p class="formulaDsp">
\[ t_0 : \mathrm{ILOT} = C_T = \frac{1}{S_A(R)} \left[ C_lS_A(R) + C_oS_A(l)N_o(R) \right] \]
</p>
<p>After this, speculate its cost if it is make an interior node with its primitives being splitted into 2 leaf nodes: </p><p class="formulaDsp">
\[ C_{Sr} = \frac{1}{S_A(R)} \left[ C_i S_A(R) + C_l \sum_{l=1}^{2} {S_A(l)} + C_o \sum_{l=1}^{2} {S_A(l)N_o(l)} \right] \]
</p>
<p>Now if \(C_{Sr} \geq C_T\) at \(t_0\) then the process is stopped and all primitives remain in the root node. Otherwise, \(t_1\) happend so: </p><p class="formulaDsp">
\[ t_1 : \mathrm{ILOT} = C_T = C_{Sr} \]
</p>
<p>After the initial case, a similar process is recursively applied to each new node until \(C_{Si} \geq C_{T}\). It is, until the speculative cost is found to be greater or equal than current cost. This new speculative cost for non-root interior nodes is computed as follows, where \(N\) is current leaf node which might be splitted depending on analysis and \(L_r\) and \(R_r\) are its left and right splits respectively: </p><p class="formulaDsp">
\[ \left\{\begin{array}{lll} k_1 &amp;=&amp; C_i S_A(N) \\ k_2 &amp;=&amp; C_l \left(S_A(L_r) + S_A(R_r)\right) - C_l S_A(N) \\ k_3 &amp;=&amp; C_o \left(S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r)\right) - C_o S_A(N)N_o(N) \\ C_{Si} &amp;=&amp; \frac{1}{S_A(R)} \left[ C_i \sum_{i=1}^{N_i} S_A(i) + k_1 + C_l \sum_{l=1}^{N_l} S_A(l) + k_2 + C_o \sum_{l=1}^{N_l} S_A(l)N_o(l) + k_3 \right] \end{array}\right. \]
</p>
<p>Thus, iterations \(x&gt;1\) that will only happen when \(C_{Si} &lt; C_T\) can be defined as: </p><p class="formulaDsp">
\[ t_{x&gt;1} : \mathrm{ILOT} = C_T = C_{Si} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a48fe3d0cf72a677b45c29ac670de5f16" title="Build children nodes for given node. If no children nodes must be built, then the node is configured ...">SimpleKDTreeFactory::buildChildrenNodes</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15" title="Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in d...">SAHKDTreeFactory::computeKDTreeStats</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a48fe3d0cf72a677b45c29ac670de5f16">SimpleKDTreeFactory</a>.</p>

</div>
</div>
<a id="aca4a9fd27edb126bcbc9fc5020ef9f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4a9fd27edb126bcbc9fc5020ef9f15">&#9670;&nbsp;</a></span>computeKDTreeStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::computeKDTreeStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in defineSplit function. </p>
<p>Current tree cost is computed as \(C_T\) not as \(C&#39;_T\)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a259a3500ce239f33914d5da0c694b427" title="Analyze KDTree computing its max depth and the minimum and maximum number of primitives considering a...">SimpleKDTreeFactory::computeKDTreeStats</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae8fea9ed6b51759b86a8bab4a223f9e1" title="Build children nodes using  heuristic to handle KDTree in-depth partitioning. ">SAHKDTreeFactory::buildChildrenNodes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a259a3500ce239f33914d5da0c694b427">SimpleKDTreeFactory</a>.</p>

</div>
</div>
<a id="ade176397ca04cd7460e49eec33f76b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade176397ca04cd7460e49eec33f76b91">&#9670;&nbsp;</a></span>cumulativeILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cumulativeILOT </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>_hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>_ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>saRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cumulative of \(C_T\) heuristic ILOT. </p>
<p><b><span style="color: red">WARNING</span></b> given reference to current total tree cost is also updated, not only returned. Thus, this is a full ILOT write function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">hi</td><td>Current partial interior cost to be updated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hl</td><td>Current partial leaves cost to be updated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ho</td><td>Current partial object cost to be updated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ht</td><td>Current total tree cost to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_hi</td><td>Adding magnitude to update partial interior cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_hl</td><td>Adding magnitude to update partial leaves cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_ho</td><td>Adding magnitude to update partial objeccts cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saRoot</td><td>Surface area of root node \(S_A(R)\) defining cumulative ILOT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated total tree cost </dd></dl>

</div>
</div>
<a id="aa22c06947f61f871156922122c41084d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22c06947f61f871156922122c41084d">&#9670;&nbsp;</a></span>defineSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::defineSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define the split axis and position for current node. </p>
<p>To illustrate the define split method let \(a\) and \(b\) be the minimum and maximum vertices of given node. Let also \(\mu\) be the geometric center or spatial median and \(M_e\) be the object median. For the sake of simplicity, lets assume \(\mu &lt; M_e\) so the iterative method will start at \(\mu\) and end at \(M_e\). If it was the other way, then the iterative method would start at \(M_e\) and end at \(\mu\). Now, if \(n\) is the number of loss nodes, \(\mathcal{L}_2\) is the loss function and \(r = \frac{\phi-a}{b-a} \in [0, 1]\) is the normalized position of split position \(\phi\). Then, the iterative method can be defined as:</p>
<p class="formulaDsp">
\[ \varphi(t) = \mu + t \frac{M_e-\mu}{n-1} \\ \left\{\begin{array}{lll} \phi_1 &amp;=&amp; \mu \\ \phi_{t&gt;1} &amp;=&amp; \left\{\begin{array}{lll} \varphi(t) &amp;,&amp; \mathcal{L}_2\left(\varphi(t)\right) &lt; \mathcal{L}_2\left(\phi_{t-1}\right) \\ \phi_{t-1} &amp;,&amp; \mathcal{L}_2\left(\varphi(t)\right) \geq \mathcal{L}_2\left(\phi_{t-1}\right) \end{array}\right. \end{array}\right. \]
</p>
<p>Finally, \(\phi_n\) is the best found split position.</p>
<p>Notice that the median is constrained so \(M_e \in [a, b]\). Thus, in case there are enough objects lying outside node boundaries causing the median to be also outside, it will be truncated.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aa3ed0e048fd2e9ae62fdd324e32153c5" title="Define the split axis and position for current node. ">SimpleKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15" title="Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in d...">SAHKDTreeFactory::computeKDTreeStats</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae8fea9ed6b51759b86a8bab4a223f9e1" title="Build children nodes using  heuristic to handle KDTree in-depth partitioning. ">SAHKDTreeFactory::buildChildrenNodes</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549" title="Compute the loss function for the splitting hyperplane. ">SAHKDTreeFactory::splitLoss</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37" title="How many loss nodes must be computed when optimizing the loss function  to determine the best split p...">SAHKDTreeFactory::lossNodes</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac123def37ff4bc4598d7d09bcbfff59c" title="Find the best split position using Surface Area Heuristic (SAH) as described in SAHKDTreeFactory::def...">SAHKDTreeFactory::findSplitPositionBySAH</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aa3ed0e048fd2e9ae62fdd324e32153c5">SimpleKDTreeFactory</a>.</p>

</div>
</div>
<a id="ac123def37ff4bc4598d7d09bcbfff59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac123def37ff4bc4598d7d09bcbfff59c">&#9670;&nbsp;</a></span>findSplitPositionBySAH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::findSplitPositionBySAH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best split position using Surface Area Heuristic (SAH) as described in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Loss of best split position. The position itself is already stored in given node </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

</div>
</div>
<a id="a651693da9d8e1431bfcdc40673471e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651693da9d8e1431bfcdc40673471e62">&#9670;&nbsp;</a></span>fromILOTCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::fromILOTCache </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set references from ILOT cache. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6" title="Cache last valid interior cost. ">SAHKDTreeFactory::cacheI</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983" title="Cache last valid leaves cost. ">SAHKDTreeFactory::cacheL</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db" title="Cache last valid object cost. ">SAHKDTreeFactory::cacheO</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab269aee31019615eb45303713ee5b1ee" title="Cache last valid tree cost. ">SAHKDTreeFactory::cacheT</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd></dl>

</div>
</div>
<a id="a0fa181a6c477c5b55b514f9b12a70b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa181a6c477c5b55b514f9b12a70b31">&#9670;&nbsp;</a></span>getInteriorCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getInteriorCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the cost-weight of interior nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Cost-weight of interior nodes </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d" title="Cost-weight for traversing interior nodes. ">SAHKDTreeFactory::ci</a> </dd></dl>

</div>
</div>
<a id="a8cfd3132e5cfa427663f3c84b2d93175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfd3132e5cfa427663f3c84b2d93175">&#9670;&nbsp;</a></span>getLeafCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getLeafCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the cost-weight for leaf nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Cost-weight of leaf nodes </dd></dl>
<dl class="section see"><dt>See also</dt><dd>SAKHDTreeFactory::cl </dd></dl>

</div>
</div>
<a id="a57ba0e95461b489801cb085937f030a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ba0e95461b489801cb085937f030a6">&#9670;&nbsp;</a></span>getObjectCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getObjectCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the cost-weight of testing an object for intersection. </p>
<dl class="section return"><dt>Returns</dt><dd>Cost-weight of testing an object for intersection </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b" title="Cost-weight for testing an object for intersection. ">SAHKDTreeFactory::co</a> </dd></dl>

</div>
</div>
<a id="a1c68f728b01e8123c188f9c06b58cbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c68f728b01e8123c188f9c06b58cbe7">&#9670;&nbsp;</a></span>heuristicILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::heuristicILOT </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>surfaceAreaRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>surfaceAreaInterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>surfaceAreaLeaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(C_T\) heuristic preserving partials result of interest. </p>
<p>Costs and previous values are taken from factory and ILOT cache respectively</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hi</td><td>Where the partial interior cost will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hl</td><td>Where the partial leaves cost will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ho</td><td>Where the partial object cost will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ht</td><td>Where the total tree cost will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfaceAreaRoot</td><td>Surface area of root node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfaceAreaInterior</td><td>Surface area of interior node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfaceAreaLeaf</td><td>Surface area of object/leaf node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primitives</td><td>Primitives defining the object/leaf cluster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(C_T\) as heuristic ILOT </dd></dl>

</div>
</div>
<a id="a4f058348ffc9432e614672e0ce4b6e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f058348ffc9432e614672e0ce4b6e80">&#9670;&nbsp;</a></span>initILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::initILOT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the ILOT cache from given root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node to initialize ILOT cache from </td></tr>
    <tr><td class="paramname">primitives</td><td>Primitives contained in root node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a64d58b146834e8fb804d25dc66a92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a64d58b146834e8fb804d25dc66a92a">&#9670;&nbsp;</a></span>internalizeILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::internalizeILOT </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute ILOT corresponding to internalization (make interior) of given node and its corresponding left and right splits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>To store new interior heuristic cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hl</td><td>To store new leaves heuristic cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ho</td><td>To store new object heuristic cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ht</td><td>To store new tree heuristic cost </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>Node to internalize (make interior) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">primitives</td><td>Primitives on given node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">leftPrimitives</td><td>Primitives on left split </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rightPrimitives</td><td>Primitives on right split </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bbb4cb358a300d406ee3688ccc97d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbb4cb358a300d406ee3688ccc97d27">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a surface area heuristic KDTree factory to a stream of bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>Type of rendering </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Specific rendering for the stream of bytes </td></tr>
    <tr><td class="paramname">version</td><td>Version number for the surface area heuristic KDTree factory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac761118b31a69f0a5e76fcaff98d4036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac761118b31a69f0a5e76fcaff98d4036">&#9670;&nbsp;</a></span>setInteriorCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setInteriorCost </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>ci</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cost-weight of interior nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ci</td><td>New cost-weight for interior nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d" title="Cost-weight for traversing interior nodes. ">SAHKDTreeFactory::ci</a> </dd></dl>

</div>
</div>
<a id="a7073d3b60fce9cd0f92fcb56deed6e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7073d3b60fce9cd0f92fcb56deed6e9c">&#9670;&nbsp;</a></span>setLeafCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setLeafCost </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cost-weight for leaf nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cl</td><td>New cost-weight for leaf nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a" title="Cost-weight for traversing leaf nodes. ">SAHKDTreeFactory::cl</a> </dd></dl>

</div>
</div>
<a id="aa589ffb6e5cee46ea3c35fafb34e5038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa589ffb6e5cee46ea3c35fafb34e5038">&#9670;&nbsp;</a></span>setObjectCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setObjectCost </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>co</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cost-weight of testing an object for intersection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">co</td><td>New cost-weight of testing an object for intersection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b" title="Cost-weight for testing an object for intersection. ">SAHKDTreeFactory::co</a> </dd></dl>

</div>
</div>
<a id="a8cee7ca7d48bb5c0edfbfef43814c549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cee7ca7d48bb5c0edfbfef43814c549">&#9670;&nbsp;</a></span>splitLoss()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::splitLoss </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>splitAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>splitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the loss function for the splitting hyperplane. </p>
<p>The loss function by default is:</p>
<p class="formulaDsp">
\[ \begin{array}{lll} \mathcal{L}(r) &amp;=&amp; S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r) \\ &amp;=&amp; S_A(N) [rN_o(L_r) + (1-r)N_o(R_r)] \end{array} \]
</p>
<p>However, as \(S_A(N)\) is a constant for the same node, it is computationally cheaper to compute an alternative version:</p>
<p class="formulaDsp">
\[ \mathcal{L_2}(r) = rN_o(L_r) + (1-r)N_o(R_r) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitives</td><td>Vector of primitives involved in the split </td></tr>
    <tr><td class="paramname">splitAxis</td><td>Axis at which split will be done </td></tr>
    <tr><td class="paramname">splitPos</td><td>Position of the hyperplane in the split axis </td></tr>
    <tr><td class="paramname">r</td><td>The ratio or normalized split position in \([0, 1]\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value obtained after evaluating loss function </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37" title="How many loss nodes must be computed when optimizing the loss function  to determine the best split p...">SAHKDTreeFactory::lossNodes</a> </dd></dl>

</div>
</div>
<a id="abfb53bebdca06fea392f30075915ccdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb53bebdca06fea392f30075915ccdf">&#9670;&nbsp;</a></span>toILOTCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::toILOTCache </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set ILOT cache from given values. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6" title="Cache last valid interior cost. ">SAHKDTreeFactory::cacheI</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983" title="Cache last valid leaves cost. ">SAHKDTreeFactory::cacheL</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db" title="Cache last valid object cost. ">SAHKDTreeFactory::cacheO</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab269aee31019615eb45303713ee5b1ee" title="Cache last valid tree cost. ">SAHKDTreeFactory::cacheT</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab64b42cd6f03a2dcf6ba826af2333ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64b42cd6f03a2dcf6ba826af2333ba6">&#9670;&nbsp;</a></span>cacheI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheI</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid interior cost. </p>
<p class="formulaDsp">
\[ C_i \sum_{i=1}^{N_i}{S_A(i)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="ae6e33369b2f14231102100027a2e4983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e33369b2f14231102100027a2e4983">&#9670;&nbsp;</a></span>cacheL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid leaves cost. </p>
<p class="formulaDsp">
\[ C_l \sum_{l=1}^{N_l}{S_A(l)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="a9276d22252cc81236f52d89cf4ed63db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9276d22252cc81236f52d89cf4ed63db">&#9670;&nbsp;</a></span>cacheO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid object cost. </p>
<p class="formulaDsp">
\[ C_o \sum_{l=1}^{N_l}{S_A(l) N_o(l)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="ab269aee31019615eb45303713ee5b1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab269aee31019615eb45303713ee5b1ee">&#9670;&nbsp;</a></span>cacheT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid tree cost. </p>
<p class="formulaDsp">
\[ C_T = \frac{ C_i \sum_{i=1}^{N_i}{S_A(i)} + C_l \sum_{l=1}^{N_l}{S_A(l)} + C_o \sum_{l=1}^{N_l}{S_A(l) N_o(l)} } {S_A(R)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="a6c4924bf2b271633b2faeb94bb09ab7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4924bf2b271633b2faeb94bb09ab7d">&#9670;&nbsp;</a></span>ci</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::ci</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost-weight for traversing interior nodes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

</div>
</div>
<a id="acafa7895196056285055f316cd8daf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafa7895196056285055f316cd8daf3a">&#9670;&nbsp;</a></span>cl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost-weight for traversing leaf nodes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

</div>
</div>
<a id="a142e8bb1c4a2d1ed9adf95f71712199b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142e8bb1c4a2d1ed9adf95f71712199b">&#9670;&nbsp;</a></span>co</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::co</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost-weight for testing an object for intersection. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

</div>
</div>
<a id="aa4bc15caaa3456f80cbcd729434e1d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bc15caaa3456f80cbcd729434e1d37">&#9670;&nbsp;</a></span>lossNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAHKDTreeFactory::lossNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How many loss nodes must be computed when optimizing the loss function \(\mathcal{L}_2\) to determine the best split position for a given KDTree node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549" title="Compute the loss function for the splitting hyperplane. ">SAHKDTreeFactory::splitLoss</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/adt/kdtree/<a class="el" href="../../d5/dc4/SAHKDTreeFactory_8h_source.html">SAHKDTreeFactory.h</a></li>
<li>src/adt/kdtree/SAHKDTreeFactory.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html">SAHKDTreeFactory</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
