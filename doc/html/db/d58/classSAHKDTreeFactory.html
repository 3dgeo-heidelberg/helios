<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios++: SAHKDTreeFactory Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Helios++
   </div>
   <div id="projectbrief">Helios software for LiDAR simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('db/d58/classSAHKDTreeFactory.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d9/df8/classSAHKDTreeFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAHKDTreeFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class providing building methods for k-dimensional trees with surface area heuristic (SAH)  
 <a href="../../db/d58/classSAHKDTreeFactory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/dc4/SAHKDTreeFactory_8h_source.html">SAHKDTreeFactory.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAHKDTreeFactory:</div>
<div class="dyncontent">
<div class="center"><img src="../../d9/d31/classSAHKDTreeFactory__inherit__graph.png" border="0" usemap="#SAHKDTreeFactory_inherit__map" alt="Inheritance graph"/></div>
<map name="SAHKDTreeFactory_inherit__map" id="SAHKDTreeFactory_inherit__map">
<area shape="rect" id="node4" href="../../df/d30/classAxisSAHKDTreeFactory.html" title="Class providing building methods for k&#45;dimensional trees with surface area heuristic and greedy selec..." alt="" coords="5,229,171,256"/>
<area shape="rect" id="node5" href="../../d0/d0e/classFastSAHKDTreeFactory.html" title="Class providing building methods for k&#45;dimensional trees with a fast strategy to approximate Surface ..." alt="" coords="195,229,360,256"/>
<area shape="rect" id="node2" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k&#45;dimensional trees. " alt="" coords="107,80,258,107"/>
<area shape="rect" id="node3" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k&#45;dimensional trees..." alt="" coords="127,5,238,32"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SAHKDTreeFactory:</div>
<div class="dyncontent">
<div class="center"><img src="../../d9/dd5/classSAHKDTreeFactory__coll__graph.png" border="0" usemap="#SAHKDTreeFactory_coll__map" alt="Collaboration graph"/></div>
<map name="SAHKDTreeFactory_coll__map" id="SAHKDTreeFactory_coll__map">
<area shape="rect" id="node2" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k&#45;dimensional trees. " alt="" coords="252,532,403,559"/>
<area shape="rect" id="node3" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k&#45;dimensional trees..." alt="" coords="295,456,405,483"/>
<area shape="rect" id="node4" href="../../dd/d04/classLightKDTreeNodeBlockAllocator.html" title="Block allocator for LightKDTreeNode instances. " alt="" coords="249,367,459,393"/>
<area shape="rect" id="node5" href="../../d9/d47/classBlockAllocator.html" title="BlockAllocator\&lt; LightKDTree\lNode \&gt;" alt="" coords="260,276,451,317"/>
<area shape="rect" id="node6" href="../../dd/d79/classLightKDTreeNode.html" title="Class representing a light KDTree node. It is, the basic representation of a KDTree node with uses le..." alt="" coords="184,185,311,212"/>
<area shape="rect" id="node9" href="../../d8/d94/classKDTreeNode.html" title="Class representing a KDTree node. " alt="" coords="137,283,235,310"/>
<area shape="rect" id="node7" href="../../d7/d98/classIBinaryTreeNode.html" title="Binary tree node interface that must be implemented by any class providing binary tree node based fun..." alt="" coords="187,95,307,121"/>
<area shape="rect" id="node10" href="../../d2/d1a/classAABB.html" title="Class representing an Axis Aligned Bounding Box (AABB) " alt="" coords="101,185,159,212"/>
<area shape="rect" id="node11" href="../../df/de1/classPrimitive.html" title="Abstract class defining the common behavior for all primitives. " alt="" coords="5,95,79,121"/>
<area shape="rect" id="node12" href="../../d2/da0/classVertex.html" title="Class representing a vertex. " alt="" coords="103,95,163,121"/>
<area shape="rect" id="node13" href="../../db/d02/classColor4f.html" title="Class representing a color with 4 float components: RGBA. " alt="" coords="101,5,165,32"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b542136f4c7cbf63ac51ea1005ff544"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1b542136f4c7cbf63ac51ea1005ff544">SAHKDTreeFactory</a> (size_t const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37">lossNodes</a>=21, double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d">ci</a>=1, double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a">cl</a>=1, double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b">co</a>=1)</td></tr>
<tr class="memdesc:a1b542136f4c7cbf63ac51ea1005ff544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface area heuristic KDTree factory default constructor.  <a href="#a1b542136f4c7cbf63ac51ea1005ff544">More...</a><br /></td></tr>
<tr class="separator:a1b542136f4c7cbf63ac51ea1005ff544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22c06947f61f871156922122c41084d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d">defineSplit</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, int const depth) const override</td></tr>
<tr class="memdesc:aa22c06947f61f871156922122c41084d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the split axis and position for current node.  <a href="#aa22c06947f61f871156922122c41084d">More...</a><br /></td></tr>
<tr class="separator:aa22c06947f61f871156922122c41084d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4a9fd27edb126bcbc9fc5020ef9f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15">computeKDTreeStats</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root) const override</td></tr>
<tr class="memdesc:aca4a9fd27edb126bcbc9fc5020ef9f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in defineSplit function.  <a href="#aca4a9fd27edb126bcbc9fc5020ef9f15">More...</a><br /></td></tr>
<tr class="separator:aca4a9fd27edb126bcbc9fc5020ef9f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f890774977516b4212e314333cdc7a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a3f890774977516b4212e314333cdc7a7">buildChildrenNodes</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const depth, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives) override</td></tr>
<tr class="memdesc:a3f890774977516b4212e314333cdc7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build children nodes using \(C_T\) heuristic to handle KDTree in-depth partitioning.  <a href="#a3f890774977516b4212e314333cdc7a7">More...</a><br /></td></tr>
<tr class="separator:a3f890774977516b4212e314333cdc7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa181a6c477c5b55b514f9b12a70b31"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a0fa181a6c477c5b55b514f9b12a70b31">getInteriorCost</a> () const</td></tr>
<tr class="memdesc:a0fa181a6c477c5b55b514f9b12a70b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the cost-weight of interior nodes.  <a href="#a0fa181a6c477c5b55b514f9b12a70b31">More...</a><br /></td></tr>
<tr class="separator:a0fa181a6c477c5b55b514f9b12a70b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac761118b31a69f0a5e76fcaff98d4036"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac761118b31a69f0a5e76fcaff98d4036">setInteriorCost</a> (double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d">ci</a>)</td></tr>
<tr class="memdesc:ac761118b31a69f0a5e76fcaff98d4036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cost-weight of interior nodes.  <a href="#ac761118b31a69f0a5e76fcaff98d4036">More...</a><br /></td></tr>
<tr class="separator:ac761118b31a69f0a5e76fcaff98d4036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfd3132e5cfa427663f3c84b2d93175"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cfd3132e5cfa427663f3c84b2d93175">getLeafCost</a> () const</td></tr>
<tr class="memdesc:a8cfd3132e5cfa427663f3c84b2d93175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the cost-weight for leaf nodes.  <a href="#a8cfd3132e5cfa427663f3c84b2d93175">More...</a><br /></td></tr>
<tr class="separator:a8cfd3132e5cfa427663f3c84b2d93175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7073d3b60fce9cd0f92fcb56deed6e9c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a7073d3b60fce9cd0f92fcb56deed6e9c">setLeafCost</a> (double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a">cl</a>)</td></tr>
<tr class="memdesc:a7073d3b60fce9cd0f92fcb56deed6e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cost-weight for leaf nodes.  <a href="#a7073d3b60fce9cd0f92fcb56deed6e9c">More...</a><br /></td></tr>
<tr class="separator:a7073d3b60fce9cd0f92fcb56deed6e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ba0e95461b489801cb085937f030a6"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a57ba0e95461b489801cb085937f030a6">getObjectCost</a> () const</td></tr>
<tr class="memdesc:a57ba0e95461b489801cb085937f030a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the cost-weight of testing an object for intersection.  <a href="#a57ba0e95461b489801cb085937f030a6">More...</a><br /></td></tr>
<tr class="separator:a57ba0e95461b489801cb085937f030a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa589ffb6e5cee46ea3c35fafb34e5038"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa589ffb6e5cee46ea3c35fafb34e5038">setObjectCost</a> (double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b">co</a>)</td></tr>
<tr class="memdesc:aa589ffb6e5cee46ea3c35fafb34e5038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cost-weight of testing an object for intersection.  <a href="#aa589ffb6e5cee46ea3c35fafb34e5038">More...</a><br /></td></tr>
<tr class="separator:aa589ffb6e5cee46ea3c35fafb34e5038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimpleKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimpleKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html">SimpleKDTreeFactory</a></td></tr>
<tr class="memitem:aac0b2d556d61c2e301de1eb2f9bda823 inherit pub_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aac0b2d556d61c2e301de1eb2f9bda823">SimpleKDTreeFactory</a> ()</td></tr>
<tr class="memdesc:aac0b2d556d61c2e301de1eb2f9bda823 inherit pub_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k-dimensional trees. ">SimpleKDTreeFactory</a> default constructor.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#aac0b2d556d61c2e301de1eb2f9bda823">More...</a><br /></td></tr>
<tr class="separator:aac0b2d556d61c2e301de1eb2f9bda823 inherit pub_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3252f0348c7fd5d40b84e52dd9144fad inherit pub_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a3252f0348c7fd5d40b84e52dd9144fad">makeFromPrimitivesUnsafe</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives) override</td></tr>
<tr class="memdesc:a3252f0348c7fd5d40b84e52dd9144fad inherit pub_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a simple KDTree from given primitives.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a3252f0348c7fd5d40b84e52dd9144fad">More...</a><br /></td></tr>
<tr class="separator:a3252f0348c7fd5d40b84e52dd9144fad inherit pub_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:ad905f937a8e13e78f18e659d0732a7a5 inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a id="ad905f937a8e13e78f18e659d0732a7a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#ad905f937a8e13e78f18e659d0732a7a5">KDTreeFactory</a> ()</td></tr>
<tr class="memdesc:ad905f937a8e13e78f18e659d0732a7a5 inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">K dimensional tree factory default constructor. <br /></td></tr>
<tr class="separator:ad905f937a8e13e78f18e659d0732a7a5 inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c0c7761a500d0d0871369ac5f6c4f9 inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a90c0c7761a500d0d0871369ac5f6c4f9">makeFromPrimitives</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives)</td></tr>
<tr class="memdesc:a90c0c7761a500d0d0871369ac5f6c4f9 inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe wrapper from makeFromPrimitivesUnsafe which handles a copy to make from primitives by default. This function behavior might be overridden by any derived/child class. It is expected that any implementation of makeFromPrimitives provides a way to implement the makeFromPrimitivesUnsafe method without modifying vector of input primitives. Notice this does not mean primitives themselves cannot be modified, that depends on the type of <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a>. It only means that the vector itself will not be modified, for instance due to sorting purposes.  <a href="../../d5/dd0/classKDTreeFactory.html#a90c0c7761a500d0d0871369ac5f6c4f9">More...</a><br /></td></tr>
<tr class="separator:a90c0c7761a500d0d0871369ac5f6c4f9 inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dd08e1de4ceeee1e028df1eb9acc8e inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a07dd08e1de4ceeee1e028df1eb9acc8e">isBuildingLightNodes</a> ()</td></tr>
<tr class="memdesc:a07dd08e1de4ceeee1e028df1eb9acc8e inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> is building light nodes.  <a href="../../d5/dd0/classKDTreeFactory.html#a07dd08e1de4ceeee1e028df1eb9acc8e">More...</a><br /></td></tr>
<tr class="separator:a07dd08e1de4ceeee1e028df1eb9acc8e inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998f586e172af6066c63d3d3a251860e inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a998f586e172af6066c63d3d3a251860e">setBuildingLightNodes</a> (bool const <a class="el" href="../../d5/dd0/classKDTreeFactory.html#aa6ede7a422802db8e6cbf537861d5f56">buildLightNodes</a>)</td></tr>
<tr class="memdesc:a998f586e172af6066c63d3d3a251860e inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> so it build light nodes (true) or not (false)  <a href="../../d5/dd0/classKDTreeFactory.html#a998f586e172af6066c63d3d3a251860e">More...</a><br /></td></tr>
<tr class="separator:a998f586e172af6066c63d3d3a251860e inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794e82f978b631abf55b85f6ac72ea01 inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a794e82f978b631abf55b85f6ac72ea01">setChild</a> (<a class="el" href="../../dd/d79/classLightKDTreeNode.html">LightKDTreeNode</a> *&amp;child, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node)</td></tr>
<tr class="memdesc:a794e82f978b631abf55b85f6ac72ea01 inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set child to given node if and only if node is not null. It must be used to assign children nodes in a thread-safe way.  <a href="../../d5/dd0/classKDTreeFactory.html#a794e82f978b631abf55b85f6ac72ea01">More...</a><br /></td></tr>
<tr class="separator:a794e82f978b631abf55b85f6ac72ea01 inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8cee7ca7d48bb5c0edfbfef43814c549"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549">splitLoss</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const splitAxis, double const splitPos, double const r) const</td></tr>
<tr class="memdesc:a8cee7ca7d48bb5c0edfbfef43814c549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the loss function for the splitting hyperplane.  <a href="#a8cee7ca7d48bb5c0edfbfef43814c549">More...</a><br /></td></tr>
<tr class="separator:a8cee7ca7d48bb5c0edfbfef43814c549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac123def37ff4bc4598d7d09bcbfff59c"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac123def37ff4bc4598d7d09bcbfff59c">findSplitPositionBySAH</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives) const</td></tr>
<tr class="memdesc:ac123def37ff4bc4598d7d09bcbfff59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best split position using Surface Area Heuristic (SAH) as described in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a>.  <a href="#ac123def37ff4bc4598d7d09bcbfff59c">More...</a><br /></td></tr>
<tr class="separator:ac123def37ff4bc4598d7d09bcbfff59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c68f728b01e8123c188f9c06b58cbe7"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1c68f728b01e8123c188f9c06b58cbe7">heuristicILOT</a> (double &amp;hi, double &amp;hl, double &amp;ho, double &amp;ht, double const surfaceAreaRoot, double const surfaceAreaInterior, double const surfaceAreaLeaf, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:a1c68f728b01e8123c188f9c06b58cbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(C_T\) heuristic preserving partials result of interest.  <a href="#a1c68f728b01e8123c188f9c06b58cbe7">More...</a><br /></td></tr>
<tr class="separator:a1c68f728b01e8123c188f9c06b58cbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade176397ca04cd7460e49eec33f76b91"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ade176397ca04cd7460e49eec33f76b91">cumulativeILOT</a> (double &amp;hi, double &amp;hl, double &amp;ho, double &amp;ht, double const _hi, double const _hl, double const _ho, double const saRoot) const</td></tr>
<tr class="memdesc:ade176397ca04cd7460e49eec33f76b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cumulative of \(C_T\) heuristic ILOT.  <a href="#ade176397ca04cd7460e49eec33f76b91">More...</a><br /></td></tr>
<tr class="separator:ade176397ca04cd7460e49eec33f76b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a64d58b146834e8fb804d25dc66a92a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9a64d58b146834e8fb804d25dc66a92a">internalizeILOT</a> (double &amp;hi, double &amp;hl, double &amp;ho, double &amp;ht, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;rightPrimitives)</td></tr>
<tr class="memdesc:a9a64d58b146834e8fb804d25dc66a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ILOT corresponding to internalization (make interior) of given node and its corresponding left and right splits.  <a href="#a9a64d58b146834e8fb804d25dc66a92a">More...</a><br /></td></tr>
<tr class="separator:a9a64d58b146834e8fb804d25dc66a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb53bebdca06fea392f30075915ccdf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf">toILOTCache</a> (double const I, double const L, double const O, double const T)</td></tr>
<tr class="memdesc:abfb53bebdca06fea392f30075915ccdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ILOT cache from given values.  <a href="#abfb53bebdca06fea392f30075915ccdf">More...</a><br /></td></tr>
<tr class="separator:abfb53bebdca06fea392f30075915ccdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651693da9d8e1431bfcdc40673471e62"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62">fromILOTCache</a> (double &amp;I, double &amp;L, double &amp;O, double &amp;T) const</td></tr>
<tr class="memdesc:a651693da9d8e1431bfcdc40673471e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set references from ILOT cache.  <a href="#a651693da9d8e1431bfcdc40673471e62">More...</a><br /></td></tr>
<tr class="separator:a651693da9d8e1431bfcdc40673471e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba7534ee95ef054eb9727921becb196"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9ba7534ee95ef054eb9727921becb196">fromILOCache</a> (double &amp;I, double &amp;L, double &amp;O) const</td></tr>
<tr class="memdesc:a9ba7534ee95ef054eb9727921becb196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set references from ILOT cache but only for ILO components.  <a href="#a9ba7534ee95ef054eb9727921becb196">More...</a><br /></td></tr>
<tr class="separator:a9ba7534ee95ef054eb9727921becb196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4241c91c603c8359cb8339b4e5f2e860"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a4241c91c603c8359cb8339b4e5f2e860">getCacheT</a> () const</td></tr>
<tr class="memdesc:a4241c91c603c8359cb8339b4e5f2e860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the T component of ILOT cache.  <a href="#a4241c91c603c8359cb8339b4e5f2e860">More...</a><br /></td></tr>
<tr class="separator:a4241c91c603c8359cb8339b4e5f2e860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f058348ffc9432e614672e0ce4b6e80"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a4f058348ffc9432e614672e0ce4b6e80">initILOT</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *root, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives)</td></tr>
<tr class="memdesc:a4f058348ffc9432e614672e0ce4b6e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the ILOT cache from given root node.  <a href="#a4f058348ffc9432e614672e0ce4b6e80">More...</a><br /></td></tr>
<tr class="separator:a4f058348ffc9432e614672e0ce4b6e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec5d2b00b82b76e07be47619f305646"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#afec5d2b00b82b76e07be47619f305646">setCacheRoot</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *root)</td></tr>
<tr class="memdesc:afec5d2b00b82b76e07be47619f305646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cached root node.  <a href="#afec5d2b00b82b76e07be47619f305646">More...</a><br /></td></tr>
<tr class="separator:afec5d2b00b82b76e07be47619f305646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSimpleKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSimpleKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html">SimpleKDTreeFactory</a></td></tr>
<tr class="memitem:a07231a87a91c5168efcb91308c60adf8 inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a07231a87a91c5168efcb91308c60adf8">buildRecursive</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, int const depth)</td></tr>
<tr class="memdesc:a07231a87a91c5168efcb91308c60adf8 inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively build a KDTree for given primitives.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a07231a87a91c5168efcb91308c60adf8">More...</a><br /></td></tr>
<tr class="separator:a07231a87a91c5168efcb91308c60adf8 inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5466631a7dc4fd2102c338645ff2af inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a0f5466631a7dc4fd2102c338645ff2af">reportKDTreeStats</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:a0f5466631a7dc4fd2102c338645ff2af inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report KDTree stats of given root node at INFO logging level.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a0f5466631a7dc4fd2102c338645ff2af">More...</a><br /></td></tr>
<tr class="separator:a0f5466631a7dc4fd2102c338645ff2af inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a2b1d37c6dfe2b97a502a85e6154c5 inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#ab3a2b1d37c6dfe2b97a502a85e6154c5">populateSplits</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const splitAxis, double const splitPos, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives) const</td></tr>
<tr class="memdesc:ab3a2b1d37c6dfe2b97a502a85e6154c5 inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate list of primitives for left and right splits from given primitives of node being splitted.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#ab3a2b1d37c6dfe2b97a502a85e6154c5">More...</a><br /></td></tr>
<tr class="separator:ab3a2b1d37c6dfe2b97a502a85e6154c5 inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc932ae3ef28f324a656add6c1ac5bd inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd">computeNodeBoundaries</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:abbc932ae3ef28f324a656add6c1ac5bd inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute min and max position and surface area of bounding cuboid for given node.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd">More...</a><br /></td></tr>
<tr class="separator:abbc932ae3ef28f324a656add6c1ac5bd inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:a837bf89fb39600314e02f9fa9d05ec9b inherit pro_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a837bf89fb39600314e02f9fa9d05ec9b">lighten</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root)</td></tr>
<tr class="memdesc:a837bf89fb39600314e02f9fa9d05ec9b inherit pro_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuild all children of given root KDTree node as LightKDTeeeNode nodes.  <a href="../../d5/dd0/classKDTreeFactory.html#a837bf89fb39600314e02f9fa9d05ec9b">More...</a><br /></td></tr>
<tr class="separator:a837bf89fb39600314e02f9fa9d05ec9b inherit pro_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0db942ba81564682211127cc1d21c3 inherit pro_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../dd/d79/classLightKDTreeNode.html">LightKDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#aad0db942ba81564682211127cc1d21c3">_lighten</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node)</td></tr>
<tr class="memdesc:aad0db942ba81564682211127cc1d21c3 inherit pro_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assist <a class="el" href="../../d5/dd0/classKDTreeFactory.html#a837bf89fb39600314e02f9fa9d05ec9b" title="Rebuild all children of given root KDTree node as LightKDTeeeNode nodes. ">KDTreeFactory::lighten</a> function by handling the lighten of a given non-root node.  <a href="../../d5/dd0/classKDTreeFactory.html#aad0db942ba81564682211127cc1d21c3">More...</a><br /></td></tr>
<tr class="separator:aad0db942ba81564682211127cc1d21c3 inherit pro_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa4bc15caaa3456f80cbcd729434e1d37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37">lossNodes</a></td></tr>
<tr class="memdesc:aa4bc15caaa3456f80cbcd729434e1d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many loss nodes must be computed when optimizing the loss function \(\mathcal{L}_2\) to determine the best split position for a given KDTree node.  <a href="#aa4bc15caaa3456f80cbcd729434e1d37">More...</a><br /></td></tr>
<tr class="separator:aa4bc15caaa3456f80cbcd729434e1d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4924bf2b271633b2faeb94bb09ab7d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d">ci</a></td></tr>
<tr class="memdesc:a6c4924bf2b271633b2faeb94bb09ab7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost-weight for traversing interior nodes.  <a href="#a6c4924bf2b271633b2faeb94bb09ab7d">More...</a><br /></td></tr>
<tr class="separator:a6c4924bf2b271633b2faeb94bb09ab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafa7895196056285055f316cd8daf3a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a">cl</a></td></tr>
<tr class="memdesc:acafa7895196056285055f316cd8daf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost-weight for traversing leaf nodes.  <a href="#acafa7895196056285055f316cd8daf3a">More...</a><br /></td></tr>
<tr class="separator:acafa7895196056285055f316cd8daf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142e8bb1c4a2d1ed9adf95f71712199b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b">co</a></td></tr>
<tr class="memdesc:a142e8bb1c4a2d1ed9adf95f71712199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost-weight for testing an object for intersection.  <a href="#a142e8bb1c4a2d1ed9adf95f71712199b">More...</a><br /></td></tr>
<tr class="separator:a142e8bb1c4a2d1ed9adf95f71712199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80997d3fd5920a2420bd5d6cec3f7f97"><td class="memItemLeft" align="right" valign="top"><a id="a80997d3fd5920a2420bd5d6cec3f7f97"></a>
<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a80997d3fd5920a2420bd5d6cec3f7f97">cacheRoot</a> = nullptr</td></tr>
<tr class="memdesc:a80997d3fd5920a2420bd5d6cec3f7f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache pointer to root node of current KDTree being built. <br /></td></tr>
<tr class="separator:a80997d3fd5920a2420bd5d6cec3f7f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64b42cd6f03a2dcf6ba826af2333ba6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6">cacheI</a></td></tr>
<tr class="memdesc:ab64b42cd6f03a2dcf6ba826af2333ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid interior cost.  <a href="#ab64b42cd6f03a2dcf6ba826af2333ba6">More...</a><br /></td></tr>
<tr class="separator:ab64b42cd6f03a2dcf6ba826af2333ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e33369b2f14231102100027a2e4983"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983">cacheL</a></td></tr>
<tr class="memdesc:ae6e33369b2f14231102100027a2e4983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid leaves cost.  <a href="#ae6e33369b2f14231102100027a2e4983">More...</a><br /></td></tr>
<tr class="separator:ae6e33369b2f14231102100027a2e4983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9276d22252cc81236f52d89cf4ed63db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db">cacheO</a></td></tr>
<tr class="memdesc:a9276d22252cc81236f52d89cf4ed63db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid object cost.  <a href="#a9276d22252cc81236f52d89cf4ed63db">More...</a><br /></td></tr>
<tr class="separator:a9276d22252cc81236f52d89cf4ed63db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab269aee31019615eb45303713ee5b1ee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab269aee31019615eb45303713ee5b1ee">cacheT</a></td></tr>
<tr class="memdesc:ab269aee31019615eb45303713ee5b1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid tree cost.  <a href="#ab269aee31019615eb45303713ee5b1ee">More...</a><br /></td></tr>
<tr class="separator:ab269aee31019615eb45303713ee5b1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfc278ecd4db90c08c79099e48d5dd3"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(void)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aebfc278ecd4db90c08c79099e48d5dd3">_lockILOT</a></td></tr>
<tr class="memdesc:aebfc278ecd4db90c08c79099e48d5dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to lock the ILOT cache on a unique way (no thread but locker one must be able to use it). By default it is a void function, it must be overridden to provide concurrency handling.  <a href="#aebfc278ecd4db90c08c79099e48d5dd3">More...</a><br /></td></tr>
<tr class="separator:aebfc278ecd4db90c08c79099e48d5dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3b16fb524bc98106899bbdd7fc246e"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(void)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6f3b16fb524bc98106899bbdd7fc246e">_unlockILOT</a></td></tr>
<tr class="memdesc:a6f3b16fb524bc98106899bbdd7fc246e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to unlock the ILOT cache. It is the counterpart of the _lockILOT function.  <a href="#a6f3b16fb524bc98106899bbdd7fc246e">More...</a><br /></td></tr>
<tr class="separator:a6f3b16fb524bc98106899bbdd7fc246e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classSimpleKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSimpleKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html">SimpleKDTreeFactory</a></td></tr>
<tr class="memitem:a0d728d4a070ec3235cdbc4988e61ad41 inherit pro_attribs_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *(<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *, bool const, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> * &gt; &amp;, int const)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a0d728d4a070ec3235cdbc4988e61ad41">_buildRecursive</a></td></tr>
<tr class="memdesc:a0d728d4a070ec3235cdbc4988e61ad41 inherit pro_attribs_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">The member function as attribute used to recursively build KDTree nodes. By default it will be assigned to the buildRecursive member function but it might be overridden by other implementations. For instance, to wrap the buildRecursive behavior to handle parallel building of KDTrees.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a0d728d4a070ec3235cdbc4988e61ad41">More...</a><br /></td></tr>
<tr class="separator:a0d728d4a070ec3235cdbc4988e61ad41 inherit pro_attribs_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba2468b2987b4bd93e3e832bdf52f00 inherit pro_attribs_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abba2468b2987b4bd93e3e832bdf52f00">minSplitPrimitives</a></td></tr>
<tr class="memdesc:abba2468b2987b4bd93e3e832bdf52f00 inherit pro_attribs_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many primitives are required for a node to be splitted.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#abba2468b2987b4bd93e3e832bdf52f00">More...</a><br /></td></tr>
<tr class="separator:abba2468b2987b4bd93e3e832bdf52f00 inherit pro_attribs_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:aa6ede7a422802db8e6cbf537861d5f56 inherit pro_attribs_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#aa6ede7a422802db8e6cbf537861d5f56">buildLightNodes</a> = true</td></tr>
<tr class="memdesc:aa6ede7a422802db8e6cbf537861d5f56 inherit pro_attribs_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">When it is true, the <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> is expected to build light nodes. It is, built KDTree must have a KDTreeRootNode which children are all <a class="el" href="../../dd/d79/classLightKDTreeNode.html" title="Class representing a light KDTree node. It is, the basic representation of a KDTree node with uses le...">LightKDTreeNode</a>. When it is false, <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> is allowed to build KDTree with <a class="el" href="../../d8/d94/classKDTreeNode.html" title="Class representing a KDTree node. ">KDTreeNode</a> children, which might require more memory.  <a href="../../d5/dd0/classKDTreeFactory.html#aa6ede7a422802db8e6cbf537861d5f56">More...</a><br /></td></tr>
<tr class="separator:aa6ede7a422802db8e6cbf537861d5f56 inherit pro_attribs_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5316cf17aff5dd178d2a84d31410e213 inherit pro_attribs_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d04/classLightKDTreeNodeBlockAllocator.html">LightKDTreeNodeBlockAllocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a5316cf17aff5dd178d2a84d31410e213">lkdtnBlockAllocator</a></td></tr>
<tr class="memdesc:a5316cf17aff5dd178d2a84d31410e213 inherit pro_attribs_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">The block allocator to speed-up lighten of KDTree by reducing allocation calls when instantiating multiple <a class="el" href="../../dd/d79/classLightKDTreeNode.html" title="Class representing a light KDTree node. It is, the basic representation of a KDTree node with uses le...">LightKDTreeNode</a>.  <a href="../../d5/dd0/classKDTreeFactory.html#a5316cf17aff5dd178d2a84d31410e213">More...</a><br /></td></tr>
<tr class="separator:a5316cf17aff5dd178d2a84d31410e213 inherit pro_attribs_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7bbb4cb358a300d406ee3688ccc97d27"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a7bbb4cb358a300d406ee3688ccc97d27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a7bbb4cb358a300d406ee3688ccc97d27">serialize</a> (Archive &amp;ar, unsigned int const version)</td></tr>
<tr class="memdesc:a7bbb4cb358a300d406ee3688ccc97d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a surface area heuristic KDTree factory to a stream of bytes.  <a href="#a7bbb4cb358a300d406ee3688ccc97d27">More...</a><br /></td></tr>
<tr class="separator:a7bbb4cb358a300d406ee3688ccc97d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9650f59fc614fd5694c3630aa95bdb16"><td class="memItemLeft" align="right" valign="top"><a id="a9650f59fc614fd5694c3630aa95bdb16"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MultiThreadSAHKDTreeFactory</b></td></tr>
<tr class="separator:a9650f59fc614fd5694c3630aa95bdb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top"><a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::serialization::access</b></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class providing building methods for k-dimensional trees with surface area heuristic (SAH) </p>
<dl class="section author"><dt>Author</dt><dd>Alberto M. Esmoris Pena </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0</dd></dl>
<p>The surface area heuristic KDTree factory defines the split point from the fact that an optimal performance point must be between the median of the distribution and the geometric center.</p>
<p>Let \(C_i\), \(C_l\) and \(C_o\) be the cost-weight for traversing interior nodes, traversing leaf nodes and testing an object for intersection respectively. Also, let \(N_i\), \(N_l\) and \(N_o\) number of interior nodes, number of leaf nodes and number of objects. Considering \(S_A(i)\) the surface area of the i-th interior node, \(S_A(l)\) the surface area of the l-th leaf node and generically \(S_A(x)\) the surface area of the \(x\) object or the \(x\) set of objects. It is now possible to define the cost of the tree where \(R\) is the root node as follows, where \(N_o(l)\) is the number of objects in the \(l\)-th leaf:</p>
<p class="formulaDsp">
\[ C_T = \frac{ C_i \sum_{i=1}^{N_i}{S_A(i)} + C_l \sum_{l=1}^{N_l}{S_A(l)} + C_o \sum_{l=1}^{N_l}{S_A(l) N_o(l)} } {S_A(R)} \]
</p>
<p>Alternatively, let \(S_l(o)\) be the set of leaves in which object \(o\) resides so the cost of the tree can be also defined as:</p>
<p class="formulaDsp">
\[ C&#39;_T = \frac{ C_i \sum_{i=1}^{N_i}{S_A(i)} + C_l \sum_{l=1}^{N_l}{S_A(l)} + C_o \sum_{o=1}^{N_o}{S_A[S_l(o)]} } {S_A(R)} \]
</p>
<p>The main difference between \(C_T\) and \(C&#39;_T\) would be that the second one fits better the case where a ray is not going to intersect multiple times the same object.</p>
<p>Now, let \(r\) be the normalized position of the splitting hyperplane for node \(N\) so \(r=0\) is the lower limit, \(r=1\) is the upper limit and \(r=\frac{1}{2}\) is the center. Moreover, let \(L_r\) and \(R_r\) be the left and right parts for the \(r\) split position and \(N_o(L_r)\) and \(N_o(R_r)\) be the number of objects at the left and right splits respectively. In consequence, following loss function arises:</p>
<p class="formulaDsp">
\[ \mathcal{L}(r) = S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r) - S_A(N)N_o(N) \]
</p>
<p>Alternatively, considering the term \(-S_A(N)N_o(N)\) is the amount of work saved by making the node an interior one (so the minus sign), it can be treated as a constant so for the sake of simplicity it would lead to:</p>
<p class="formulaDsp">
\[ \begin{array}{lll} \mathcal{L}(r) &amp;=&amp; S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r) \\ &amp;=&amp; rS_A(N)N_o(L_r) + (1-r)S_A(N)N_o(R_r) \\ &amp;=&amp; S_A(N) \left[rN_o(L_r) + (1-r)N_o(R_r)\right] \end{array} \]
</p>
<p>Differentiating with respect to \(r\) leads to: </p><p class="formulaDsp">
\[ \frac{d\mathcal{L}}{dr} = \left(2N_o(L_r) - N_o(N)\right)\frac{d}{dr}S_A(L_r) + \left[ S_A(L_r) - S_A(R_r) \right] \frac{d}{dr}N_o(L_r) \]
</p>
<p>Although \(N_o(L_r)\) is a discontinuous function, which implies \(\frac{d}{dr}N_o(L_r)\) is not defined, it is known that is always nonnegative which is enough to define a valid minimization criteria. In consequence, it is possible to analyze different scenarios. First, consider the case where the median lies somewhere satisfying \(r &lt; \frac{1}{2}\). Thus, \(\frac{d}{dr}\mathcal{L}(r) &lt; 0\) at the left side because \(N_o(L_r) &lt; \frac{n}{2}\) and \(S_A(L_r) &lt; S_A(R_r)\). On the other hand, \(\frac{d}{dr}\mathcal{L}(r) &gt; 0\) at the right side because \(N_o(L_r) &lt; \frac{n}{2}\) and \(S_A(L_r) &gt; S_A(R_r)\). So the minimum must occur between the object median and the spatial median if the object median is to the left of the spatial median. It is easy to see that an analogous argument applies for the case where the object median is to the right of the spatial median. Then, the optimum split must lie between the object median and the spatial median (center).</p>
<p>To clarify, the object median is understood as related to the splitting plane that places one half of the objects on each side of the plane. While the spatial median \(\mu\) for a given KDTree node in \(\mathbb{R}^{n}\) with \(a = (a_1, \ldots, a_n)\) as minimum vertex and \(b = (b_1, \ldots, b_n)\) as maximum vertex is:</p>
<p class="formulaDsp">
\[ \mu = \frac{a+b}{2} = \left(\frac{a_1+b_1}{2}, \ldots, \frac{a_n+b_n}{2}\right) \]
</p>
<p><em>For a more detailed explanation refer to "Heuristics for ray tracing
 using space subdivision" by J. David MacDonald and Kellogg S. Booth. </em></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k-dimensional trees. ">SimpleKDTreeFactory</a> </dd>
<dd>
<a class="el" href="../../df/d30/classAxisSAHKDTreeFactory.html" title="Class providing building methods for k-dimensional trees with surface area heuristic and greedy selec...">AxisSAHKDTreeFactory</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1b542136f4c7cbf63ac51ea1005ff544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b542136f4c7cbf63ac51ea1005ff544">&#9670;&nbsp;</a></span>SAHKDTreeFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAHKDTreeFactory::SAHKDTreeFactory </td>
          <td>(</td>
          <td class="paramtype">size_t const&#160;</td>
          <td class="paramname"><em>lossNodes</em> = <code>21</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>ci</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>cl</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>co</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Surface area heuristic KDTree factory default constructor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d" title="Cost-weight for traversing interior nodes. ">SAHKDTreeFactory::ci</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a" title="Cost-weight for traversing leaf nodes. ">SAHKDTreeFactory::cl</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b" title="Cost-weight for testing an object for intersection. ">SAHKDTreeFactory::co</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f890774977516b4212e314333cdc7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f890774977516b4212e314333cdc7a7">&#9670;&nbsp;</a></span>buildChildrenNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::buildChildrenNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build children nodes using \(C_T\) heuristic to handle KDTree in-depth partitioning. </p>
<p>If root node, then by default assume it is a leaf node containing all primitives: </p><p class="formulaDsp">
\[ t_0 : \mathrm{ILOT} = C_T = \frac{1}{S_A(R)} \left[ C_lS_A(R) + C_oS_A(l)N_o(R) \right] \]
</p>
<p>After this, speculate its cost if it is make an interior node with its primitives being splitted into 2 leaf nodes: </p><p class="formulaDsp">
\[ C_{Sr} = \frac{1}{S_A(R)} \left[ C_i S_A(R) + C_l \sum_{l=1}^{2} {S_A(l)} + C_o \sum_{l=1}^{2} {S_A(l)N_o(l)} \right] \]
</p>
<p>Now if \(C_{Sr} \geq C_T\) at \(t_0\) then the process is stopped and all primitives remain in the root node. Otherwise, \(t_1\) happend so: </p><p class="formulaDsp">
\[ t_1 : \mathrm{ILOT} = C_T = C_{Sr} \]
</p>
<p>After the initial case, a similar process is recursively applied to each new node until \(C_{Si} \geq C_{T}\). It is, until the speculative cost is found to be greater or equal than current cost. This new speculative cost for non-root interior nodes is computed as follows, where \(N\) is current leaf node which might be splitted depending on analysis and \(L_r\) and \(R_r\) are its left and right splits respectively: </p><p class="formulaDsp">
\[ \left\{\begin{array}{lll} k_1 &amp;=&amp; C_i S_A(N) \\ k_2 &amp;=&amp; C_l \left(S_A(L_r) + S_A(R_r)\right) - C_l S_A(N) \\ k_3 &amp;=&amp; C_o \left(S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r)\right) - C_o S_A(N)N_o(N) \\ C_{Si} &amp;=&amp; \frac{1}{S_A(R)} \left[ C_i \sum_{i=1}^{N_i} S_A(i) + k_1 + C_l \sum_{l=1}^{N_l} S_A(l) + k_2 + C_o \sum_{l=1}^{N_l} S_A(l)N_o(l) + k_3 \right] \end{array}\right. \]
</p>
<p>Thus, iterations \(x&gt;1\) that will only happen when \(C_{Si} &lt; C_T\) can be defined as: </p><p class="formulaDsp">
\[ t_{x&gt;1} : \mathrm{ILOT} = C_T = C_{Si} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#ab1f57b35097966c0884d0373a71b382d" title="Build children nodes for given node. If no children nodes must be built, then the node is configured ...">SimpleKDTreeFactory::buildChildrenNodes</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15" title="Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in d...">SAHKDTreeFactory::computeKDTreeStats</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#ab1f57b35097966c0884d0373a71b382d">SimpleKDTreeFactory</a>.</p>

</div>
</div>
<a id="aca4a9fd27edb126bcbc9fc5020ef9f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4a9fd27edb126bcbc9fc5020ef9f15">&#9670;&nbsp;</a></span>computeKDTreeStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::computeKDTreeStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in defineSplit function. </p>
<p>Current tree cost is computed as \(C_T\) not as \(C&#39;_T\)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a259a3500ce239f33914d5da0c694b427" title="Analyze KDTree computing its max depth and the minimum and maximum number of primitives considering a...">SimpleKDTreeFactory::computeKDTreeStats</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a3f890774977516b4212e314333cdc7a7" title="Build children nodes using  heuristic to handle KDTree in-depth partitioning. ">SAHKDTreeFactory::buildChildrenNodes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a259a3500ce239f33914d5da0c694b427">SimpleKDTreeFactory</a>.</p>

</div>
</div>
<a id="ade176397ca04cd7460e49eec33f76b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade176397ca04cd7460e49eec33f76b91">&#9670;&nbsp;</a></span>cumulativeILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cumulativeILOT </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>_hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>_ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>saRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cumulative of \(C_T\) heuristic ILOT. </p>
<p><b><span style="color: red">WARNING</span></b> given reference to current total tree cost is also updated, not only returned. Thus, this is a full ILOT write function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">hi</td><td>Current partial interior cost to be updated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hl</td><td>Current partial leaves cost to be updated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ho</td><td>Current partial object cost to be updated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ht</td><td>Current total tree cost to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_hi</td><td>Adding magnitude to update partial interior cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_hl</td><td>Adding magnitude to update partial leaves cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_ho</td><td>Adding magnitude to update partial objeccts cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saRoot</td><td>Surface area of root node \(S_A(R)\) defining cumulative ILOT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated total tree cost </dd></dl>

</div>
</div>
<a id="aa22c06947f61f871156922122c41084d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22c06947f61f871156922122c41084d">&#9670;&nbsp;</a></span>defineSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::defineSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define the split axis and position for current node. </p>
<p>To illustrate the define split method let \(a\) and \(b\) be the minimum and maximum vertices of given node. Let also \(\mu\) be the geometric center or spatial median and \(M_e\) be the object median. For the sake of simplicity, lets assume \(\mu &lt; M_e\) so the iterative method will start at \(\mu\) and end at \(M_e\). If it was the other way, then the iterative method would start at \(M_e\) and end at \(\mu\). Now, if \(n\) is the number of loss nodes, \(\mathcal{L}_2\) is the loss function and \(r = \frac{\phi-a}{b-a} \in [0, 1]\) is the normalized position of split position \(\phi\). Then, the iterative method can be defined as:</p>
<p class="formulaDsp">
\[ \varphi(t) = \mu + t \frac{M_e-\mu}{n-1} \\ \left\{\begin{array}{lll} \phi_1 &amp;=&amp; \mu \\ \phi_{t&gt;1} &amp;=&amp; \left\{\begin{array}{lll} \varphi(t) &amp;,&amp; \mathcal{L}_2\left(\varphi(t)\right) &lt; \mathcal{L}_2\left(\phi_{t-1}\right) \\ \phi_{t-1} &amp;,&amp; \mathcal{L}_2\left(\varphi(t)\right) \geq \mathcal{L}_2\left(\phi_{t-1}\right) \end{array}\right. \end{array}\right. \]
</p>
<p>Finally, \(\phi_n\) is the best found split position.</p>
<p>Notice that the median is constrained so \(M_e \in [a, b]\). Thus, in case there are enough objects lying outside node boundaries causing the median to be also outside, it will be truncated.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aa3ed0e048fd2e9ae62fdd324e32153c5" title="Define the split axis and position for current node. ">SimpleKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15" title="Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in d...">SAHKDTreeFactory::computeKDTreeStats</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a3f890774977516b4212e314333cdc7a7" title="Build children nodes using  heuristic to handle KDTree in-depth partitioning. ">SAHKDTreeFactory::buildChildrenNodes</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549" title="Compute the loss function for the splitting hyperplane. ">SAHKDTreeFactory::splitLoss</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37" title="How many loss nodes must be computed when optimizing the loss function  to determine the best split p...">SAHKDTreeFactory::lossNodes</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac123def37ff4bc4598d7d09bcbfff59c" title="Find the best split position using Surface Area Heuristic (SAH) as described in SAHKDTreeFactory::def...">SAHKDTreeFactory::findSplitPositionBySAH</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aa3ed0e048fd2e9ae62fdd324e32153c5">SimpleKDTreeFactory</a>.</p>

</div>
</div>
<a id="ac123def37ff4bc4598d7d09bcbfff59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac123def37ff4bc4598d7d09bcbfff59c">&#9670;&nbsp;</a></span>findSplitPositionBySAH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::findSplitPositionBySAH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best split position using Surface Area Heuristic (SAH) as described in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Loss of best split position. The position itself is already stored in given node </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

<p>Reimplemented in <a class="el" href="../../d0/d0e/classFastSAHKDTreeFactory.html#a663032609bd4e732db17c073cf7249cb">FastSAHKDTreeFactory</a>.</p>

</div>
</div>
<a id="a9ba7534ee95ef054eb9727921becb196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba7534ee95ef054eb9727921becb196">&#9670;&nbsp;</a></span>fromILOCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::fromILOCache </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>O</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set references from ILOT cache but only for ILO components. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6" title="Cache last valid interior cost. ">SAHKDTreeFactory::cacheI</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983" title="Cache last valid leaves cost. ">SAHKDTreeFactory::cacheL</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db" title="Cache last valid object cost. ">SAHKDTreeFactory::cacheO</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="a651693da9d8e1431bfcdc40673471e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651693da9d8e1431bfcdc40673471e62">&#9670;&nbsp;</a></span>fromILOTCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::fromILOTCache </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set references from ILOT cache. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6" title="Cache last valid interior cost. ">SAHKDTreeFactory::cacheI</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983" title="Cache last valid leaves cost. ">SAHKDTreeFactory::cacheL</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db" title="Cache last valid object cost. ">SAHKDTreeFactory::cacheO</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab269aee31019615eb45303713ee5b1ee" title="Cache last valid tree cost. ">SAHKDTreeFactory::cacheT</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9ba7534ee95ef054eb9727921becb196" title="Set references from ILOT cache but only for ILO components. ">SAHKDTreeFactory::fromILOCache</a> </dd></dl>

</div>
</div>
<a id="a4241c91c603c8359cb8339b4e5f2e860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4241c91c603c8359cb8339b4e5f2e860">&#9670;&nbsp;</a></span>getCacheT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getCacheT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the T component of ILOT cache. </p>
<dl class="section return"><dt>Returns</dt><dd>T component of ILOT cache </dd></dl>

</div>
</div>
<a id="a0fa181a6c477c5b55b514f9b12a70b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa181a6c477c5b55b514f9b12a70b31">&#9670;&nbsp;</a></span>getInteriorCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getInteriorCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the cost-weight of interior nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Cost-weight of interior nodes </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d" title="Cost-weight for traversing interior nodes. ">SAHKDTreeFactory::ci</a> </dd></dl>

</div>
</div>
<a id="a8cfd3132e5cfa427663f3c84b2d93175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfd3132e5cfa427663f3c84b2d93175">&#9670;&nbsp;</a></span>getLeafCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getLeafCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the cost-weight for leaf nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Cost-weight of leaf nodes </dd></dl>
<dl class="section see"><dt>See also</dt><dd>SAKHDTreeFactory::cl </dd></dl>

</div>
</div>
<a id="a57ba0e95461b489801cb085937f030a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ba0e95461b489801cb085937f030a6">&#9670;&nbsp;</a></span>getObjectCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getObjectCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the cost-weight of testing an object for intersection. </p>
<dl class="section return"><dt>Returns</dt><dd>Cost-weight of testing an object for intersection </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b" title="Cost-weight for testing an object for intersection. ">SAHKDTreeFactory::co</a> </dd></dl>

</div>
</div>
<a id="a1c68f728b01e8123c188f9c06b58cbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c68f728b01e8123c188f9c06b58cbe7">&#9670;&nbsp;</a></span>heuristicILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::heuristicILOT </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>surfaceAreaRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>surfaceAreaInterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>surfaceAreaLeaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(C_T\) heuristic preserving partials result of interest. </p>
<p>Costs and previous values are taken from factory and ILOT cache respectively</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hi</td><td>Where the partial interior cost will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hl</td><td>Where the partial leaves cost will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ho</td><td>Where the partial object cost will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ht</td><td>Where the total tree cost will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfaceAreaRoot</td><td>Surface area of root node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfaceAreaInterior</td><td>Surface area of interior node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfaceAreaLeaf</td><td>Surface area of object/leaf node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primitives</td><td>Primitives defining the object/leaf cluster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(C_T\) as heuristic ILOT </dd></dl>

</div>
</div>
<a id="a4f058348ffc9432e614672e0ce4b6e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f058348ffc9432e614672e0ce4b6e80">&#9670;&nbsp;</a></span>initILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::initILOT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the ILOT cache from given root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node to initialize ILOT cache from </td></tr>
    <tr><td class="paramname">primitives</td><td>Primitives contained in root node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a64d58b146834e8fb804d25dc66a92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a64d58b146834e8fb804d25dc66a92a">&#9670;&nbsp;</a></span>internalizeILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::internalizeILOT </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute ILOT corresponding to internalization (make interior) of given node and its corresponding left and right splits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>To store new interior heuristic cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hl</td><td>To store new leaves heuristic cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ho</td><td>To store new object heuristic cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ht</td><td>To store new tree heuristic cost </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>Node to internalize (make interior) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">primitives</td><td>Primitives on given node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">leftPrimitives</td><td>Primitives on left split </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rightPrimitives</td><td>Primitives on right split </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bbb4cb358a300d406ee3688ccc97d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbb4cb358a300d406ee3688ccc97d27">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a surface area heuristic KDTree factory to a stream of bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>Type of rendering </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Specific rendering for the stream of bytes </td></tr>
    <tr><td class="paramname">version</td><td>Version number for the surface area heuristic KDTree factory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afec5d2b00b82b76e07be47619f305646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec5d2b00b82b76e07be47619f305646">&#9670;&nbsp;</a></span>setCacheRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setCacheRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cached root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The new root node to be cached </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a80997d3fd5920a2420bd5d6cec3f7f97" title="Cache pointer to root node of current KDTree being built. ">SAHKDTreeFactory::cacheRoot</a> </dd></dl>

</div>
</div>
<a id="ac761118b31a69f0a5e76fcaff98d4036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac761118b31a69f0a5e76fcaff98d4036">&#9670;&nbsp;</a></span>setInteriorCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setInteriorCost </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>ci</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cost-weight of interior nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ci</td><td>New cost-weight for interior nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d" title="Cost-weight for traversing interior nodes. ">SAHKDTreeFactory::ci</a> </dd></dl>

</div>
</div>
<a id="a7073d3b60fce9cd0f92fcb56deed6e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7073d3b60fce9cd0f92fcb56deed6e9c">&#9670;&nbsp;</a></span>setLeafCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setLeafCost </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cost-weight for leaf nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cl</td><td>New cost-weight for leaf nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a" title="Cost-weight for traversing leaf nodes. ">SAHKDTreeFactory::cl</a> </dd></dl>

</div>
</div>
<a id="aa589ffb6e5cee46ea3c35fafb34e5038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa589ffb6e5cee46ea3c35fafb34e5038">&#9670;&nbsp;</a></span>setObjectCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setObjectCost </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>co</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cost-weight of testing an object for intersection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">co</td><td>New cost-weight of testing an object for intersection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b" title="Cost-weight for testing an object for intersection. ">SAHKDTreeFactory::co</a> </dd></dl>

</div>
</div>
<a id="a8cee7ca7d48bb5c0edfbfef43814c549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cee7ca7d48bb5c0edfbfef43814c549">&#9670;&nbsp;</a></span>splitLoss()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::splitLoss </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>splitAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>splitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the loss function for the splitting hyperplane. </p>
<p>The loss function by default is:</p>
<p class="formulaDsp">
\[ \begin{array}{lll} \mathcal{L}(r) &amp;=&amp; S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r) \\ &amp;=&amp; S_A(N) [rN_o(L_r) + (1-r)N_o(R_r)] \end{array} \]
</p>
<p>However, as \(S_A(N)\) is a constant for the same node, it is computationally cheaper to compute an alternative version:</p>
<p class="formulaDsp">
\[ \mathcal{L_2}(r) = rN_o(L_r) + (1-r)N_o(R_r) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitives</td><td>Vector of primitives involved in the split </td></tr>
    <tr><td class="paramname">splitAxis</td><td>Axis at which split will be done </td></tr>
    <tr><td class="paramname">splitPos</td><td>Position of the hyperplane in the split axis </td></tr>
    <tr><td class="paramname">r</td><td>The ratio or normalized split position in \([0, 1]\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value obtained after evaluating loss function </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37" title="How many loss nodes must be computed when optimizing the loss function  to determine the best split p...">SAHKDTreeFactory::lossNodes</a> </dd></dl>

</div>
</div>
<a id="abfb53bebdca06fea392f30075915ccdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb53bebdca06fea392f30075915ccdf">&#9670;&nbsp;</a></span>toILOTCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::toILOTCache </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set ILOT cache from given values. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6" title="Cache last valid interior cost. ">SAHKDTreeFactory::cacheI</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983" title="Cache last valid leaves cost. ">SAHKDTreeFactory::cacheL</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db" title="Cache last valid object cost. ">SAHKDTreeFactory::cacheO</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab269aee31019615eb45303713ee5b1ee" title="Cache last valid tree cost. ">SAHKDTreeFactory::cacheT</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aebfc278ecd4db90c08c79099e48d5dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfc278ecd4db90c08c79099e48d5dd3">&#9670;&nbsp;</a></span>_lockILOT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(void)&gt; SAHKDTreeFactory::_lockILOT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to lock the ILOT cache on a unique way (no thread but locker one must be able to use it). By default it is a void function, it must be overridden to provide concurrency handling. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d95/classMultiThreadSAHKDTreeFactory.html" title="Decorator for any SAH KDTree which provides support for multi thread KDTree building. ">MultiThreadSAHKDTreeFactory</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6f3b16fb524bc98106899bbdd7fc246e" title="Function to unlock the ILOT cache. It is the counterpart of the _lockILOT function. ">SAHKDTreeFactory::_unlockILOT</a> </dd></dl>

</div>
</div>
<a id="a6f3b16fb524bc98106899bbdd7fc246e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3b16fb524bc98106899bbdd7fc246e">&#9670;&nbsp;</a></span>_unlockILOT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(void)&gt; SAHKDTreeFactory::_unlockILOT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to unlock the ILOT cache. It is the counterpart of the _lockILOT function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d95/classMultiThreadSAHKDTreeFactory.html" title="Decorator for any SAH KDTree which provides support for multi thread KDTree building. ">MultiThreadSAHKDTreeFactory</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aebfc278ecd4db90c08c79099e48d5dd3" title="Function to lock the ILOT cache on a unique way (no thread but locker one must be able to use it)...">SAHKDTreeFactory::_lockILOT</a> </dd></dl>

</div>
</div>
<a id="ab64b42cd6f03a2dcf6ba826af2333ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64b42cd6f03a2dcf6ba826af2333ba6">&#9670;&nbsp;</a></span>cacheI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheI</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid interior cost. </p>
<p class="formulaDsp">
\[ C_i \sum_{i=1}^{N_i}{S_A(i)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="ae6e33369b2f14231102100027a2e4983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e33369b2f14231102100027a2e4983">&#9670;&nbsp;</a></span>cacheL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid leaves cost. </p>
<p class="formulaDsp">
\[ C_l \sum_{l=1}^{N_l}{S_A(l)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="a9276d22252cc81236f52d89cf4ed63db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9276d22252cc81236f52d89cf4ed63db">&#9670;&nbsp;</a></span>cacheO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid object cost. </p>
<p class="formulaDsp">
\[ C_o \sum_{l=1}^{N_l}{S_A(l) N_o(l)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="ab269aee31019615eb45303713ee5b1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab269aee31019615eb45303713ee5b1ee">&#9670;&nbsp;</a></span>cacheT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid tree cost. </p>
<p class="formulaDsp">
\[ C_T = \frac{ C_i \sum_{i=1}^{N_i}{S_A(i)} + C_l \sum_{l=1}^{N_l}{S_A(l)} + C_o \sum_{l=1}^{N_l}{S_A(l) N_o(l)} } {S_A(R)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="a6c4924bf2b271633b2faeb94bb09ab7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4924bf2b271633b2faeb94bb09ab7d">&#9670;&nbsp;</a></span>ci</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::ci</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost-weight for traversing interior nodes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

</div>
</div>
<a id="acafa7895196056285055f316cd8daf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafa7895196056285055f316cd8daf3a">&#9670;&nbsp;</a></span>cl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost-weight for traversing leaf nodes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

</div>
</div>
<a id="a142e8bb1c4a2d1ed9adf95f71712199b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142e8bb1c4a2d1ed9adf95f71712199b">&#9670;&nbsp;</a></span>co</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::co</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost-weight for testing an object for intersection. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

</div>
</div>
<a id="aa4bc15caaa3456f80cbcd729434e1d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bc15caaa3456f80cbcd729434e1d37">&#9670;&nbsp;</a></span>lossNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAHKDTreeFactory::lossNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How many loss nodes must be computed when optimizing the loss function \(\mathcal{L}_2\) to determine the best split position for a given KDTree node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549" title="Compute the loss function for the splitting hyperplane. ">SAHKDTreeFactory::splitLoss</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/adt/kdtree/<a class="el" href="../../d5/dc4/SAHKDTreeFactory_8h_source.html">SAHKDTreeFactory.h</a></li>
<li>src/adt/kdtree/SAHKDTreeFactory.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html">SAHKDTreeFactory</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
