<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios++: SAHKDTreeFactory Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Helios++
   </div>
   <div id="projectbrief">Helios software for LiDAR simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('db/d58/classSAHKDTreeFactory.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d9/df8/classSAHKDTreeFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SAHKDTreeFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class providing building methods for k-dimensional trees with surface area heuristic (SAH)  
 <a href="../../db/d58/classSAHKDTreeFactory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/dc4/SAHKDTreeFactory_8h_source.html">SAHKDTreeFactory.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAHKDTreeFactory:</div>
<div class="dyncontent">
<div class="center"><img src="../../d9/d31/classSAHKDTreeFactory__inherit__graph.png" border="0" usemap="#SAHKDTreeFactory_inherit__map" alt="Inheritance graph"/></div>
<map name="SAHKDTreeFactory_inherit__map" id="SAHKDTreeFactory_inherit__map">
<area shape="rect" id="node4" href="../../df/d30/classAxisSAHKDTreeFactory.html" title="Class providing building methods for k&#45;dimensional trees with surface area heuristic and greedy selec..." alt="" coords="5,229,171,256"/>
<area shape="rect" id="node5" href="../../d0/d0e/classFastSAHKDTreeFactory.html" title="Class providing building methods for k&#45;dimensional trees with a fast strategy to approximate Surface ..." alt="" coords="195,229,360,256"/>
<area shape="rect" id="node2" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k&#45;dimensional trees. " alt="" coords="107,80,258,107"/>
<area shape="rect" id="node3" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k&#45;dimensional trees..." alt="" coords="127,5,238,32"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SAHKDTreeFactory:</div>
<div class="dyncontent">
<div class="center"><img src="../../d9/dd5/classSAHKDTreeFactory__coll__graph.png" border="0" usemap="#SAHKDTreeFactory_coll__map" alt="Collaboration graph"/></div>
<map name="SAHKDTreeFactory_coll__map" id="SAHKDTreeFactory_coll__map">
<area shape="rect" id="node2" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k&#45;dimensional trees. " alt="" coords="548,547,699,573"/>
<area shape="rect" id="node3" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k&#45;dimensional trees..." alt="" coords="468,471,579,497"/>
<area shape="rect" id="node4" href="../../dd/d04/classLightKDTreeNodeBlockAllocator.html" title="Block allocator for LightKDTreeNode instances. " alt="" coords="375,381,586,408"/>
<area shape="rect" id="node5" href="../../d9/d47/classBlockAllocator.html" title="BlockAllocator\&lt; LightKDTree\lNode \&gt;" alt="" coords="367,291,557,332"/>
<area shape="rect" id="node6" href="../../dd/d79/classLightKDTreeNode.html" title="Class representing a light KDTree node. It is, the basic representation of a KDTree node with uses le..." alt="" coords="184,185,311,212"/>
<area shape="rect" id="node10" href="../../d8/d94/classKDTreeNode.html" title="Class representing a KDTree node. " alt="" coords="198,298,297,325"/>
<area shape="rect" id="node7" href="../../d7/d98/classIBinaryTreeNode.html" title="Binary tree node interface that must be implemented by any class providing binary tree node based fun..." alt="" coords="187,95,307,121"/>
<area shape="rect" id="node11" href="../../d2/d1a/classAABB.html" title="Class representing an Axis Aligned Bounding Box (AABB) " alt="" coords="101,185,159,212"/>
<area shape="rect" id="node12" href="../../df/de1/classPrimitive.html" title="Abstract class defining the common behavior for all primitives. " alt="" coords="5,95,79,121"/>
<area shape="rect" id="node13" href="../../d2/da0/classVertex.html" title="Class representing a vertex. " alt="" coords="103,95,163,121"/>
<area shape="rect" id="node14" href="../../db/d02/classColor4f.html" title="Class representing a color with 4 float components: RGBA. " alt="" coords="101,5,165,32"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b542136f4c7cbf63ac51ea1005ff544"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1b542136f4c7cbf63ac51ea1005ff544">SAHKDTreeFactory</a> (size_t const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37">lossNodes</a>=21, double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d">ci</a>=1, double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a">cl</a>=1, double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b">co</a>=1)</td></tr>
<tr class="memdesc:a1b542136f4c7cbf63ac51ea1005ff544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface area heuristic KDTree factory default constructor.  <a href="#a1b542136f4c7cbf63ac51ea1005ff544">More...</a><br /></td></tr>
<tr class="separator:a1b542136f4c7cbf63ac51ea1005ff544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22c06947f61f871156922122c41084d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d">defineSplit</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, int const depth) const override</td></tr>
<tr class="memdesc:aa22c06947f61f871156922122c41084d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the split axis and position for current node.  <a href="#aa22c06947f61f871156922122c41084d">More...</a><br /></td></tr>
<tr class="separator:aa22c06947f61f871156922122c41084d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4a9fd27edb126bcbc9fc5020ef9f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15">computeKDTreeStats</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root) const override</td></tr>
<tr class="memdesc:aca4a9fd27edb126bcbc9fc5020ef9f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in defineSplit function.  <a href="#aca4a9fd27edb126bcbc9fc5020ef9f15">More...</a><br /></td></tr>
<tr class="separator:aca4a9fd27edb126bcbc9fc5020ef9f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce94a7548b00220c2970becba91ff8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1ce94a7548b00220c2970becba91ff8b">buildChildrenNodes</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const depth, int const index, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives) override</td></tr>
<tr class="memdesc:a1ce94a7548b00220c2970becba91ff8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build children nodes using \(C_T\) heuristic to handle KDTree in-depth partitioning.  <a href="#a1ce94a7548b00220c2970becba91ff8b">More...</a><br /></td></tr>
<tr class="separator:a1ce94a7548b00220c2970becba91ff8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ca93261853fe9d6929ccee7f62ca46"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab6ca93261853fe9d6929ccee7f62ca46">buildChildrenNodesRecipe</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const depth, int const index, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives, std::function&lt; void(<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, int const depth, int const index, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives)&gt;f_buildChildrenNodes)</td></tr>
<tr class="memdesc:ab6ca93261853fe9d6929ccee7f62ca46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The recipe for building of children nodes by SAH algorithm. It is meant to be used by the <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1ce94a7548b00220c2970becba91ff8b" title="Build children nodes using  heuristic to handle KDTree in-depth partitioning. ">SAHKDTreeFactory::buildChildrenNodes</a> but also by any alternative implementation which shared the same recipe (global logic) but changes the way some parts are computed. For instance, it is used to handle geometry-level parallelization.  <a href="#ab6ca93261853fe9d6929ccee7f62ca46">More...</a><br /></td></tr>
<tr class="separator:ab6ca93261853fe9d6929ccee7f62ca46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa181a6c477c5b55b514f9b12a70b31"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a0fa181a6c477c5b55b514f9b12a70b31">getInteriorCost</a> () const</td></tr>
<tr class="memdesc:a0fa181a6c477c5b55b514f9b12a70b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the cost-weight of interior nodes.  <a href="#a0fa181a6c477c5b55b514f9b12a70b31">More...</a><br /></td></tr>
<tr class="separator:a0fa181a6c477c5b55b514f9b12a70b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac761118b31a69f0a5e76fcaff98d4036"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac761118b31a69f0a5e76fcaff98d4036">setInteriorCost</a> (double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d">ci</a>)</td></tr>
<tr class="memdesc:ac761118b31a69f0a5e76fcaff98d4036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cost-weight of interior nodes.  <a href="#ac761118b31a69f0a5e76fcaff98d4036">More...</a><br /></td></tr>
<tr class="separator:ac761118b31a69f0a5e76fcaff98d4036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfd3132e5cfa427663f3c84b2d93175"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cfd3132e5cfa427663f3c84b2d93175">getLeafCost</a> () const</td></tr>
<tr class="memdesc:a8cfd3132e5cfa427663f3c84b2d93175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the cost-weight for leaf nodes.  <a href="#a8cfd3132e5cfa427663f3c84b2d93175">More...</a><br /></td></tr>
<tr class="separator:a8cfd3132e5cfa427663f3c84b2d93175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7073d3b60fce9cd0f92fcb56deed6e9c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a7073d3b60fce9cd0f92fcb56deed6e9c">setLeafCost</a> (double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a">cl</a>)</td></tr>
<tr class="memdesc:a7073d3b60fce9cd0f92fcb56deed6e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cost-weight for leaf nodes.  <a href="#a7073d3b60fce9cd0f92fcb56deed6e9c">More...</a><br /></td></tr>
<tr class="separator:a7073d3b60fce9cd0f92fcb56deed6e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ba0e95461b489801cb085937f030a6"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a57ba0e95461b489801cb085937f030a6">getObjectCost</a> () const</td></tr>
<tr class="memdesc:a57ba0e95461b489801cb085937f030a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the cost-weight of testing an object for intersection.  <a href="#a57ba0e95461b489801cb085937f030a6">More...</a><br /></td></tr>
<tr class="separator:a57ba0e95461b489801cb085937f030a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa589ffb6e5cee46ea3c35fafb34e5038"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa589ffb6e5cee46ea3c35fafb34e5038">setObjectCost</a> (double const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b">co</a>)</td></tr>
<tr class="memdesc:aa589ffb6e5cee46ea3c35fafb34e5038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cost-weight of testing an object for intersection.  <a href="#aa589ffb6e5cee46ea3c35fafb34e5038">More...</a><br /></td></tr>
<tr class="separator:aa589ffb6e5cee46ea3c35fafb34e5038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimpleKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimpleKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html">SimpleKDTreeFactory</a></td></tr>
<tr class="memitem:aac0b2d556d61c2e301de1eb2f9bda823 inherit pub_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aac0b2d556d61c2e301de1eb2f9bda823">SimpleKDTreeFactory</a> ()</td></tr>
<tr class="memdesc:aac0b2d556d61c2e301de1eb2f9bda823 inherit pub_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k-dimensional trees. ">SimpleKDTreeFactory</a> default constructor.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#aac0b2d556d61c2e301de1eb2f9bda823">More...</a><br /></td></tr>
<tr class="separator:aac0b2d556d61c2e301de1eb2f9bda823 inherit pub_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710ca041b66dbc0738fffc61d7dccc6b inherit pub_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a710ca041b66dbc0738fffc61d7dccc6b">makeFromPrimitivesUnsafe</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, bool const computeStats=false, bool const reportStats=false) override</td></tr>
<tr class="memdesc:a710ca041b66dbc0738fffc61d7dccc6b inherit pub_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a simple KDTree from given primitives.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a710ca041b66dbc0738fffc61d7dccc6b">More...</a><br /></td></tr>
<tr class="separator:a710ca041b66dbc0738fffc61d7dccc6b inherit pub_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:ad905f937a8e13e78f18e659d0732a7a5 inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a id="ad905f937a8e13e78f18e659d0732a7a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#ad905f937a8e13e78f18e659d0732a7a5">KDTreeFactory</a> ()</td></tr>
<tr class="memdesc:ad905f937a8e13e78f18e659d0732a7a5 inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">K dimensional tree factory default constructor. <br /></td></tr>
<tr class="separator:ad905f937a8e13e78f18e659d0732a7a5 inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b76b2ff7b83c2074bed4aa01c0c85a inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#ae3b76b2ff7b83c2074bed4aa01c0c85a">makeFromPrimitives</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, bool const computeStats=false, bool const reportStats=false)</td></tr>
<tr class="memdesc:ae3b76b2ff7b83c2074bed4aa01c0c85a inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe wrapper from makeFromPrimitivesUnsafe which handles a copy to make from primitives by default. This function behavior might be overridden by any derived/child class. It is expected that any implementation of makeFromPrimitives provides a way to implement the makeFromPrimitivesUnsafe method without modifying vector of input primitives. Notice this does not mean primitives themselves cannot be modified, that depends on the type of <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a>. It only means that the vector itself will not be modified, for instance due to sorting purposes.  <a href="../../d5/dd0/classKDTreeFactory.html#ae3b76b2ff7b83c2074bed4aa01c0c85a">More...</a><br /></td></tr>
<tr class="separator:ae3b76b2ff7b83c2074bed4aa01c0c85a inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dd08e1de4ceeee1e028df1eb9acc8e inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a07dd08e1de4ceeee1e028df1eb9acc8e">isBuildingLightNodes</a> ()</td></tr>
<tr class="memdesc:a07dd08e1de4ceeee1e028df1eb9acc8e inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> is building light nodes.  <a href="../../d5/dd0/classKDTreeFactory.html#a07dd08e1de4ceeee1e028df1eb9acc8e">More...</a><br /></td></tr>
<tr class="separator:a07dd08e1de4ceeee1e028df1eb9acc8e inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998f586e172af6066c63d3d3a251860e inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a998f586e172af6066c63d3d3a251860e">setBuildingLightNodes</a> (bool const <a class="el" href="../../d5/dd0/classKDTreeFactory.html#aa6ede7a422802db8e6cbf537861d5f56">buildLightNodes</a>)</td></tr>
<tr class="memdesc:a998f586e172af6066c63d3d3a251860e inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> so it build light nodes (true) or not (false)  <a href="../../d5/dd0/classKDTreeFactory.html#a998f586e172af6066c63d3d3a251860e">More...</a><br /></td></tr>
<tr class="separator:a998f586e172af6066c63d3d3a251860e inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794e82f978b631abf55b85f6ac72ea01 inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a794e82f978b631abf55b85f6ac72ea01">setChild</a> (<a class="el" href="../../dd/d79/classLightKDTreeNode.html">LightKDTreeNode</a> *&amp;child, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node)</td></tr>
<tr class="memdesc:a794e82f978b631abf55b85f6ac72ea01 inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set child to given node if and only if node is not null. It must be used to assign children nodes in a thread-safe way.  <a href="../../d5/dd0/classKDTreeFactory.html#a794e82f978b631abf55b85f6ac72ea01">More...</a><br /></td></tr>
<tr class="separator:a794e82f978b631abf55b85f6ac72ea01 inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a13833d1dc848b2bd3b159815d8be45eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a13833d1dc848b2bd3b159815d8be45eb">checkNodeMustSplit</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;rightPrimitives) const override</td></tr>
<tr class="memdesc:a13833d1dc848b2bd3b159815d8be45eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check wheter the node must be splitted (true) or not (false) depending on its total primitives.  <a href="#a13833d1dc848b2bd3b159815d8be45eb">More...</a><br /></td></tr>
<tr class="separator:a13833d1dc848b2bd3b159815d8be45eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cee7ca7d48bb5c0edfbfef43814c549"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549">splitLoss</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const splitAxis, double const splitPos, double const r) const</td></tr>
<tr class="memdesc:a8cee7ca7d48bb5c0edfbfef43814c549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the loss function for the splitting hyperplane.  <a href="#a8cee7ca7d48bb5c0edfbfef43814c549">More...</a><br /></td></tr>
<tr class="separator:a8cee7ca7d48bb5c0edfbfef43814c549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe00df5e1eb262f635640a431ccc5ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abbe00df5e1eb262f635640a431ccc5ad">computeBestSplit</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, size_t const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37">lossNodes</a>, double const start, double const step, int const splitAxis, double const minBound, double const boundLength, double &amp;loss, double &amp;splitPos) const</td></tr>
<tr class="memdesc:abbe00df5e1eb262f635640a431ccc5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively compute the best split position, it is the one with smaller loss.  <a href="#abbe00df5e1eb262f635640a431ccc5ad">More...</a><br /></td></tr>
<tr class="separator:abbe00df5e1eb262f635640a431ccc5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac123def37ff4bc4598d7d09bcbfff59c"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac123def37ff4bc4598d7d09bcbfff59c">findSplitPositionBySAH</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives) const</td></tr>
<tr class="memdesc:ac123def37ff4bc4598d7d09bcbfff59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best split position using Surface Area Heuristic (SAH) as described in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a>.  <a href="#ac123def37ff4bc4598d7d09bcbfff59c">More...</a><br /></td></tr>
<tr class="separator:ac123def37ff4bc4598d7d09bcbfff59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6c2833576b0f1370195d8d6fbe9d8d"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#afb6c2833576b0f1370195d8d6fbe9d8d">findSplitPositionBySAHRecipe</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, std::function&lt; void(vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt;::iterator begin, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt;::iterator end, <a class="el" href="../../d6/d1f/structKDTreePrimitiveComparator.html">KDTreePrimitiveComparator</a> comparator)&gt; f_sortPrimitives, std::function&lt; void(vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, size_t const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37">lossNodes</a>, double const start, double const step, int const splitAxis, double const minBound, double const boundLength, double &amp;loss, double &amp;splitPos)&gt; f_computeLossNodes) const</td></tr>
<tr class="memdesc:afb6c2833576b0f1370195d8d6fbe9d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The recipe for finding split position by SAH algorithm. It is meant to be used by the <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac123def37ff4bc4598d7d09bcbfff59c" title="Find the best split position using Surface Area Heuristic (SAH) as described in SAHKDTreeFactory::def...">SAHKDTreeFactory::findSplitPositionBySAH</a> but also by any alternative implementation which shares the same recipe ( global logic) but changes the way some parts are computed. For instance, it is used to handle geometry-level parallelization.  <a href="#afb6c2833576b0f1370195d8d6fbe9d8d">More...</a><br /></td></tr>
<tr class="separator:afb6c2833576b0f1370195d8d6fbe9d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c68f728b01e8123c188f9c06b58cbe7"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1c68f728b01e8123c188f9c06b58cbe7">heuristicILOT</a> (double &amp;hi, double &amp;hl, double &amp;ho, double &amp;ht, double const surfaceAreaRoot, double const surfaceAreaInterior, double const surfaceAreaLeaf, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:a1c68f728b01e8123c188f9c06b58cbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(C_T\) heuristic preserving partials result of interest.  <a href="#a1c68f728b01e8123c188f9c06b58cbe7">More...</a><br /></td></tr>
<tr class="separator:a1c68f728b01e8123c188f9c06b58cbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade176397ca04cd7460e49eec33f76b91"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ade176397ca04cd7460e49eec33f76b91">cumulativeILOT</a> (double &amp;hi, double &amp;hl, double &amp;ho, double &amp;ht, double const _hi, double const _hl, double const _ho, double const saRoot) const</td></tr>
<tr class="memdesc:ade176397ca04cd7460e49eec33f76b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cumulative of \(C_T\) heuristic ILOT.  <a href="#ade176397ca04cd7460e49eec33f76b91">More...</a><br /></td></tr>
<tr class="separator:ade176397ca04cd7460e49eec33f76b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a64d58b146834e8fb804d25dc66a92a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9a64d58b146834e8fb804d25dc66a92a">internalizeILOT</a> (double &amp;hi, double &amp;hl, double &amp;ho, double &amp;ht, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;rightPrimitives)</td></tr>
<tr class="memdesc:a9a64d58b146834e8fb804d25dc66a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ILOT corresponding to internalization (make interior) of given node and its corresponding left and right splits.  <a href="#a9a64d58b146834e8fb804d25dc66a92a">More...</a><br /></td></tr>
<tr class="separator:a9a64d58b146834e8fb804d25dc66a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb53bebdca06fea392f30075915ccdf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf">toILOTCache</a> (double const I, double const L, double const O, double const T)</td></tr>
<tr class="memdesc:abfb53bebdca06fea392f30075915ccdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ILOT cache from given values.  <a href="#abfb53bebdca06fea392f30075915ccdf">More...</a><br /></td></tr>
<tr class="separator:abfb53bebdca06fea392f30075915ccdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651693da9d8e1431bfcdc40673471e62"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62">fromILOTCache</a> (double &amp;I, double &amp;L, double &amp;O, double &amp;T) const</td></tr>
<tr class="memdesc:a651693da9d8e1431bfcdc40673471e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set references from ILOT cache.  <a href="#a651693da9d8e1431bfcdc40673471e62">More...</a><br /></td></tr>
<tr class="separator:a651693da9d8e1431bfcdc40673471e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba7534ee95ef054eb9727921becb196"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9ba7534ee95ef054eb9727921becb196">fromILOCache</a> (double &amp;I, double &amp;L, double &amp;O) const</td></tr>
<tr class="memdesc:a9ba7534ee95ef054eb9727921becb196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set references from ILOT cache but only for ILO components.  <a href="#a9ba7534ee95ef054eb9727921becb196">More...</a><br /></td></tr>
<tr class="separator:a9ba7534ee95ef054eb9727921becb196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4241c91c603c8359cb8339b4e5f2e860"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a4241c91c603c8359cb8339b4e5f2e860">getCacheT</a> () const</td></tr>
<tr class="memdesc:a4241c91c603c8359cb8339b4e5f2e860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the T component of ILOT cache.  <a href="#a4241c91c603c8359cb8339b4e5f2e860">More...</a><br /></td></tr>
<tr class="separator:a4241c91c603c8359cb8339b4e5f2e860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f058348ffc9432e614672e0ce4b6e80"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a4f058348ffc9432e614672e0ce4b6e80">initILOT</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *root, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives)</td></tr>
<tr class="memdesc:a4f058348ffc9432e614672e0ce4b6e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the ILOT cache from given root node.  <a href="#a4f058348ffc9432e614672e0ce4b6e80">More...</a><br /></td></tr>
<tr class="separator:a4f058348ffc9432e614672e0ce4b6e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec5d2b00b82b76e07be47619f305646"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#afec5d2b00b82b76e07be47619f305646">setCacheRoot</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *root)</td></tr>
<tr class="memdesc:afec5d2b00b82b76e07be47619f305646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cached root node.  <a href="#afec5d2b00b82b76e07be47619f305646">More...</a><br /></td></tr>
<tr class="separator:afec5d2b00b82b76e07be47619f305646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSimpleKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSimpleKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html">SimpleKDTreeFactory</a></td></tr>
<tr class="memitem:a96323d9575182f1bedbd013991a693a6 inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a96323d9575182f1bedbd013991a693a6">buildRecursive</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, int const depth, int const index)</td></tr>
<tr class="memdesc:a96323d9575182f1bedbd013991a693a6 inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively build a KDTree for given primitives.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a96323d9575182f1bedbd013991a693a6">More...</a><br /></td></tr>
<tr class="separator:a96323d9575182f1bedbd013991a693a6 inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070315453cd5192e4e41dd2594fec91a inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a070315453cd5192e4e41dd2594fec91a">buildRecursiveRecipe</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, int const depth, int const index, std::function&lt; void(<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives)&gt; f_computeNodeBoundaries, std::function&lt; void(<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, int const depth)&gt; f_defineSplit, std::function&lt; void(vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const splitAxis, double const splitPos, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives)&gt; f_populateSplits, std::function&lt; void(<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const depth, int const index, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives)&gt; f_buildChildrenNodes)</td></tr>
<tr class="memdesc:a070315453cd5192e4e41dd2594fec91a inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">The recipe of the recursive building algorithm. It is meant to be used by the <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a96323d9575182f1bedbd013991a693a6" title="Recursively build a KDTree for given primitives. ">SimpleKDTreeFactory::buildRecursive</a> but also by any alternative implementation which shares the same recipe (global logic) but changes the way some parts are computed. For instance, it is used by the <a class="el" href="../../df/d86/classMultiThreadKDTreeFactory.html" title="Decorator for any KDTree factory which provides support for multi thread KDTree building. ">MultiThreadKDTreeFactory</a> to handle geometry-level parallelization.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a070315453cd5192e4e41dd2594fec91a">More...</a><br /></td></tr>
<tr class="separator:a070315453cd5192e4e41dd2594fec91a inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5466631a7dc4fd2102c338645ff2af inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a0f5466631a7dc4fd2102c338645ff2af">reportKDTreeStats</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:a0f5466631a7dc4fd2102c338645ff2af inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report KDTree stats of given root node at INFO logging level.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a0f5466631a7dc4fd2102c338645ff2af">More...</a><br /></td></tr>
<tr class="separator:a0f5466631a7dc4fd2102c338645ff2af inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a2b1d37c6dfe2b97a502a85e6154c5 inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#ab3a2b1d37c6dfe2b97a502a85e6154c5">populateSplits</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const splitAxis, double const splitPos, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives) const</td></tr>
<tr class="memdesc:ab3a2b1d37c6dfe2b97a502a85e6154c5 inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate list of primitives for left and right splits from given primitives of node being splitted.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#ab3a2b1d37c6dfe2b97a502a85e6154c5">More...</a><br /></td></tr>
<tr class="separator:ab3a2b1d37c6dfe2b97a502a85e6154c5 inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc932ae3ef28f324a656add6c1ac5bd inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd">computeNodeBoundaries</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:abbc932ae3ef28f324a656add6c1ac5bd inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute min and max position and surface area of bounding cuboid for given node.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd">More...</a><br /></td></tr>
<tr class="separator:abbc932ae3ef28f324a656add6c1ac5bd inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4da1338fe0cb580a4b08af270c5a16b inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aa4da1338fe0cb580a4b08af270c5a16b">onPopulateSplitsDigestPrimitive</a> (<a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *p, int const splitAxis, double const splitPos, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives) const</td></tr>
<tr class="memdesc:aa4da1338fe0cb580a4b08af270c5a16b inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assist <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#ab3a2b1d37c6dfe2b97a502a85e6154c5" title="Populate list of primitives for left and right splits from given primitives of node being splitted...">SimpleKDTreeFactory::populateSplits</a> by providing the logic of digesting a primitive.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#aa4da1338fe0cb580a4b08af270c5a16b">More...</a><br /></td></tr>
<tr class="separator:aa4da1338fe0cb580a4b08af270c5a16b inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c59136d3519ec54eb3ac911fd3c5e2 inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#ac6c59136d3519ec54eb3ac911fd3c5e2">computeMinMaxSAHForChild</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:ac6c59136d3519ec54eb3ac911fd3c5e2 inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assist <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd" title="Compute min and max position and surface area of bounding cuboid for given node. ">SimpleKDTreeFactory::computeNodeBoundaries</a> when computing surface area heuristic and minimum and maximum positions for child nodes.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#ac6c59136d3519ec54eb3ac911fd3c5e2">More...</a><br /></td></tr>
<tr class="separator:ac6c59136d3519ec54eb3ac911fd3c5e2 inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d40a5c71953a134e8c8edcb6564a8d1 inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a9d40a5c71953a134e8c8edcb6564a8d1">onRootBoundariesDigestPrimitive</a> (<a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *primitive, double &amp;ax, double &amp;ay, double &amp;az, double &amp;bx, double &amp;by, double &amp;bz) const</td></tr>
<tr class="memdesc:a9d40a5c71953a134e8c8edcb6564a8d1 inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assist <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd" title="Compute min and max position and surface area of bounding cuboid for given node. ">SimpleKDTreeFactory::computeNodeBoundaries</a> by providing the logic of digesting a primitive.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a9d40a5c71953a134e8c8edcb6564a8d1">More...</a><br /></td></tr>
<tr class="separator:a9d40a5c71953a134e8c8edcb6564a8d1 inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94faad23b678f0df745f0e5bf9284b52 inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a94faad23b678f0df745f0e5bf9284b52">onComputeNodeBoundariesCalcSAH</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, double const ax, double const ay, double const az, double const bx, double const by, double const bz) const</td></tr>
<tr class="memdesc:a94faad23b678f0df745f0e5bf9284b52 inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assist <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd" title="Compute min and max position and surface area of bounding cuboid for given node. ">SimpleKDTreeFactory::computeNodeBoundaries</a> when computing the SAH for a node.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a94faad23b678f0df745f0e5bf9284b52">More...</a><br /></td></tr>
<tr class="separator:a94faad23b678f0df745f0e5bf9284b52 inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d890b27a27a5afb79ca3babfc270961 inherit pro_methods_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a6d890b27a27a5afb79ca3babfc270961">makeLeaf</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:a6d890b27a27a5afb79ca3babfc270961 inherit pro_methods_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make given node a leaf one.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a6d890b27a27a5afb79ca3babfc270961">More...</a><br /></td></tr>
<tr class="separator:a6d890b27a27a5afb79ca3babfc270961 inherit pro_methods_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:a837bf89fb39600314e02f9fa9d05ec9b inherit pro_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a837bf89fb39600314e02f9fa9d05ec9b">lighten</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root)</td></tr>
<tr class="memdesc:a837bf89fb39600314e02f9fa9d05ec9b inherit pro_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuild all children of given root KDTree node as LightKDTeeeNode nodes.  <a href="../../d5/dd0/classKDTreeFactory.html#a837bf89fb39600314e02f9fa9d05ec9b">More...</a><br /></td></tr>
<tr class="separator:a837bf89fb39600314e02f9fa9d05ec9b inherit pro_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0db942ba81564682211127cc1d21c3 inherit pro_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../dd/d79/classLightKDTreeNode.html">LightKDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#aad0db942ba81564682211127cc1d21c3">_lighten</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node)</td></tr>
<tr class="memdesc:aad0db942ba81564682211127cc1d21c3 inherit pro_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assist <a class="el" href="../../d5/dd0/classKDTreeFactory.html#a837bf89fb39600314e02f9fa9d05ec9b" title="Rebuild all children of given root KDTree node as LightKDTeeeNode nodes. ">KDTreeFactory::lighten</a> function by handling the lighten of a given non-root node.  <a href="../../d5/dd0/classKDTreeFactory.html#aad0db942ba81564682211127cc1d21c3">More...</a><br /></td></tr>
<tr class="separator:aad0db942ba81564682211127cc1d21c3 inherit pro_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa4bc15caaa3456f80cbcd729434e1d37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37">lossNodes</a></td></tr>
<tr class="memdesc:aa4bc15caaa3456f80cbcd729434e1d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many loss nodes must be computed when optimizing the loss function \(\mathcal{L}_2\) to determine the best split position for a given KDTree node.  <a href="#aa4bc15caaa3456f80cbcd729434e1d37">More...</a><br /></td></tr>
<tr class="separator:aa4bc15caaa3456f80cbcd729434e1d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4924bf2b271633b2faeb94bb09ab7d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d">ci</a></td></tr>
<tr class="memdesc:a6c4924bf2b271633b2faeb94bb09ab7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost-weight for traversing interior nodes.  <a href="#a6c4924bf2b271633b2faeb94bb09ab7d">More...</a><br /></td></tr>
<tr class="separator:a6c4924bf2b271633b2faeb94bb09ab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafa7895196056285055f316cd8daf3a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a">cl</a></td></tr>
<tr class="memdesc:acafa7895196056285055f316cd8daf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost-weight for traversing leaf nodes.  <a href="#acafa7895196056285055f316cd8daf3a">More...</a><br /></td></tr>
<tr class="separator:acafa7895196056285055f316cd8daf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142e8bb1c4a2d1ed9adf95f71712199b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b">co</a></td></tr>
<tr class="memdesc:a142e8bb1c4a2d1ed9adf95f71712199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost-weight for testing an object for intersection.  <a href="#a142e8bb1c4a2d1ed9adf95f71712199b">More...</a><br /></td></tr>
<tr class="separator:a142e8bb1c4a2d1ed9adf95f71712199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80997d3fd5920a2420bd5d6cec3f7f97"><td class="memItemLeft" align="right" valign="top"><a id="a80997d3fd5920a2420bd5d6cec3f7f97"></a>
<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a80997d3fd5920a2420bd5d6cec3f7f97">cacheRoot</a> = nullptr</td></tr>
<tr class="memdesc:a80997d3fd5920a2420bd5d6cec3f7f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache pointer to root node of current KDTree being built. <br /></td></tr>
<tr class="separator:a80997d3fd5920a2420bd5d6cec3f7f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64b42cd6f03a2dcf6ba826af2333ba6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6">cacheI</a></td></tr>
<tr class="memdesc:ab64b42cd6f03a2dcf6ba826af2333ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid interior cost.  <a href="#ab64b42cd6f03a2dcf6ba826af2333ba6">More...</a><br /></td></tr>
<tr class="separator:ab64b42cd6f03a2dcf6ba826af2333ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e33369b2f14231102100027a2e4983"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983">cacheL</a></td></tr>
<tr class="memdesc:ae6e33369b2f14231102100027a2e4983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid leaves cost.  <a href="#ae6e33369b2f14231102100027a2e4983">More...</a><br /></td></tr>
<tr class="separator:ae6e33369b2f14231102100027a2e4983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9276d22252cc81236f52d89cf4ed63db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db">cacheO</a></td></tr>
<tr class="memdesc:a9276d22252cc81236f52d89cf4ed63db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid object cost.  <a href="#a9276d22252cc81236f52d89cf4ed63db">More...</a><br /></td></tr>
<tr class="separator:a9276d22252cc81236f52d89cf4ed63db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab269aee31019615eb45303713ee5b1ee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab269aee31019615eb45303713ee5b1ee">cacheT</a></td></tr>
<tr class="memdesc:ab269aee31019615eb45303713ee5b1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache last valid tree cost.  <a href="#ab269aee31019615eb45303713ee5b1ee">More...</a><br /></td></tr>
<tr class="separator:ab269aee31019615eb45303713ee5b1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfc278ecd4db90c08c79099e48d5dd3"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(void)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aebfc278ecd4db90c08c79099e48d5dd3">_lockILOT</a></td></tr>
<tr class="memdesc:aebfc278ecd4db90c08c79099e48d5dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to lock the ILOT cache on a unique way (no thread but locker one must be able to use it). By default it is a void function, it must be overridden to provide concurrency handling.  <a href="#aebfc278ecd4db90c08c79099e48d5dd3">More...</a><br /></td></tr>
<tr class="separator:aebfc278ecd4db90c08c79099e48d5dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3b16fb524bc98106899bbdd7fc246e"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(void)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6f3b16fb524bc98106899bbdd7fc246e">_unlockILOT</a></td></tr>
<tr class="memdesc:a6f3b16fb524bc98106899bbdd7fc246e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to unlock the ILOT cache. It is the counterpart of the _lockILOT function.  <a href="#a6f3b16fb524bc98106899bbdd7fc246e">More...</a><br /></td></tr>
<tr class="separator:a6f3b16fb524bc98106899bbdd7fc246e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classSimpleKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSimpleKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html">SimpleKDTreeFactory</a></td></tr>
<tr class="memitem:a4c3213bf294ab8cd890ccc09e1297317 inherit pro_attribs_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *(<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *, bool const, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> * &gt; &amp;, int const, int const)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a4c3213bf294ab8cd890ccc09e1297317">_buildRecursive</a></td></tr>
<tr class="memdesc:a4c3213bf294ab8cd890ccc09e1297317 inherit pro_attribs_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">The member function as attribute used to recursively build KDTree nodes. By default it will be assigned to the buildRecursive member function but it might be overridden by other implementations. For instance, to wrap the buildRecursive behavior to handle parallel building of KDTrees.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#a4c3213bf294ab8cd890ccc09e1297317">More...</a><br /></td></tr>
<tr class="separator:a4c3213bf294ab8cd890ccc09e1297317 inherit pro_attribs_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba2468b2987b4bd93e3e832bdf52f00 inherit pro_attribs_classSimpleKDTreeFactory"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abba2468b2987b4bd93e3e832bdf52f00">minSplitPrimitives</a></td></tr>
<tr class="memdesc:abba2468b2987b4bd93e3e832bdf52f00 inherit pro_attribs_classSimpleKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many primitives are required for a node to be splitted.  <a href="../../d6/d96/classSimpleKDTreeFactory.html#abba2468b2987b4bd93e3e832bdf52f00">More...</a><br /></td></tr>
<tr class="separator:abba2468b2987b4bd93e3e832bdf52f00 inherit pro_attribs_classSimpleKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:aa6ede7a422802db8e6cbf537861d5f56 inherit pro_attribs_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#aa6ede7a422802db8e6cbf537861d5f56">buildLightNodes</a> = true</td></tr>
<tr class="memdesc:aa6ede7a422802db8e6cbf537861d5f56 inherit pro_attribs_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">When it is true, the <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> is expected to build light nodes. It is, built KDTree must have a KDTreeRootNode which children are all <a class="el" href="../../dd/d79/classLightKDTreeNode.html" title="Class representing a light KDTree node. It is, the basic representation of a KDTree node with uses le...">LightKDTreeNode</a>. When it is false, <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> is allowed to build KDTree with <a class="el" href="../../d8/d94/classKDTreeNode.html" title="Class representing a KDTree node. ">KDTreeNode</a> children, which might require more memory.  <a href="../../d5/dd0/classKDTreeFactory.html#aa6ede7a422802db8e6cbf537861d5f56">More...</a><br /></td></tr>
<tr class="separator:aa6ede7a422802db8e6cbf537861d5f56 inherit pro_attribs_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5316cf17aff5dd178d2a84d31410e213 inherit pro_attribs_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d04/classLightKDTreeNodeBlockAllocator.html">LightKDTreeNodeBlockAllocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a5316cf17aff5dd178d2a84d31410e213">lkdtnBlockAllocator</a></td></tr>
<tr class="memdesc:a5316cf17aff5dd178d2a84d31410e213 inherit pro_attribs_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">The block allocator to speed-up lighten of KDTree by reducing allocation calls when instantiating multiple <a class="el" href="../../dd/d79/classLightKDTreeNode.html" title="Class representing a light KDTree node. It is, the basic representation of a KDTree node with uses le...">LightKDTreeNode</a>.  <a href="../../d5/dd0/classKDTreeFactory.html#a5316cf17aff5dd178d2a84d31410e213">More...</a><br /></td></tr>
<tr class="separator:a5316cf17aff5dd178d2a84d31410e213 inherit pro_attribs_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7bbb4cb358a300d406ee3688ccc97d27"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a7bbb4cb358a300d406ee3688ccc97d27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a7bbb4cb358a300d406ee3688ccc97d27">serialize</a> (Archive &amp;ar, unsigned int const version)</td></tr>
<tr class="memdesc:a7bbb4cb358a300d406ee3688ccc97d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a surface area heuristic KDTree factory to a stream of bytes.  <a href="#a7bbb4cb358a300d406ee3688ccc97d27">More...</a><br /></td></tr>
<tr class="separator:a7bbb4cb358a300d406ee3688ccc97d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9650f59fc614fd5694c3630aa95bdb16"><td class="memItemLeft" align="right" valign="top"><a id="a9650f59fc614fd5694c3630aa95bdb16"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MultiThreadSAHKDTreeFactory</b></td></tr>
<tr class="separator:a9650f59fc614fd5694c3630aa95bdb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450b5ab36aacf763460461f60411159a"><td class="memItemLeft" align="right" valign="top"><a id="a450b5ab36aacf763460461f60411159a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SAHKDTreeGeometricStrategy</b></td></tr>
<tr class="separator:a450b5ab36aacf763460461f60411159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top"><a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::serialization::access</b></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class providing building methods for k-dimensional trees with surface area heuristic (SAH) </p>
<dl class="section author"><dt>Author</dt><dd>Alberto M. Esmoris Pena </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0</dd></dl>
<p>The surface area heuristic KDTree factory defines the split point from the fact that an optimal performance point must be between the median of the distribution and the geometric center.</p>
<p>Let \(C_i\), \(C_l\) and \(C_o\) be the cost-weight for traversing interior nodes, traversing leaf nodes and testing an object for intersection respectively. Also, let \(N_i\), \(N_l\) and \(N_o\) number of interior nodes, number of leaf nodes and number of objects. Considering \(S_A(i)\) the surface area of the i-th interior node, \(S_A(l)\) the surface area of the l-th leaf node and generically \(S_A(x)\) the surface area of the \(x\) object or the \(x\) set of objects. It is now possible to define the cost of the tree where \(R\) is the root node as follows, where \(N_o(l)\) is the number of objects in the \(l\)-th leaf:</p>
<p class="formulaDsp">
\[ C_T = \frac{ C_i \sum_{i=1}^{N_i}{S_A(i)} + C_l \sum_{l=1}^{N_l}{S_A(l)} + C_o \sum_{l=1}^{N_l}{S_A(l) N_o(l)} } {S_A(R)} \]
</p>
<p>Alternatively, let \(S_l(o)\) be the set of leaves in which object \(o\) resides so the cost of the tree can be also defined as:</p>
<p class="formulaDsp">
\[ C&#39;_T = \frac{ C_i \sum_{i=1}^{N_i}{S_A(i)} + C_l \sum_{l=1}^{N_l}{S_A(l)} + C_o \sum_{o=1}^{N_o}{S_A[S_l(o)]} } {S_A(R)} \]
</p>
<p>The main difference between \(C_T\) and \(C&#39;_T\) would be that the second one fits better the case where a ray is not going to intersect multiple times the same object.</p>
<p>Now, let \(r\) be the normalized position of the splitting hyperplane for node \(N\) so \(r=0\) is the lower limit, \(r=1\) is the upper limit and \(r=\frac{1}{2}\) is the center. Moreover, let \(L_r\) and \(R_r\) be the left and right parts for the \(r\) split position and \(N_o(L_r)\) and \(N_o(R_r)\) be the number of objects at the left and right splits respectively. In consequence, following loss function arises:</p>
<p class="formulaDsp">
\[ \mathcal{L}(r) = S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r) - S_A(N)N_o(N) \]
</p>
<p>Alternatively, considering the term \(-S_A(N)N_o(N)\) is the amount of work saved by making the node an interior one (so the minus sign), it can be treated as a constant so for the sake of simplicity it would lead to:</p>
<p class="formulaDsp">
\[ \begin{array}{lll} \mathcal{L}(r) &amp;=&amp; S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r) \\ &amp;=&amp; rS_A(N)N_o(L_r) + (1-r)S_A(N)N_o(R_r) \\ &amp;=&amp; S_A(N) \left[rN_o(L_r) + (1-r)N_o(R_r)\right] \end{array} \]
</p>
<p>Differentiating with respect to \(r\) leads to: </p><p class="formulaDsp">
\[ \frac{d\mathcal{L}}{dr} = \left[2N_o(L_r) - N_o(N)\right]\frac{d}{dr}S_A(L_r) + \left[ S_A(L_r) - S_A(R_r) \right] \frac{d}{dr}N_o(L_r) \]
</p>
<p>Although \(N_o(L_r)\) is a discontinuous function, which implies \(\frac{d}{dr}N_o(L_r)\) is not defined, it is known that is always nonnegative which is enough to define a valid minimization criteria. In consequence, it is possible to analyze different scenarios. First, consider the case where the median lies somewhere satisfying \(r &lt; \frac{1}{2}\). Thus, \(\frac{d}{dr}\mathcal{L}(r) &lt; 0\) at the left side of the object median because \(N_o(L_r) &lt; \frac{N_o(N)}{2}\) and \(S_A(L_r) &lt; S_A(R_r)\). On the other hand, \(\frac{d}{dr}\mathcal{L}(r) &gt; 0\) at the right side of the spatial median because \(N_o(L_r) &lt; \frac{N_o(N)}{2}\) and \(S_A(L_r) &gt; S_A(R_r)\). So the minimum must occur between the object median and the spatial median if the object median is to the left of the spatial median. It is easy to see that an analogous argument applies for the case where the object median is to the right of the spatial median. Then, the optimum split must lie between the object median and the spatial median (center).</p>
<p>To clarify, the object median is understood as related to the splitting plane that places one half of the objects on each side of the plane. While the spatial median \(\mu\) for a given KDTree node in \(\mathbb{R}^{n}\) with \(a = (a_1, \ldots, a_n)\) as minimum vertex and \(b = (b_1, \ldots, b_n)\) as maximum vertex is:</p>
<p class="formulaDsp">
\[ \mu = \frac{a+b}{2} = \left(\frac{a_1+b_1}{2}, \ldots, \frac{a_n+b_n}{2}\right) \]
</p>
<p><em>For a more detailed explanation refer to "Heuristics for ray tracing
 using space subdivision" by J. David MacDonald and Kellogg S. Booth. </em></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k-dimensional trees. ">SimpleKDTreeFactory</a> </dd>
<dd>
<a class="el" href="../../df/d30/classAxisSAHKDTreeFactory.html" title="Class providing building methods for k-dimensional trees with surface area heuristic and greedy selec...">AxisSAHKDTreeFactory</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1b542136f4c7cbf63ac51ea1005ff544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b542136f4c7cbf63ac51ea1005ff544">&#9670;&nbsp;</a></span>SAHKDTreeFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAHKDTreeFactory::SAHKDTreeFactory </td>
          <td>(</td>
          <td class="paramtype">size_t const&#160;</td>
          <td class="paramname"><em>lossNodes</em> = <code>21</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>ci</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>cl</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>co</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Surface area heuristic KDTree factory default constructor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d" title="Cost-weight for traversing interior nodes. ">SAHKDTreeFactory::ci</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a" title="Cost-weight for traversing leaf nodes. ">SAHKDTreeFactory::cl</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b" title="Cost-weight for testing an object for intersection. ">SAHKDTreeFactory::co</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1ce94a7548b00220c2970becba91ff8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce94a7548b00220c2970becba91ff8b">&#9670;&nbsp;</a></span>buildChildrenNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::buildChildrenNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build children nodes using \(C_T\) heuristic to handle KDTree in-depth partitioning. </p>
<p>If root node, then by default assume it is a leaf node containing all primitives: </p><p class="formulaDsp">
\[ t_0 : \mathrm{ILOT} = C_T = \frac{1}{S_A(R)} \left[ C_lS_A(R) + C_oS_A(R)N_o(R) \right] \]
</p>
<p>After this, speculate its cost if it is make an interior node with its primitives being splitted into 2 leaf nodes: </p><p class="formulaDsp">
\[ C_{Sr} = \frac{1}{S_A(R)} \left[ C_i S_A(R) + C_l \sum_{l=1}^{2} {S_A(l)} + C_o \sum_{l=1}^{2} {S_A(l)N_o(l)} \right] \]
</p>
<p>Now if \(C_{Sr} \geq C_T\) at \(t_0\) then the process is stopped and all primitives remain in the root node. Otherwise, \(t_1\) happend so: </p><p class="formulaDsp">
\[ t_1 : \mathrm{ILOT} = C_T = C_{Sr} \]
</p>
<p>After the initial case, a similar process is recursively applied to each new node until \(C_{Si} \geq C_{T}\). It is, until the speculative cost is found to be greater or equal than current cost. This new speculative cost for non-root interior nodes is computed as follows, where \(N\) is current leaf node which might be splitted depending on analysis and \(L_r\) and \(R_r\) are its left and right splits respectively: </p><p class="formulaDsp">
\[ \left\{\begin{array}{lll} k_1 &amp;=&amp; C_i S_A(N) \\ k_2 &amp;=&amp; C_l \left(S_A(L_r) + S_A(R_r)\right) - C_l S_A(N) \\ k_3 &amp;=&amp; C_o \left(S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r)\right) - C_o S_A(N)N_o(N) \\ C_{Si} &amp;=&amp; \frac{1}{S_A(R)} \left[ C_i \sum_{i=1}^{N_i} S_A(i) + k_1 + C_l \sum_{l=1}^{N_l} S_A(l) + k_2 + C_o \sum_{l=1}^{N_l} S_A(l)N_o(l) + k_3 \right] \end{array}\right. \]
</p>
<p>Thus, iterations \(x&gt;1\) that will only happen when \(C_{Si} &lt; C_T\) can be defined as: </p><p class="formulaDsp">
\[ t_{x&gt;1} : \mathrm{ILOT} = C_T = C_{Si} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a9c77a23429fcf72e7f5c46429e72f7af" title="Build children nodes for given node. If no children nodes must be built, then the node is configured ...">SimpleKDTreeFactory::buildChildrenNodes</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15" title="Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in d...">SAHKDTreeFactory::computeKDTreeStats</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a9c77a23429fcf72e7f5c46429e72f7af">SimpleKDTreeFactory</a>.</p>

</div>
</div>
<a id="ab6ca93261853fe9d6929ccee7f62ca46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ca93261853fe9d6929ccee7f62ca46">&#9670;&nbsp;</a></span>buildChildrenNodesRecipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::buildChildrenNodesRecipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, int const depth, int const index, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives)&gt;&#160;</td>
          <td class="paramname"><em>f_buildChildrenNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The recipe for building of children nodes by SAH algorithm. It is meant to be used by the <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1ce94a7548b00220c2970becba91ff8b" title="Build children nodes using  heuristic to handle KDTree in-depth partitioning. ">SAHKDTreeFactory::buildChildrenNodes</a> but also by any alternative implementation which shared the same recipe (global logic) but changes the way some parts are computed. For instance, it is used to handle geometry-level parallelization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_buildChildrenNodes</td><td>Function to do the building of the children nodes itself</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1ce94a7548b00220c2970becba91ff8b" title="Build children nodes using  heuristic to handle KDTree in-depth partitioning. ">SAHKDTreeFactory::buildChildrenNodes</a> </dd>
<dd>
SAHKDTreeFactory::GEOM_buildChildrenNodes </dd>
<dd>
<a class="el" href="../../df/d86/classMultiThreadKDTreeFactory.html" title="Decorator for any KDTree factory which provides support for multi thread KDTree building. ">MultiThreadKDTreeFactory</a> </dd></dl>

</div>
</div>
<a id="a13833d1dc848b2bd3b159815d8be45eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13833d1dc848b2bd3b159815d8be45eb">&#9670;&nbsp;</a></span>checkNodeMustSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SAHKDTreeFactory::checkNodeMustSplit </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check wheter the node must be splitted (true) or not (false) depending on its total primitives. </p>
<p>For a SAH KDT a node must be splitted if there are enough primitives.</p>
<dl class="section return"><dt>Returns</dt><dd>True if node must be splitted, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a34143864d77d79ef1677a06bd5b938f6" title="Check wheter the node must be splitted (true) or not (false) depending on its total primitives and th...">SimpleKDTreeFactory::checkNodeMustSplit</a> </dd>
<dd>
<a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abba2468b2987b4bd93e3e832bdf52f00" title="How many primitives are required for a node to be splitted. ">SimpleKDTreeFactory::minSplitPrimitives</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a34143864d77d79ef1677a06bd5b938f6">SimpleKDTreeFactory</a>.</p>

</div>
</div>
<a id="abbe00df5e1eb262f635640a431ccc5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe00df5e1eb262f635640a431ccc5ad">&#9670;&nbsp;</a></span>computeBestSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::computeBestSplit </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t const&#160;</td>
          <td class="paramname"><em>lossNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>splitAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>minBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>boundLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>loss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>splitPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iteratively compute the best split position, it is the one with smaller loss. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loss</td><td>Where initial loss is stored and where best found loss will be written </td></tr>
    <tr><td class="paramname">splitPos</td><td>Where initial split position is stored and where best found split position will be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac123def37ff4bc4598d7d09bcbfff59c" title="Find the best split position using Surface Area Heuristic (SAH) as described in SAHKDTreeFactory::def...">SAHKDTreeFactory::findSplitPositionBySAH</a> </dd>
<dd>
SAHKDTreeFactory::GEOM_findSplitPositionBySAH </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#afb6c2833576b0f1370195d8d6fbe9d8d" title="The recipe for finding split position by SAH algorithm. It is meant to be used by the SAHKDTreeFactor...">SAHKDTreeFactory::findSplitPositionBySAHRecipe</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549" title="Compute the loss function for the splitting hyperplane. ">SAHKDTreeFactory::splitLoss</a> </dd></dl>

</div>
</div>
<a id="aca4a9fd27edb126bcbc9fc5020ef9f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4a9fd27edb126bcbc9fc5020ef9f15">&#9670;&nbsp;</a></span>computeKDTreeStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::computeKDTreeStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in defineSplit function. </p>
<p>Current tree cost is computed as \(C_T\) not as \(C&#39;_T\)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a259a3500ce239f33914d5da0c694b427" title="Analyze KDTree computing its max depth and the minimum and maximum number of primitives considering a...">SimpleKDTreeFactory::computeKDTreeStats</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1ce94a7548b00220c2970becba91ff8b" title="Build children nodes using  heuristic to handle KDTree in-depth partitioning. ">SAHKDTreeFactory::buildChildrenNodes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a259a3500ce239f33914d5da0c694b427">SimpleKDTreeFactory</a>.</p>

</div>
</div>
<a id="ade176397ca04cd7460e49eec33f76b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade176397ca04cd7460e49eec33f76b91">&#9670;&nbsp;</a></span>cumulativeILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cumulativeILOT </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>_hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>_ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>saRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cumulative of \(C_T\) heuristic ILOT. </p>
<p><b><span style="color: red">WARNING</span></b> given reference to current total tree cost is also updated, not only returned. Thus, this is a full ILOT write function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">hi</td><td>Current partial interior cost to be updated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hl</td><td>Current partial leaves cost to be updated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ho</td><td>Current partial object cost to be updated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ht</td><td>Current total tree cost to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_hi</td><td>Adding magnitude to update partial interior cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_hl</td><td>Adding magnitude to update partial leaves cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_ho</td><td>Adding magnitude to update partial objeccts cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saRoot</td><td>Surface area of root node \(S_A(R)\) defining cumulative ILOT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated total tree cost </dd></dl>

</div>
</div>
<a id="aa22c06947f61f871156922122c41084d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22c06947f61f871156922122c41084d">&#9670;&nbsp;</a></span>defineSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::defineSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define the split axis and position for current node. </p>
<p>To illustrate the define split method let \(a\) and \(b\) be the minimum and maximum vertices of given node. Let also \(\mu\) be the geometric center or spatial median and \(M_e\) be the object median. For the sake of simplicity, lets assume \(\mu &lt; M_e\) so the iterative method will start at \(\mu\) and end at \(M_e\). If it was the other way, then the iterative method would start at \(M_e\) and end at \(\mu\). Now, if \(n\) is the number of loss nodes, \(\mathcal{L}_2\) is the loss function as defined in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549" title="Compute the loss function for the splitting hyperplane. ">SAHKDTreeFactory::splitLoss</a> and \(r = \frac{\phi-a}{b-a} \in [0, 1]\) is the normalized position of split position \(\phi\). Then, the iterative method can be defined as:</p>
<p class="formulaDsp">
\[ \varphi(t) = \mu + t \frac{M_e-\mu}{n-1} \\ \left\{\begin{array}{lll} \phi_1 &amp;=&amp; \mu \\ \phi_{t&gt;1} &amp;=&amp; \left\{\begin{array}{lll} \varphi(t) &amp;,&amp; \mathcal{L}_2\left[(\varphi(t)-a)(b-a)^{-1}\right] &lt; \mathcal{L}_2\left[(\phi_{t-1}-a)(b-a)^{-1}\right] \\ \phi_{t-1} &amp;,&amp; \mathcal{L}_2\left[(\varphi(t)-a)(b-a)^{-1}\right] \geq \mathcal{L}_2\left[(\phi_{t-1}-a)(b-a)^{-1}\right] \end{array}\right. \end{array}\right. \]
</p>
<p>Finally, \(r=\phi_n\) is the best found split position.</p>
<p>Notice that the median is constrained so \(M_e \in [a, b]\). Thus, in case there are enough objects lying outside node boundaries causing the median to be also outside, it will be truncated.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aa3ed0e048fd2e9ae62fdd324e32153c5" title="Define the split axis and position for current node. ">SimpleKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15" title="Compute the simple stats of the KDTree but also its cost based on surface area heuristic defined in d...">SAHKDTreeFactory::computeKDTreeStats</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a1ce94a7548b00220c2970becba91ff8b" title="Build children nodes using  heuristic to handle KDTree in-depth partitioning. ">SAHKDTreeFactory::buildChildrenNodes</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549" title="Compute the loss function for the splitting hyperplane. ">SAHKDTreeFactory::splitLoss</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37" title="How many loss nodes must be computed when optimizing the loss function  to determine the best split p...">SAHKDTreeFactory::lossNodes</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac123def37ff4bc4598d7d09bcbfff59c" title="Find the best split position using Surface Area Heuristic (SAH) as described in SAHKDTreeFactory::def...">SAHKDTreeFactory::findSplitPositionBySAH</a> </dd></dl>

<p>Reimplemented from <a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aa3ed0e048fd2e9ae62fdd324e32153c5">SimpleKDTreeFactory</a>.</p>

</div>
</div>
<a id="ac123def37ff4bc4598d7d09bcbfff59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac123def37ff4bc4598d7d09bcbfff59c">&#9670;&nbsp;</a></span>findSplitPositionBySAH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::findSplitPositionBySAH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best split position using Surface Area Heuristic (SAH) as described in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Loss of best split position. The position itself is already stored in given node </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

<p>Reimplemented in <a class="el" href="../../d0/d0e/classFastSAHKDTreeFactory.html#a663032609bd4e732db17c073cf7249cb">FastSAHKDTreeFactory</a>.</p>

</div>
</div>
<a id="afb6c2833576b0f1370195d8d6fbe9d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6c2833576b0f1370195d8d6fbe9d8d">&#9670;&nbsp;</a></span>findSplitPositionBySAHRecipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::findSplitPositionBySAHRecipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt;::iterator begin, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt;::iterator end, <a class="el" href="../../d6/d1f/structKDTreePrimitiveComparator.html">KDTreePrimitiveComparator</a> comparator)&gt;&#160;</td>
          <td class="paramname"><em>f_sortPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, size_t const <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37">lossNodes</a>, double const start, double const step, int const splitAxis, double const minBound, double const boundLength, double &amp;loss, double &amp;splitPos)&gt;&#160;</td>
          <td class="paramname"><em>f_computeLossNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The recipe for finding split position by SAH algorithm. It is meant to be used by the <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac123def37ff4bc4598d7d09bcbfff59c" title="Find the best split position using Surface Area Heuristic (SAH) as described in SAHKDTreeFactory::def...">SAHKDTreeFactory::findSplitPositionBySAH</a> but also by any alternative implementation which shares the same recipe ( global logic) but changes the way some parts are computed. For instance, it is used to handle geometry-level parallelization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_sortPrimitives</td><td>Function to sort primitives </td></tr>
    <tr><td class="paramname">f_computeLossNodes</td><td>Function to iteratively compute loss nodes and find the split position with best loss (the smallest)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ac123def37ff4bc4598d7d09bcbfff59c" title="Find the best split position using Surface Area Heuristic (SAH) as described in SAHKDTreeFactory::def...">SAHKDTreeFactory::findSplitPositionBySAH</a> </dd>
<dd>
SAHKDTreeFactory::GEOM_findSplitPositionBySAH </dd>
<dd>
<a class="el" href="../../df/d86/classMultiThreadKDTreeFactory.html" title="Decorator for any KDTree factory which provides support for multi thread KDTree building. ">MultiThreadKDTreeFactory</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Loss of best split position. The position itself is already stored in given node </dd></dl>

</div>
</div>
<a id="a9ba7534ee95ef054eb9727921becb196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba7534ee95ef054eb9727921becb196">&#9670;&nbsp;</a></span>fromILOCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::fromILOCache </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>O</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set references from ILOT cache but only for ILO components. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6" title="Cache last valid interior cost. ">SAHKDTreeFactory::cacheI</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983" title="Cache last valid leaves cost. ">SAHKDTreeFactory::cacheL</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db" title="Cache last valid object cost. ">SAHKDTreeFactory::cacheO</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="a651693da9d8e1431bfcdc40673471e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651693da9d8e1431bfcdc40673471e62">&#9670;&nbsp;</a></span>fromILOTCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::fromILOTCache </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set references from ILOT cache. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6" title="Cache last valid interior cost. ">SAHKDTreeFactory::cacheI</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983" title="Cache last valid leaves cost. ">SAHKDTreeFactory::cacheL</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db" title="Cache last valid object cost. ">SAHKDTreeFactory::cacheO</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab269aee31019615eb45303713ee5b1ee" title="Cache last valid tree cost. ">SAHKDTreeFactory::cacheT</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9ba7534ee95ef054eb9727921becb196" title="Set references from ILOT cache but only for ILO components. ">SAHKDTreeFactory::fromILOCache</a> </dd></dl>

</div>
</div>
<a id="a4241c91c603c8359cb8339b4e5f2e860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4241c91c603c8359cb8339b4e5f2e860">&#9670;&nbsp;</a></span>getCacheT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getCacheT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the T component of ILOT cache. </p>
<dl class="section return"><dt>Returns</dt><dd>T component of ILOT cache </dd></dl>

</div>
</div>
<a id="a0fa181a6c477c5b55b514f9b12a70b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa181a6c477c5b55b514f9b12a70b31">&#9670;&nbsp;</a></span>getInteriorCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getInteriorCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the cost-weight of interior nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Cost-weight of interior nodes </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d" title="Cost-weight for traversing interior nodes. ">SAHKDTreeFactory::ci</a> </dd></dl>

</div>
</div>
<a id="a8cfd3132e5cfa427663f3c84b2d93175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfd3132e5cfa427663f3c84b2d93175">&#9670;&nbsp;</a></span>getLeafCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getLeafCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the cost-weight for leaf nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Cost-weight of leaf nodes </dd></dl>
<dl class="section see"><dt>See also</dt><dd>SAKHDTreeFactory::cl </dd></dl>

</div>
</div>
<a id="a57ba0e95461b489801cb085937f030a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ba0e95461b489801cb085937f030a6">&#9670;&nbsp;</a></span>getObjectCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAHKDTreeFactory::getObjectCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the cost-weight of testing an object for intersection. </p>
<dl class="section return"><dt>Returns</dt><dd>Cost-weight of testing an object for intersection </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b" title="Cost-weight for testing an object for intersection. ">SAHKDTreeFactory::co</a> </dd></dl>

</div>
</div>
<a id="a1c68f728b01e8123c188f9c06b58cbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c68f728b01e8123c188f9c06b58cbe7">&#9670;&nbsp;</a></span>heuristicILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::heuristicILOT </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>surfaceAreaRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>surfaceAreaInterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>surfaceAreaLeaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(C_T\) heuristic preserving partials result of interest. </p>
<p>Costs and previous values are taken from factory and ILOT cache respectively</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hi</td><td>Where the partial interior cost will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hl</td><td>Where the partial leaves cost will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ho</td><td>Where the partial object cost will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ht</td><td>Where the total tree cost will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfaceAreaRoot</td><td>Surface area of root node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfaceAreaInterior</td><td>Surface area of interior node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfaceAreaLeaf</td><td>Surface area of object/leaf node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primitives</td><td>Primitives defining the object/leaf cluster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(C_T\) as heuristic ILOT </dd></dl>

</div>
</div>
<a id="a4f058348ffc9432e614672e0ce4b6e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f058348ffc9432e614672e0ce4b6e80">&#9670;&nbsp;</a></span>initILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::initILOT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the ILOT cache from given root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node to initialize ILOT cache from </td></tr>
    <tr><td class="paramname">primitives</td><td>Primitives contained in root node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a64d58b146834e8fb804d25dc66a92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a64d58b146834e8fb804d25dc66a92a">&#9670;&nbsp;</a></span>internalizeILOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::internalizeILOT </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute ILOT corresponding to internalization (make interior) of given node and its corresponding left and right splits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>To store new interior heuristic cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hl</td><td>To store new leaves heuristic cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ho</td><td>To store new object heuristic cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ht</td><td>To store new tree heuristic cost </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>Node to internalize (make interior) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">primitives</td><td>Primitives on given node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">leftPrimitives</td><td>Primitives on left split </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rightPrimitives</td><td>Primitives on right split </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bbb4cb358a300d406ee3688ccc97d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbb4cb358a300d406ee3688ccc97d27">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAHKDTreeFactory::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int const&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a surface area heuristic KDTree factory to a stream of bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>Type of rendering </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Specific rendering for the stream of bytes </td></tr>
    <tr><td class="paramname">version</td><td>Version number for the surface area heuristic KDTree factory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afec5d2b00b82b76e07be47619f305646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec5d2b00b82b76e07be47619f305646">&#9670;&nbsp;</a></span>setCacheRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setCacheRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cached root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The new root node to be cached </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a80997d3fd5920a2420bd5d6cec3f7f97" title="Cache pointer to root node of current KDTree being built. ">SAHKDTreeFactory::cacheRoot</a> </dd></dl>

</div>
</div>
<a id="ac761118b31a69f0a5e76fcaff98d4036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac761118b31a69f0a5e76fcaff98d4036">&#9670;&nbsp;</a></span>setInteriorCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setInteriorCost </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>ci</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cost-weight of interior nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ci</td><td>New cost-weight for interior nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6c4924bf2b271633b2faeb94bb09ab7d" title="Cost-weight for traversing interior nodes. ">SAHKDTreeFactory::ci</a> </dd></dl>

</div>
</div>
<a id="a7073d3b60fce9cd0f92fcb56deed6e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7073d3b60fce9cd0f92fcb56deed6e9c">&#9670;&nbsp;</a></span>setLeafCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setLeafCost </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cost-weight for leaf nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cl</td><td>New cost-weight for leaf nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#acafa7895196056285055f316cd8daf3a" title="Cost-weight for traversing leaf nodes. ">SAHKDTreeFactory::cl</a> </dd></dl>

</div>
</div>
<a id="aa589ffb6e5cee46ea3c35fafb34e5038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa589ffb6e5cee46ea3c35fafb34e5038">&#9670;&nbsp;</a></span>setObjectCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::setObjectCost </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>co</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cost-weight of testing an object for intersection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">co</td><td>New cost-weight of testing an object for intersection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a142e8bb1c4a2d1ed9adf95f71712199b" title="Cost-weight for testing an object for intersection. ">SAHKDTreeFactory::co</a> </dd></dl>

</div>
</div>
<a id="a8cee7ca7d48bb5c0edfbfef43814c549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cee7ca7d48bb5c0edfbfef43814c549">&#9670;&nbsp;</a></span>splitLoss()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::splitLoss </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>splitAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>splitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the loss function for the splitting hyperplane. </p>
<p>The loss function by default is:</p>
<p class="formulaDsp">
\[ \begin{array}{lll} \mathcal{L}(r) &amp;=&amp; S_A(L_r)N_o(L_r) + S_A(R_r)N_o(R_r) \\ &amp;=&amp; S_A(N) [rN_o(L_r) + (1-r)N_o(R_r)] \end{array} \]
</p>
<p>However, as \(S_A(N)\) is a constant for the same node, it is computationally cheaper to compute an alternative version:</p>
<p class="formulaDsp">
\[ \mathcal{L_2}(r) = rN_o(L_r) + (1-r)N_o(R_r) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitives</td><td>Vector of primitives involved in the split </td></tr>
    <tr><td class="paramname">splitAxis</td><td>Axis at which split will be done </td></tr>
    <tr><td class="paramname">splitPos</td><td>Position of the hyperplane in the split axis </td></tr>
    <tr><td class="paramname">r</td><td>The ratio or normalized split position in \([0, 1]\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value obtained after evaluating loss function </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa4bc15caaa3456f80cbcd729434e1d37" title="How many loss nodes must be computed when optimizing the loss function  to determine the best split p...">SAHKDTreeFactory::lossNodes</a> </dd></dl>

</div>
</div>
<a id="abfb53bebdca06fea392f30075915ccdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb53bebdca06fea392f30075915ccdf">&#9670;&nbsp;</a></span>toILOTCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAHKDTreeFactory::toILOTCache </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set ILOT cache from given values. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab64b42cd6f03a2dcf6ba826af2333ba6" title="Cache last valid interior cost. ">SAHKDTreeFactory::cacheI</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae6e33369b2f14231102100027a2e4983" title="Cache last valid leaves cost. ">SAHKDTreeFactory::cacheL</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a9276d22252cc81236f52d89cf4ed63db" title="Cache last valid object cost. ">SAHKDTreeFactory::cacheO</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ab269aee31019615eb45303713ee5b1ee" title="Cache last valid tree cost. ">SAHKDTreeFactory::cacheT</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aebfc278ecd4db90c08c79099e48d5dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfc278ecd4db90c08c79099e48d5dd3">&#9670;&nbsp;</a></span>_lockILOT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(void)&gt; SAHKDTreeFactory::_lockILOT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to lock the ILOT cache on a unique way (no thread but locker one must be able to use it). By default it is a void function, it must be overridden to provide concurrency handling. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d95/classMultiThreadSAHKDTreeFactory.html" title="Decorator for any SAH KDTree which provides support for multi thread KDTree building. ">MultiThreadSAHKDTreeFactory</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a6f3b16fb524bc98106899bbdd7fc246e" title="Function to unlock the ILOT cache. It is the counterpart of the _lockILOT function. ">SAHKDTreeFactory::_unlockILOT</a> </dd></dl>

</div>
</div>
<a id="a6f3b16fb524bc98106899bbdd7fc246e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3b16fb524bc98106899bbdd7fc246e">&#9670;&nbsp;</a></span>_unlockILOT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(void)&gt; SAHKDTreeFactory::_unlockILOT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to unlock the ILOT cache. It is the counterpart of the _lockILOT function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d95/classMultiThreadSAHKDTreeFactory.html" title="Decorator for any SAH KDTree which provides support for multi thread KDTree building. ">MultiThreadSAHKDTreeFactory</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aebfc278ecd4db90c08c79099e48d5dd3" title="Function to lock the ILOT cache on a unique way (no thread but locker one must be able to use it)...">SAHKDTreeFactory::_lockILOT</a> </dd></dl>

</div>
</div>
<a id="ab64b42cd6f03a2dcf6ba826af2333ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64b42cd6f03a2dcf6ba826af2333ba6">&#9670;&nbsp;</a></span>cacheI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheI</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid interior cost. </p>
<p class="formulaDsp">
\[ C_i \sum_{i=1}^{N_i}{S_A(i)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="ae6e33369b2f14231102100027a2e4983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e33369b2f14231102100027a2e4983">&#9670;&nbsp;</a></span>cacheL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid leaves cost. </p>
<p class="formulaDsp">
\[ C_l \sum_{l=1}^{N_l}{S_A(l)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="a9276d22252cc81236f52d89cf4ed63db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9276d22252cc81236f52d89cf4ed63db">&#9670;&nbsp;</a></span>cacheO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid object cost. </p>
<p class="formulaDsp">
\[ C_o \sum_{l=1}^{N_l}{S_A(l) N_o(l)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="ab269aee31019615eb45303713ee5b1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab269aee31019615eb45303713ee5b1ee">&#9670;&nbsp;</a></span>cacheT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cacheT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache last valid tree cost. </p>
<p class="formulaDsp">
\[ C_T = \frac{ C_i \sum_{i=1}^{N_i}{S_A(i)} + C_l \sum_{l=1}^{N_l}{S_A(l)} + C_o \sum_{l=1}^{N_l}{S_A(l) N_o(l)} } {S_A(R)} \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#abfb53bebdca06fea392f30075915ccdf" title="Set ILOT cache from given values. ">SAHKDTreeFactory::toILOTCache</a> </dd>
<dd>
<a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a651693da9d8e1431bfcdc40673471e62" title="Set references from ILOT cache. ">SAHKDTreeFactory::fromILOTCache</a> </dd></dl>

</div>
</div>
<a id="a6c4924bf2b271633b2faeb94bb09ab7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4924bf2b271633b2faeb94bb09ab7d">&#9670;&nbsp;</a></span>ci</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::ci</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost-weight for traversing interior nodes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

</div>
</div>
<a id="acafa7895196056285055f316cd8daf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafa7895196056285055f316cd8daf3a">&#9670;&nbsp;</a></span>cl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::cl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost-weight for traversing leaf nodes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

</div>
</div>
<a id="a142e8bb1c4a2d1ed9adf95f71712199b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142e8bb1c4a2d1ed9adf95f71712199b">&#9670;&nbsp;</a></span>co</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SAHKDTreeFactory::co</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost-weight for testing an object for intersection. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d" title="Define the split axis and position for current node. ">SAHKDTreeFactory::defineSplit</a> </dd></dl>

</div>
</div>
<a id="aa4bc15caaa3456f80cbcd729434e1d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bc15caaa3456f80cbcd729434e1d37">&#9670;&nbsp;</a></span>lossNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAHKDTreeFactory::lossNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How many loss nodes must be computed when optimizing the loss function \(\mathcal{L}_2\) to determine the best split position for a given KDTree node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a8cee7ca7d48bb5c0edfbfef43814c549" title="Compute the loss function for the splitting hyperplane. ">SAHKDTreeFactory::splitLoss</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/adt/kdtree/<a class="el" href="../../d5/dc4/SAHKDTreeFactory_8h_source.html">SAHKDTreeFactory.h</a></li>
<li>src/adt/kdtree/SAHKDTreeFactory.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d58/classSAHKDTreeFactory.html">SAHKDTreeFactory</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
