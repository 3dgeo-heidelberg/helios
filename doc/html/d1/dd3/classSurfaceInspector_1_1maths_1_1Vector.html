<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios++: SurfaceInspector::maths::Vector&lt; T &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Helios++
   </div>
   <div id="projectbrief">Helios software for LiDAR simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../d5/d98/classSurfaceInspector_1_1maths_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SurfaceInspector::maths::Vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class providing vector operations.  
 <a href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/dd9/Vector_8hpp_source.html">Vector.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SurfaceInspector::maths::Vector&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="../../df/d49/classSurfaceInspector_1_1maths_1_1Vector__inherit__graph.png" border="0" usemap="#SurfaceInspector_1_1maths_1_1Vector_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="SurfaceInspector_1_1maths_1_1Vector_3_01T_01_4_inherit__map" id="SurfaceInspector_1_1maths_1_1Vector_3_01T_01_4_inherit__map">
<area shape="rect" id="node2" href="../../d2/df2/classSurfaceInspector_1_1util_1_1Object.html" title="Class representing an object. All surface inspector classes must extend Object. " alt="" coords="15,5,161,47"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SurfaceInspector::maths::Vector&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="../../d8/da2/classSurfaceInspector_1_1maths_1_1Vector__coll__graph.png" border="0" usemap="#SurfaceInspector_1_1maths_1_1Vector_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="SurfaceInspector_1_1maths_1_1Vector_3_01T_01_4_coll__map" id="SurfaceInspector_1_1maths_1_1Vector_3_01T_01_4_coll__map">
<area shape="rect" id="node2" href="../../d2/df2/classSurfaceInspector_1_1util_1_1Object.html" title="Class representing an object. All surface inspector classes must extend Object. " alt="" coords="15,5,161,47"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7e4a38ae9dbc489ef5cd8f6e18de44c1"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a7e4a38ae9dbc489ef5cd8f6e18de44c1">add</a> (vector&lt; T &gt; const u, vector&lt; T &gt; const v)</td></tr>
<tr class="memdesc:a7e4a38ae9dbc489ef5cd8f6e18de44c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two vectors.  <a href="#a7e4a38ae9dbc489ef5cd8f6e18de44c1">More...</a><br /></td></tr>
<tr class="separator:a7e4a38ae9dbc489ef5cd8f6e18de44c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb15a50fafae148c4b88b9fcb36668d"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a2bb15a50fafae148c4b88b9fcb36668d">subtract</a> (vector&lt; T &gt; const u, vector&lt; T &gt; const v)</td></tr>
<tr class="memdesc:a2bb15a50fafae148c4b88b9fcb36668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors.  <a href="#a2bb15a50fafae148c4b88b9fcb36668d">More...</a><br /></td></tr>
<tr class="separator:a2bb15a50fafae148c4b88b9fcb36668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6931a5c5a0e1eafad6c9ed1db1263214"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a6931a5c5a0e1eafad6c9ed1db1263214">scalarAdd</a> (vector&lt; T &gt; const u, T const scalar)</td></tr>
<tr class="memdesc:a6931a5c5a0e1eafad6c9ed1db1263214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the scalar to all elements in vector \(\overline{u}\).  <a href="#a6931a5c5a0e1eafad6c9ed1db1263214">More...</a><br /></td></tr>
<tr class="separator:a6931a5c5a0e1eafad6c9ed1db1263214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d2f909e61956e3a258a713b44484f2"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a94d2f909e61956e3a258a713b44484f2">scalarSubtract</a> (vector&lt; T &gt; const u, T const scalar)</td></tr>
<tr class="memdesc:a94d2f909e61956e3a258a713b44484f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the scalar to all elements in vector \(\overline{u}\).  <a href="#a94d2f909e61956e3a258a713b44484f2">More...</a><br /></td></tr>
<tr class="separator:a94d2f909e61956e3a258a713b44484f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c15403da25943f8d0446acd8ea7cb22"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a6c15403da25943f8d0446acd8ea7cb22">scalarMultiply</a> (vector&lt; T &gt; const u, T const scalar)</td></tr>
<tr class="memdesc:a6c15403da25943f8d0446acd8ea7cb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply all elements in vector \(overline{u}\) by scalar.  <a href="#a6c15403da25943f8d0446acd8ea7cb22">More...</a><br /></td></tr>
<tr class="separator:a6c15403da25943f8d0446acd8ea7cb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7408ebde0335d994236858ba4e831295"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a7408ebde0335d994236858ba4e831295">scalarDivide</a> (vector&lt; T &gt; const u, T const scalar)</td></tr>
<tr class="memdesc:a7408ebde0335d994236858ba4e831295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide all elements in vector \(\overline{u}\) by scalar.  <a href="#a7408ebde0335d994236858ba4e831295">More...</a><br /></td></tr>
<tr class="separator:a7408ebde0335d994236858ba4e831295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bafc6860b33d8360185046c5033bf6d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a0bafc6860b33d8360185046c5033bf6d">scalarAddInPlace</a> (vector&lt; T &gt; &amp;u, T const scalar)</td></tr>
<tr class="memdesc:a0bafc6860b33d8360185046c5033bf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like scalarAdd function but modifying given vector.  <a href="#a0bafc6860b33d8360185046c5033bf6d">More...</a><br /></td></tr>
<tr class="separator:a0bafc6860b33d8360185046c5033bf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043fe59241e476b661623aea20ffbbf0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a043fe59241e476b661623aea20ffbbf0">scalarSubtractInPlace</a> (vector&lt; T &gt; &amp;u, T const scalar)</td></tr>
<tr class="memdesc:a043fe59241e476b661623aea20ffbbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like scalarSubtract function but modifying given vector.  <a href="#a043fe59241e476b661623aea20ffbbf0">More...</a><br /></td></tr>
<tr class="separator:a043fe59241e476b661623aea20ffbbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a387503ead4b6f741b8702de8d9d00a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a8a387503ead4b6f741b8702de8d9d00a">scalarMultiplyInPlace</a> (vector&lt; T &gt; &amp;u, T const scalar)</td></tr>
<tr class="memdesc:a8a387503ead4b6f741b8702de8d9d00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like scalarMultiply function but modifying given vector.  <a href="#a8a387503ead4b6f741b8702de8d9d00a">More...</a><br /></td></tr>
<tr class="separator:a8a387503ead4b6f741b8702de8d9d00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad382b2f5c677ea796498365ed0ee285"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#aad382b2f5c677ea796498365ed0ee285">scalarDivideInPlace</a> (vector&lt; T &gt; &amp;u, T const scalar)</td></tr>
<tr class="memdesc:aad382b2f5c677ea796498365ed0ee285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like scalarDivide function but modifying given vector.  <a href="#aad382b2f5c677ea796498365ed0ee285">More...</a><br /></td></tr>
<tr class="separator:aad382b2f5c677ea796498365ed0ee285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d22b5a914aa61e12fbb36eef3265971"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a1d22b5a914aa61e12fbb36eef3265971">negate</a> (vector&lt; T &gt; const u)</td></tr>
<tr class="memdesc:a1d22b5a914aa61e12fbb36eef3265971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the opposite of given vector \(u\).  <a href="#a1d22b5a914aa61e12fbb36eef3265971">More...</a><br /></td></tr>
<tr class="separator:a1d22b5a914aa61e12fbb36eef3265971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff521d759bb709ab1ddefa6b9fb6229"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a4ff521d759bb709ab1ddefa6b9fb6229">equals</a> (vector&lt; T &gt; const u, vector&lt; T &gt; const v)</td></tr>
<tr class="memdesc:a4ff521d759bb709ab1ddefa6b9fb6229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if you vectors are equal or not.  <a href="#a4ff521d759bb709ab1ddefa6b9fb6229">More...</a><br /></td></tr>
<tr class="separator:a4ff521d759bb709ab1ddefa6b9fb6229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f58f124cd2b67771c3c8eefba9a1ab"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#ad4f58f124cd2b67771c3c8eefba9a1ab">min</a> (vector&lt; T &gt; const &amp;u)</td></tr>
<tr class="memdesc:ad4f58f124cd2b67771c3c8eefba9a1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the minimum value in given vector.  <a href="#ad4f58f124cd2b67771c3c8eefba9a1ab">More...</a><br /></td></tr>
<tr class="separator:ad4f58f124cd2b67771c3c8eefba9a1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec10b905c19c5b7dae749c60b76f5816"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#aec10b905c19c5b7dae749c60b76f5816">max</a> (vector&lt; T &gt; const &amp;u)</td></tr>
<tr class="memdesc:aec10b905c19c5b7dae749c60b76f5816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the maximum value in given vector.  <a href="#aec10b905c19c5b7dae749c60b76f5816">More...</a><br /></td></tr>
<tr class="separator:aec10b905c19c5b7dae749c60b76f5816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23843bdfb51a87089ca7ab8266d106da"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a23843bdfb51a87089ca7ab8266d106da">argmin</a> (vector&lt; T &gt; const &amp;u)</td></tr>
<tr class="memdesc:a23843bdfb51a87089ca7ab8266d106da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the index of minimum value in given vector.  <a href="#a23843bdfb51a87089ca7ab8266d106da">More...</a><br /></td></tr>
<tr class="separator:a23843bdfb51a87089ca7ab8266d106da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909c0e5a73034d3a83692d8e8eb621e2"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a909c0e5a73034d3a83692d8e8eb621e2">argmax</a> (vector&lt; T &gt; const &amp;u)</td></tr>
<tr class="memdesc:a909c0e5a73034d3a83692d8e8eb621e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the index of maximum value in given vector.  <a href="#a909c0e5a73034d3a83692d8e8eb621e2">More...</a><br /></td></tr>
<tr class="separator:a909c0e5a73034d3a83692d8e8eb621e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d97c5a9afabf8414803aedf204925d"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a75d97c5a9afabf8414803aedf204925d">midrange</a> (vector&lt; T &gt; const &amp;u)</td></tr>
<tr class="memdesc:a75d97c5a9afabf8414803aedf204925d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the midrange \(\lambda\) for given vector.  <a href="#a75d97c5a9afabf8414803aedf204925d">More...</a><br /></td></tr>
<tr class="separator:a75d97c5a9afabf8414803aedf204925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63773ea79554f9f1052a89b1278cafd3"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a63773ea79554f9f1052a89b1278cafd3">dotProduct</a> (vector&lt; T &gt; const u, vector&lt; T &gt; const v)</td></tr>
<tr class="memdesc:a63773ea79554f9f1052a89b1278cafd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between vectors \(\overline{u}\) and \(\overline{v}\).  <a href="#a63773ea79554f9f1052a89b1278cafd3">More...</a><br /></td></tr>
<tr class="separator:a63773ea79554f9f1052a89b1278cafd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d8d8fcc9665d2d77cfda58aeaf82e0"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a96d8d8fcc9665d2d77cfda58aeaf82e0">crossProduct3D</a> (vector&lt; T &gt; const u, vector&lt; T &gt; const v)</td></tr>
<tr class="memdesc:a96d8d8fcc9665d2d77cfda58aeaf82e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D cross product between vectors \(\overline{u}\) and \(\overline{v}\).  <a href="#a96d8d8fcc9665d2d77cfda58aeaf82e0">More...</a><br /></td></tr>
<tr class="separator:a96d8d8fcc9665d2d77cfda58aeaf82e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f76df9998822c0358b3be9636c242e"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#aa5f76df9998822c0358b3be9636c242e">hadamardProduct</a> (vector&lt; T &gt; const u, vector&lt; T &gt; const v)</td></tr>
<tr class="memdesc:aa5f76df9998822c0358b3be9636c242e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hadamard product between vectors \(\overline{u}\) and \(\overline{v}\).  <a href="#aa5f76df9998822c0358b3be9636c242e">More...</a><br /></td></tr>
<tr class="separator:aa5f76df9998822c0358b3be9636c242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e98c26c1bd1f408c8f7ce57411f0d64"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a5e98c26c1bd1f408c8f7ce57411f0d64">squareNorm</a> (vector&lt; T &gt; const u)</td></tr>
<tr class="memdesc:a5e98c26c1bd1f408c8f7ce57411f0d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square norm (magnitude) of vector \(\overline{u}\).  <a href="#a5e98c26c1bd1f408c8f7ce57411f0d64">More...</a><br /></td></tr>
<tr class="separator:a5e98c26c1bd1f408c8f7ce57411f0d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f0aec07727569e9e6b4f1ec4d7fecf"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a12f0aec07727569e9e6b4f1ec4d7fecf">squareMagnitude</a> (vector&lt; T &gt; const u)</td></tr>
<tr class="separator:a12f0aec07727569e9e6b4f1ec4d7fecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649912b2b1522ec9683b1d3f2ed76ca6"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a649912b2b1522ec9683b1d3f2ed76ca6">norm</a> (vector&lt; T &gt; const u)</td></tr>
<tr class="memdesc:a649912b2b1522ec9683b1d3f2ed76ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the norm (magnitude) of vector \(\overline{u}\), which is the square root of its square norm.  <a href="#a649912b2b1522ec9683b1d3f2ed76ca6">More...</a><br /></td></tr>
<tr class="separator:a649912b2b1522ec9683b1d3f2ed76ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385cc0538672406bd3a2d238f94e13f0"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a385cc0538672406bd3a2d238f94e13f0">magnitude</a> (vector&lt; T &gt; const u)</td></tr>
<tr class="separator:a385cc0538672406bd3a2d238f94e13f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3c0b98ac7fb8524bc3d33eefdb0fc5"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a2c3c0b98ac7fb8524bc3d33eefdb0fc5">normalize</a> (vector&lt; T &gt; const u)</td></tr>
<tr class="memdesc:a2c3c0b98ac7fb8524bc3d33eefdb0fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize given vector \(\overline{u}\), obtaining \(\hat{u}\).  <a href="#a2c3c0b98ac7fb8524bc3d33eefdb0fc5">More...</a><br /></td></tr>
<tr class="separator:a2c3c0b98ac7fb8524bc3d33eefdb0fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4f5fe73d6d1bad77d37a18f42874e7"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a1e4f5fe73d6d1bad77d37a18f42874e7">normalize</a> (vector&lt; T &gt; const u, T const <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a649912b2b1522ec9683b1d3f2ed76ca6">norm</a>)</td></tr>
<tr class="memdesc:a1e4f5fe73d6d1bad77d37a18f42874e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a2c3c0b98ac7fb8524bc3d33eefdb0fc5" title="Normalize given vector , obtaining . ">Vector::normalize(vector&lt;T&gt; const)</a> but providing a precomputed norm so it is not necessary to compute it. Hence, it is faster as it performs less operations.  <a href="#a1e4f5fe73d6d1bad77d37a18f42874e7">More...</a><br /></td></tr>
<tr class="separator:a1e4f5fe73d6d1bad77d37a18f42874e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e46b0aa3d6f8d55545ce1c85b02d39"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#ae4e46b0aa3d6f8d55545ce1c85b02d39">normalizeInPlace</a> (vector&lt; T &gt; &amp;u)</td></tr>
<tr class="memdesc:ae4e46b0aa3d6f8d55545ce1c85b02d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a2c3c0b98ac7fb8524bc3d33eefdb0fc5" title="Normalize given vector , obtaining . ">Vector::normalize(vector&lt;T&gt; const)</a> but modifying given vector instead of creating new one.  <a href="#ae4e46b0aa3d6f8d55545ce1c85b02d39">More...</a><br /></td></tr>
<tr class="separator:ae4e46b0aa3d6f8d55545ce1c85b02d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381f058db6fc21541d368984bcc5dee2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a381f058db6fc21541d368984bcc5dee2">normalizeInPlace</a> (vector&lt; T &gt; &amp;u, T const <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a649912b2b1522ec9683b1d3f2ed76ca6">norm</a>)</td></tr>
<tr class="memdesc:a381f058db6fc21541d368984bcc5dee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a1e4f5fe73d6d1bad77d37a18f42874e7" title="Like Vector::normalize(vector&lt;T&gt; const) but providing a precomputed norm so it is not necessary to co...">Vector::normalize(vector&lt;T&gt; const, T const)</a> but modifying given vector instead of creating new one.  <a href="#a381f058db6fc21541d368984bcc5dee2">More...</a><br /></td></tr>
<tr class="separator:a381f058db6fc21541d368984bcc5dee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dcec6c7e5d184eefc89287e8999919"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#ad1dcec6c7e5d184eefc89287e8999919">angle</a> (vector&lt; T &gt; const u, vector&lt; T &gt; const v, bool alreadyNormalized=false)</td></tr>
<tr class="memdesc:ad1dcec6c7e5d184eefc89287e8999919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the angle between two given vectors \(overline{u}\) and \(\overline{v}\).  <a href="#ad1dcec6c7e5d184eefc89287e8999919">More...</a><br /></td></tr>
<tr class="separator:ad1dcec6c7e5d184eefc89287e8999919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb1e555b5ada08fb1f8a223c2f67b57"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a7cb1e555b5ada08fb1f8a223c2f67b57">acuteAngle</a> (vector&lt; T &gt; const u, vector&lt; T &gt; const v, bool alreadyNormalized=false)</td></tr>
<tr class="memdesc:a7cb1e555b5ada08fb1f8a223c2f67b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(\theta \leq \frac{\pi}{2}\) angle between two given vectors \(\vec{u}\) and \(\vec{v}\).  <a href="#a7cb1e555b5ada08fb1f8a223c2f67b57">More...</a><br /></td></tr>
<tr class="separator:a7cb1e555b5ada08fb1f8a223c2f67b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab691483a44635f42edebe998726ec882"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#ab691483a44635f42edebe998726ec882">toAngle2D</a> (vector&lt; T &gt; const u)</td></tr>
<tr class="memdesc:ab691483a44635f42edebe998726ec882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2D angle coming from two first components of vector \(\overline{u}\).  <a href="#ab691483a44635f42edebe998726ec882">More...</a><br /></td></tr>
<tr class="separator:ab691483a44635f42edebe998726ec882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec3c2113c5b9487f63b45dde328980c"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a9ec3c2113c5b9487f63b45dde328980c">findOrthogonal</a> (vector&lt; T &gt; const v)</td></tr>
<tr class="memdesc:a9ec3c2113c5b9487f63b45dde328980c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a orthogonal vector with respect to \(v\).  <a href="#a9ec3c2113c5b9487f63b45dde328980c">More...</a><br /></td></tr>
<tr class="separator:a9ec3c2113c5b9487f63b45dde328980c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52430bc6759a745082b6162b3b2532b"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#ae52430bc6759a745082b6162b3b2532b">findOrthonormal</a> (vector&lt; T &gt; const v)</td></tr>
<tr class="memdesc:ae52430bc6759a745082b6162b3b2532b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a9ec3c2113c5b9487f63b45dde328980c" title="Find a orthogonal vector with respect to . ">findOrthogonal(vector&lt;T&gt; const)</a> but returning a normalized orthogonal vector.  <a href="#ae52430bc6759a745082b6162b3b2532b">More...</a><br /></td></tr>
<tr class="separator:ae52430bc6759a745082b6162b3b2532b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e412bb0e1d09640d543dfc0ba15301"><td class="memItemLeft" align="right" valign="top">static vector&lt; vector&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a93e412bb0e1d09640d543dfc0ba15301">findOrthonormals</a> (vector&lt; vector&lt; T &gt;&gt; const V)</td></tr>
<tr class="memdesc:a93e412bb0e1d09640d543dfc0ba15301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#ae52430bc6759a745082b6162b3b2532b" title="Like findOrthogonal(vector&lt;T&gt; const) but returning a normalized orthogonal vector. ">findOrthonormal(vector&lt;T&gt; const)</a> but applied to a vector of vectors instead of a single vector.  <a href="#a93e412bb0e1d09640d543dfc0ba15301">More...</a><br /></td></tr>
<tr class="separator:a93e412bb0e1d09640d543dfc0ba15301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac892c1ea1969cd0e362f0a5f9e9c53"><td class="memItemLeft" align="right" valign="top">static vector&lt; vector&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a4ac892c1ea1969cd0e362f0a5f9e9c53">xyRotations</a> (size_t const depth, bool complement)</td></tr>
<tr class="memdesc:a4ac892c1ea1969cd0e362f0a5f9e9c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute normal vectors representing different rotations on 2D.  <a href="#a4ac892c1ea1969cd0e362f0a5f9e9c53">More...</a><br /></td></tr>
<tr class="separator:a4ac892c1ea1969cd0e362f0a5f9e9c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66077cfacab611685f406bc57fb4499"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#aa66077cfacab611685f406bc57fb4499">isNull</a> (vector&lt; T &gt; const &amp;v)</td></tr>
<tr class="memdesc:aa66077cfacab611685f406bc57fb4499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if \(\vec{v}\) is a null vector (all zero) or not.  <a href="#aa66077cfacab611685f406bc57fb4499">More...</a><br /></td></tr>
<tr class="separator:aa66077cfacab611685f406bc57fb4499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dd05aa3bcb1435806e346916726720"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#ae4dd05aa3bcb1435806e346916726720">project</a> (vector&lt; T &gt; const v, vector&lt; T &gt; const u)</td></tr>
<tr class="memdesc:ae4dd05aa3bcb1435806e346916726720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project vector \(v\) over vector \(u\).  <a href="#ae4dd05aa3bcb1435806e346916726720">More...</a><br /></td></tr>
<tr class="separator:ae4dd05aa3bcb1435806e346916726720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112847d4af5d8d9e6b18ed64b3dbe1c6"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a112847d4af5d8d9e6b18ed64b3dbe1c6">project</a> (vector&lt; T &gt; const v, vector&lt; vector&lt; T &gt;&gt; const u)</td></tr>
<tr class="memdesc:a112847d4af5d8d9e6b18ed64b3dbe1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project vector \(v\) over subspace \(u\).  <a href="#a112847d4af5d8d9e6b18ed64b3dbe1c6">More...</a><br /></td></tr>
<tr class="separator:a112847d4af5d8d9e6b18ed64b3dbe1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d39bc7833b08d4fdaa89313e36ca744"><td class="memItemLeft" align="right" valign="top">static vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a4d39bc7833b08d4fdaa89313e36ca744">diff</a> (vector&lt; T &gt; const u)</td></tr>
<tr class="memdesc:a4d39bc7833b08d4fdaa89313e36ca744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(v\) as the discrete differences of vector \(u\).  <a href="#a4d39bc7833b08d4fdaa89313e36ca744">More...</a><br /></td></tr>
<tr class="separator:a4d39bc7833b08d4fdaa89313e36ca744"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class SurfaceInspector::maths::Vector&lt; T &gt;</h3>

<p>Class providing vector operations. </p>
<dl class="section author"><dt>Author</dt><dd>Alberto M. Esmoris Pena </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of element used by the vector </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7cb1e555b5ada08fb1f8a223c2f67b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb1e555b5ada08fb1f8a223c2f67b57">&#9670;&nbsp;</a></span>acuteAngle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::acuteAngle </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alreadyNormalized</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(\theta \leq \frac{\pi}{2}\) angle between two given vectors \(\vec{u}\) and \(\vec{v}\). </p>
<p class="formulaDsp">
\[ {\theta}&#39; = \arccos{\left( \frac{\langle{\overline{u},\overline{v}}\rangle} {||\overline{u}||\cdot||\overline{v}||} \right)} \]
</p>
<p>When \({\theta}&#39; \leq \frac{\pi}{2}\) then \(\theta = {\theta}&#39;\), otherwise \(\theta = \pi - {\theta}&#39;\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First vector </td></tr>
    <tr><td class="paramname">v</td><td>Second vector </td></tr>
    <tr><td class="paramname">alreadyNormalized</td><td>True when vectors are already normalized so normalization is not necessary and computation will be faster, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\theta \leq \frac{\pi}{2}\) angle between vectors \(\overline{u}\) and \(\overline{v}\) </dd></dl>

</div>
</div>
<a id="a7e4a38ae9dbc489ef5cd8f6e18de44c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4a38ae9dbc489ef5cd8f6e18de44c1">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two vectors. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> from addition </dd></dl>

</div>
</div>
<a id="ad1dcec6c7e5d184eefc89287e8999919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dcec6c7e5d184eefc89287e8999919">&#9670;&nbsp;</a></span>angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::angle </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alreadyNormalized</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the angle between two given vectors \(overline{u}\) and \(\overline{v}\). </p>
<p class="formulaDsp">
\[ \theta = \arccos{\left( \frac{\overline{u}\cdot\overline{v}} {||\overline{u}||\cdot||\overline{v}||} \right)} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First vector </td></tr>
    <tr><td class="paramname">v</td><td>Second vector </td></tr>
    <tr><td class="paramname">alreadyNormalized</td><td>True when vectors are already normalized so normalization is not necessary and computation will be faster, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle between vectors \(\overline{u}\) and \(\overline{v}\) </dd></dl>

</div>
</div>
<a id="a909c0e5a73034d3a83692d8e8eb621e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909c0e5a73034d3a83692d8e8eb621e2">&#9670;&nbsp;</a></span>argmax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::argmax </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the index of maximum value in given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> which maximum value index must be obtained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum value index from given vector </dd></dl>

</div>
</div>
<a id="a23843bdfb51a87089ca7ab8266d106da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23843bdfb51a87089ca7ab8266d106da">&#9670;&nbsp;</a></span>argmin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::argmin </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the index of minimum value in given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> which minimum value index must be obtained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum value index from given vector </dd></dl>

</div>
</div>
<a id="a96d8d8fcc9665d2d77cfda58aeaf82e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d8d8fcc9665d2d77cfda58aeaf82e0">&#9670;&nbsp;</a></span>crossProduct3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::crossProduct3D </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 3D cross product between vectors \(\overline{u}\) and \(\overline{v}\). </p>
<p class="formulaDsp">
\[ \overline{w} = \overline{u} \times \overline{v} = ( u_{y}v_{z} - u_{z}v_{y}, u_{z}v_{x} - u_{x}v_{z}, u_{x}v_{y} - u_{y}v_{x} ) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First vector </td></tr>
    <tr><td class="paramname">v</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cross product between \(\overline{u}\) and \(\overline{v}\) </dd></dl>

</div>
</div>
<a id="a4d39bc7833b08d4fdaa89313e36ca744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d39bc7833b08d4fdaa89313e36ca744">&#9670;&nbsp;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::diff </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(v\) as the discrete differences of vector \(u\). </p>
<p>The cardinality of \(v\) will be \(|v| = |u| - 1\).</p>
<p>Also, \(v_i = u_{i+1} - u_{i}\), so: </p><p class="formulaDsp">
\[ v = \left(u_{2}-u_{1}, \ldots, u_{n}-u_{n-1}\right) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> to differentiate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(v\) vector as the discrete differences of vector \(u\) </dd></dl>

</div>
</div>
<a id="a63773ea79554f9f1052a89b1278cafd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63773ea79554f9f1052a89b1278cafd3">&#9670;&nbsp;</a></span>dotProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::dotProduct </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product between vectors \(\overline{u}\) and \(\overline{v}\). </p>
<p class="formulaDsp">
\[ \overline{u} \cdot \overline{v} = \sum_{i=1}^{n}{u_{i} v_{i}} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First vector </td></tr>
    <tr><td class="paramname">v</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product between \(\overline{u}\) and \(\overline{v}\) </dd></dl>

</div>
</div>
<a id="a4ff521d759bb709ab1ddefa6b9fb6229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff521d759bb709ab1ddefa6b9fb6229">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if you vectors are equal or not. </p>
<p>Two vectors \(u\) and \(v\) are considered to be equal when \(\forall i,\, u_{i}=v_{i}\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First vector to compare with </td></tr>
    <tr><td class="paramname">v</td><td>Second vector to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vectors are exactly equal, false otherwise </dd></dl>

</div>
</div>
<a id="a9ec3c2113c5b9487f63b45dde328980c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec3c2113c5b9487f63b45dde328980c">&#9670;&nbsp;</a></span>findOrthogonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::findOrthogonal </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a orthogonal vector with respect to \(v\). </p>
<p>Let u be the orthogonal vector which can be defined as follows: </p><p class="formulaDsp">
\[ u_{i} = \frac{1}{n_{i}}\sum_{i{\neq}j}{u_{j}v_{j}} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> which orthogonal must be found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> orthogonal to \(v\) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#ae52430bc6759a745082b6162b3b2532b" title="Like findOrthogonal(vector&lt;T&gt; const) but returning a normalized orthogonal vector. ">Vector::findOrthonormal(vector&lt;T&gt; const)</a> </dd></dl>

</div>
</div>
<a id="ae52430bc6759a745082b6162b3b2532b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52430bc6759a745082b6162b3b2532b">&#9670;&nbsp;</a></span>findOrthonormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::findOrthonormal </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a9ec3c2113c5b9487f63b45dde328980c" title="Find a orthogonal vector with respect to . ">findOrthogonal(vector&lt;T&gt; const)</a> but returning a normalized orthogonal vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Orthonormal vector with respect to v </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a9ec3c2113c5b9487f63b45dde328980c" title="Find a orthogonal vector with respect to . ">Vector::findOrthogonal(vector&lt;T&gt; const)</a> </dd>
<dd>
<a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a2c3c0b98ac7fb8524bc3d33eefdb0fc5" title="Normalize given vector , obtaining . ">Vector::normalize</a> </dd></dl>

</div>
</div>
<a id="a93e412bb0e1d09640d543dfc0ba15301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e412bb0e1d09640d543dfc0ba15301">&#9670;&nbsp;</a></span>findOrthonormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;vector&lt;T&gt; &gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::findOrthonormals </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; T &gt;&gt; const&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#ae52430bc6759a745082b6162b3b2532b" title="Like findOrthogonal(vector&lt;T&gt; const) but returning a normalized orthogonal vector. ">findOrthonormal(vector&lt;T&gt; const)</a> but applied to a vector of vectors instead of a single vector. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#ae52430bc6759a745082b6162b3b2532b" title="Like findOrthogonal(vector&lt;T&gt; const) but returning a normalized orthogonal vector. ">Vector::findOrthonormal(vector&lt;T&gt; const)</a> </dd></dl>

</div>
</div>
<a id="aa5f76df9998822c0358b3be9636c242e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f76df9998822c0358b3be9636c242e">&#9670;&nbsp;</a></span>hadamardProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::hadamardProduct </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hadamard product between vectors \(\overline{u}\) and \(\overline{v}\). </p>
<p class="formulaDsp">
\[ \overline{w} = \overline{u} \odot \overline{v} = (u_{1}v_{1}, \ldots , u_{n}v_{n}) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First vector </td></tr>
    <tr><td class="paramname">v</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hadamard product between \(\overline{u}\) and \(\overline{v}\) </dd></dl>

</div>
</div>
<a id="aa66077cfacab611685f406bc57fb4499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66077cfacab611685f406bc57fb4499">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::isNull </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if \(\vec{v}\) is a null vector (all zero) or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Check to be checked for nullity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if \(\vec{v}\) is a null vector, false otherwise. </dd></dl>

</div>
</div>
<a id="a385cc0538672406bd3a2d238f94e13f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385cc0538672406bd3a2d238f94e13f0">&#9670;&nbsp;</a></span>magnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::magnitude </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a649912b2b1522ec9683b1d3f2ed76ca6" title="Compute the norm (magnitude) of vector , which is the square root of its square norm. ">Vector::norm</a> </dd></dl>

</div>
</div>
<a id="aec10b905c19c5b7dae749c60b76f5816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec10b905c19c5b7dae749c60b76f5816">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::max </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the maximum value in given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> which maximum value must be obtained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum value from given vector </dd></dl>

</div>
</div>
<a id="a75d97c5a9afabf8414803aedf204925d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d97c5a9afabf8414803aedf204925d">&#9670;&nbsp;</a></span>midrange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::midrange </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the midrange \(\lambda\) for given vector. </p>
<p class="formulaDsp">
\[ \lambda = \frac{u_{max}+u_{min}}{2} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> which midrange must be obtained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Midrange for given vector </dd></dl>

</div>
</div>
<a id="ad4f58f124cd2b67771c3c8eefba9a1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f58f124cd2b67771c3c8eefba9a1ab">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::min </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the minimum value in given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> which minimum value must be obtained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum value from given vector </dd></dl>

</div>
</div>
<a id="a1d22b5a914aa61e12fbb36eef3265971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d22b5a914aa61e12fbb36eef3265971">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::negate </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the opposite of given vector \(u\). </p>
<p class="formulaDsp">
\[ u = (u_{1}, ..., u_{n}) \implies -u = (-u_{1}, ..., -u_{n}) \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> to be negated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negated \(u\) </dd></dl>

</div>
</div>
<a id="a649912b2b1522ec9683b1d3f2ed76ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649912b2b1522ec9683b1d3f2ed76ca6">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::norm </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the norm (magnitude) of vector \(\overline{u}\), which is the square root of its square norm. </p>
<p class="formulaDsp">
\[ ||\overline{u}|| = \sqrt{\sum_{i=1}^{n}{u_{i}^{2}}} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> which norm (magnitude) must be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Norm (magnitude) of vector \(\overline{u}\) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a5e98c26c1bd1f408c8f7ce57411f0d64" title="Compute the square norm (magnitude) of vector . ">Vector::squareNorm</a> </dd></dl>

</div>
</div>
<a id="a2c3c0b98ac7fb8524bc3d33eefdb0fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3c0b98ac7fb8524bc3d33eefdb0fc5">&#9670;&nbsp;</a></span>normalize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::normalize </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize given vector \(\overline{u}\), obtaining \(\hat{u}\). </p>
<p class="formulaDsp">
\[ \hat{u} = \left(\frac{u_{i}}{||\overline{u}||} ,\ldots, \frac{u_{i}}{||\overline{u}||}\right) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> to be normalized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalized vector \(\hat{u}\) </dd></dl>

</div>
</div>
<a id="a1e4f5fe73d6d1bad77d37a18f42874e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4f5fe73d6d1bad77d37a18f42874e7">&#9670;&nbsp;</a></span>normalize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::normalize </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a2c3c0b98ac7fb8524bc3d33eefdb0fc5" title="Normalize given vector , obtaining . ">Vector::normalize(vector&lt;T&gt; const)</a> but providing a precomputed norm so it is not necessary to compute it. Hence, it is faster as it performs less operations. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a2c3c0b98ac7fb8524bc3d33eefdb0fc5" title="Normalize given vector , obtaining . ">Vector::normalize(vector&lt;T&gt; const)</a> </dd></dl>

</div>
</div>
<a id="ae4e46b0aa3d6f8d55545ce1c85b02d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e46b0aa3d6f8d55545ce1c85b02d39">&#9670;&nbsp;</a></span>normalizeInPlace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::normalizeInPlace </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a2c3c0b98ac7fb8524bc3d33eefdb0fc5" title="Normalize given vector , obtaining . ">Vector::normalize(vector&lt;T&gt; const)</a> but modifying given vector instead of creating new one. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a2c3c0b98ac7fb8524bc3d33eefdb0fc5" title="Normalize given vector , obtaining . ">Vector::normalize(vector&lt;T&gt; const)</a> </dd></dl>

</div>
</div>
<a id="a381f058db6fc21541d368984bcc5dee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381f058db6fc21541d368984bcc5dee2">&#9670;&nbsp;</a></span>normalizeInPlace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::normalizeInPlace </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a1e4f5fe73d6d1bad77d37a18f42874e7" title="Like Vector::normalize(vector&lt;T&gt; const) but providing a precomputed norm so it is not necessary to co...">Vector::normalize(vector&lt;T&gt; const, T const)</a> but modifying given vector instead of creating new one. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a1e4f5fe73d6d1bad77d37a18f42874e7" title="Like Vector::normalize(vector&lt;T&gt; const) but providing a precomputed norm so it is not necessary to co...">Vector::normalize(vector&lt;T&gt; const, T const)</a> </dd></dl>

</div>
</div>
<a id="ae4dd05aa3bcb1435806e346916726720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4dd05aa3bcb1435806e346916726720">&#9670;&nbsp;</a></span>project() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::project </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project vector \(v\) over vector \(u\). </p>
<p class="formulaDsp">
\[ \mathrm{proj}_{u}{v} = \frac{\langle{u,v}\rangle}{\langle{u,u}\rangle} u \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> to be projected </td></tr>
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> to project over it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection of v over u </dd></dl>

</div>
</div>
<a id="a112847d4af5d8d9e6b18ed64b3dbe1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112847d4af5d8d9e6b18ed64b3dbe1c6">&#9670;&nbsp;</a></span>project() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::project </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; T &gt;&gt; const&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project vector \(v\) over subspace \(u\). </p>
<p>Considering \(u = \langle{b_{1}, \ldots, b_{n}}\rangle\)</p>
<p class="formulaDsp">
\[ \mathrm{proj}_{u}{v} = \frac{\langle{v,b_{1}}\rangle}{\langle{b_{1},b_{1}}\rangle} b_{1} + \ldots + \frac{\langle{v,b_{n}}\rangle}{\langle{b_{n},b_{n}}\rangle} b_{n} = \sum_{i=1}^{n}{\frac{\langle{v,b_{i}}\rangle}{||b_{i}||^{2}}b_{i}} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> to be projected </td></tr>
    <tr><td class="paramname">u</td><td>Basis of the vector subspace to project over it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection of v over u </dd></dl>

</div>
</div>
<a id="a6931a5c5a0e1eafad6c9ed1db1263214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6931a5c5a0e1eafad6c9ed1db1263214">&#9670;&nbsp;</a></span>scalarAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::scalarAdd </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the scalar to all elements in vector \(\overline{u}\). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> resulting from addition </dd></dl>

</div>
</div>
<a id="a0bafc6860b33d8360185046c5033bf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bafc6860b33d8360185046c5033bf6d">&#9670;&nbsp;</a></span>scalarAddInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::scalarAddInPlace </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like scalarAdd function but modifying given vector. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a6931a5c5a0e1eafad6c9ed1db1263214" title="Add the scalar to all elements in vector . ">Vector::scalarAdd</a> </dd></dl>

</div>
</div>
<a id="a7408ebde0335d994236858ba4e831295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7408ebde0335d994236858ba4e831295">&#9670;&nbsp;</a></span>scalarDivide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::scalarDivide </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide all elements in vector \(\overline{u}\) by scalar. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> resulting from division </dd></dl>

</div>
</div>
<a id="aad382b2f5c677ea796498365ed0ee285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad382b2f5c677ea796498365ed0ee285">&#9670;&nbsp;</a></span>scalarDivideInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::scalarDivideInPlace </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like scalarDivide function but modifying given vector. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a7408ebde0335d994236858ba4e831295" title="Divide all elements in vector  by scalar. ">Vector::scalarDivide</a> </dd></dl>

</div>
</div>
<a id="a6c15403da25943f8d0446acd8ea7cb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c15403da25943f8d0446acd8ea7cb22">&#9670;&nbsp;</a></span>scalarMultiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::scalarMultiply </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply all elements in vector \(overline{u}\) by scalar. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> resulting from multiplication </dd></dl>

</div>
</div>
<a id="a8a387503ead4b6f741b8702de8d9d00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a387503ead4b6f741b8702de8d9d00a">&#9670;&nbsp;</a></span>scalarMultiplyInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::scalarMultiplyInPlace </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like scalarMultiply function but modifying given vector. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a6c15403da25943f8d0446acd8ea7cb22" title="Multiply all elements in vector  by scalar. ">Vector::scalarMultiply</a> </dd></dl>

</div>
</div>
<a id="a94d2f909e61956e3a258a713b44484f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d2f909e61956e3a258a713b44484f2">&#9670;&nbsp;</a></span>scalarSubtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::scalarSubtract </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract the scalar to all elements in vector \(\overline{u}\). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> resulting from subtraction </dd></dl>

</div>
</div>
<a id="a043fe59241e476b661623aea20ffbbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043fe59241e476b661623aea20ffbbf0">&#9670;&nbsp;</a></span>scalarSubtractInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::scalarSubtractInPlace </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like scalarSubtract function but modifying given vector. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a94d2f909e61956e3a258a713b44484f2" title="Subtract the scalar to all elements in vector . ">Vector::scalarSubtract</a> </dd></dl>

</div>
</div>
<a id="a12f0aec07727569e9e6b4f1ec4d7fecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f0aec07727569e9e6b4f1ec4d7fecf">&#9670;&nbsp;</a></span>squareMagnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::squareMagnitude </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html#a5e98c26c1bd1f408c8f7ce57411f0d64" title="Compute the square norm (magnitude) of vector . ">Vector::squareNorm</a> </dd></dl>

</div>
</div>
<a id="a5e98c26c1bd1f408c8f7ce57411f0d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e98c26c1bd1f408c8f7ce57411f0d64">&#9670;&nbsp;</a></span>squareNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::squareNorm </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square norm (magnitude) of vector \(\overline{u}\). </p>
<p class="formulaDsp">
\[ ||\overline{u}||^{2} = \sum_{i=1}^{n}{u_{i}^{2}} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> which square norm (magnitude) must be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Square norm (magnitude) of vector \(\overline{u}\) </dd></dl>

</div>
</div>
<a id="a2bb15a50fafae148c4b88b9fcb36668d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb15a50fafae148c4b88b9fcb36668d">&#9670;&nbsp;</a></span>subtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;T&gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::subtract </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two vectors. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> from subtraction </dd></dl>

</div>
</div>
<a id="ab691483a44635f42edebe998726ec882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab691483a44635f42edebe998726ec882">&#9670;&nbsp;</a></span>toAngle2D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::toAngle2D </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 2D angle coming from two first components of vector \(\overline{u}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html" title="Class providing vector operations. ">Vector</a> which 2D angle must be obtained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle of first two components of \(\overline{u}\) in interval \([-\pi, +\pi]\) </dd></dl>

</div>
</div>
<a id="a4ac892c1ea1969cd0e362f0a5f9e9c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac892c1ea1969cd0e362f0a5f9e9c53">&#9670;&nbsp;</a></span>xyRotations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt;vector&lt;T&gt; &gt; <a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">SurfaceInspector::maths::Vector</a>&lt; T &gt;::xyRotations </td>
          <td>(</td>
          <td class="paramtype">size_t const&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>complement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute normal vectors representing different rotations on 2D. </p>
<p>Rotations are computed according to following formula</p>
<p class="formulaDsp">
\[ x&#39; = cos(\theta)x - sin(\theta)y \\ y&#39; = sin(\theta)x + cos(\theta)y \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>The number of rotations computed in the semi-circumference space. </td></tr>
    <tr><td class="paramname">complement</td><td>When it is false, as many vectors as depth will be returned. However, when it is true, as many vectors as depth x 2 will be returned, since the entire circumference will be considered through negation of vectors in the semi-circumference space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either depth rotations on the semi-circumference space (when complement is false) or (2 x depth) rotations on the circumference space (when complement is true) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/surfaceinspector/maths/<a class="el" href="../../de/dd9/Vector_8hpp_source.html">Vector.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>SurfaceInspector</b></li><li class="navelem"><b>maths</b></li><li class="navelem"><a class="el" href="../../d1/dd3/classSurfaceInspector_1_1maths_1_1Vector.html">Vector</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
