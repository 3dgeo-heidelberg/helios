<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios++: SimpleKDTreeFactory Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Helios++
   </div>
   <div id="projectbrief">Helios software for LiDAR simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d6/d96/classSimpleKDTreeFactory.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../de/dc3/classSimpleKDTreeFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimpleKDTreeFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class providing building methods for simple k-dimensional trees.  
 <a href="../../d6/d96/classSimpleKDTreeFactory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../da/da3/SimpleKDTreeFactory_8h_source.html">SimpleKDTreeFactory.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SimpleKDTreeFactory:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/daa/classSimpleKDTreeFactory__inherit__graph.png" border="0" usemap="#SimpleKDTreeFactory_inherit__map" alt="Inheritance graph"/></div>
<map name="SimpleKDTreeFactory_inherit__map" id="SimpleKDTreeFactory_inherit__map">
<area shape="rect" id="node3" href="../../db/d58/classSAHKDTreeFactory.html" title="Class providing building methods for k&#45;dimensional trees with surface area heuristic (SAH) ..." alt="" coords="19,155,157,181"/>
<area shape="rect" id="node2" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k&#45;dimensional trees..." alt="" coords="33,5,143,32"/>
<area shape="rect" id="node4" href="../../df/d30/classAxisSAHKDTreeFactory.html" title="Class providing building methods for k&#45;dimensional trees with surface area heuristic and greedy selec..." alt="" coords="5,229,171,256"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SimpleKDTreeFactory:</div>
<div class="dyncontent">
<div class="center"><img src="../../db/daf/classSimpleKDTreeFactory__coll__graph.png" border="0" usemap="#SimpleKDTreeFactory_coll__map" alt="Collaboration graph"/></div>
<map name="SimpleKDTreeFactory_coll__map" id="SimpleKDTreeFactory_coll__map">
<area shape="rect" id="node2" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k&#45;dimensional trees..." alt="" coords="25,5,136,32"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abd0ddd1777cecd176f94a14da1537bd9"><td class="memItemLeft" align="right" valign="top"><a id="abd0ddd1777cecd176f94a14da1537bd9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abd0ddd1777cecd176f94a14da1537bd9">SimpleKDTreeFactory</a> ()=default</td></tr>
<tr class="memdesc:abd0ddd1777cecd176f94a14da1537bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k-dimensional trees. ">SimpleKDTreeFactory</a> default constructor. <br /></td></tr>
<tr class="separator:abd0ddd1777cecd176f94a14da1537bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15ff698fd31b9b6476778c76ddcad31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#af15ff698fd31b9b6476778c76ddcad31">makeFromPrimitives</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) override</td></tr>
<tr class="memdesc:af15ff698fd31b9b6476778c76ddcad31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a simple KDTree from given primitives.  <a href="#af15ff698fd31b9b6476778c76ddcad31">More...</a><br /></td></tr>
<tr class="separator:af15ff698fd31b9b6476778c76ddcad31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:abd874b2cfb07c46a974ebc6e9cacff3b inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a id="abd874b2cfb07c46a974ebc6e9cacff3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#abd874b2cfb07c46a974ebc6e9cacff3b">KDTreeFactory</a> ()=default</td></tr>
<tr class="memdesc:abd874b2cfb07c46a974ebc6e9cacff3b inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">K dimensional tree factory default constructor. <br /></td></tr>
<tr class="separator:abd874b2cfb07c46a974ebc6e9cacff3b inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2ffeb366f3239f47ae0f8aad14e69a0a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a2ffeb366f3239f47ae0f8aad14e69a0a">buildRecursive</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; primitives, int const depth)</td></tr>
<tr class="memdesc:a2ffeb366f3239f47ae0f8aad14e69a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively build a KDTree for given primitives.  <a href="#a2ffeb366f3239f47ae0f8aad14e69a0a">More...</a><br /></td></tr>
<tr class="separator:a2ffeb366f3239f47ae0f8aad14e69a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259a3500ce239f33914d5da0c694b427"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a259a3500ce239f33914d5da0c694b427">computeKDTreeStats</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root) const</td></tr>
<tr class="memdesc:a259a3500ce239f33914d5da0c694b427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze KDTree computing its max depth and the minimum and maximum number of primitives considering all nodes.  <a href="#a259a3500ce239f33914d5da0c694b427">More...</a><br /></td></tr>
<tr class="separator:a259a3500ce239f33914d5da0c694b427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ed0e048fd2e9ae62fdd324e32153c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aa3ed0e048fd2e9ae62fdd324e32153c5">defineSplit</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, int const depth) const</td></tr>
<tr class="memdesc:aa3ed0e048fd2e9ae62fdd324e32153c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the split axis and position for current node.  <a href="#aa3ed0e048fd2e9ae62fdd324e32153c5">More...</a><br /></td></tr>
<tr class="separator:aa3ed0e048fd2e9ae62fdd324e32153c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a2b1d37c6dfe2b97a502a85e6154c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#ab3a2b1d37c6dfe2b97a502a85e6154c5">populateSplits</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const splitAxis, double const splitPos, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives) const</td></tr>
<tr class="memdesc:ab3a2b1d37c6dfe2b97a502a85e6154c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate list of primitives for left and right splits from given primitives of node being splitted.  <a href="#ab3a2b1d37c6dfe2b97a502a85e6154c5">More...</a><br /></td></tr>
<tr class="separator:ab3a2b1d37c6dfe2b97a502a85e6154c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fe3d0cf72a677b45c29ac670de5f16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a48fe3d0cf72a677b45c29ac670de5f16">buildChildrenNodes</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const depth, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;rightPrimitives)</td></tr>
<tr class="memdesc:a48fe3d0cf72a677b45c29ac670de5f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build children nodes for given node. If no children nodes must be built, then the node is configured as a leaf node.  <a href="#a48fe3d0cf72a677b45c29ac670de5f16">More...</a><br /></td></tr>
<tr class="separator:a48fe3d0cf72a677b45c29ac670de5f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc932ae3ef28f324a656add6c1ac5bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd">computeNodeBoundaries</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:abbc932ae3ef28f324a656add6c1ac5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute min and max position and surface area of bounding cuboid for given node.  <a href="#abbc932ae3ef28f324a656add6c1ac5bd">More...</a><br /></td></tr>
<tr class="separator:abbc932ae3ef28f324a656add6c1ac5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afebd1f880d9171e68537df4e2485e06c"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:afebd1f880d9171e68537df4e2485e06c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#afebd1f880d9171e68537df4e2485e06c">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="memdesc:afebd1f880d9171e68537df4e2485e06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a simple KDTree factory to a stream of bytes.  <a href="#afebd1f880d9171e68537df4e2485e06c">More...</a><br /></td></tr>
<tr class="separator:afebd1f880d9171e68537df4e2485e06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top"><a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::serialization::access</b></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class providing building methods for simple k-dimensional trees. </p>
<dl class="section author"><dt>Author</dt><dd>Alberto M. Esmoris Pena </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a48fe3d0cf72a677b45c29ac670de5f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fe3d0cf72a677b45c29ac670de5f16">&#9670;&nbsp;</a></span>buildChildrenNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::buildChildrenNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build children nodes for given node. If no children nodes must be built, then the node is configured as a leaf node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Node which children will be built if possible and, if not, then will be configured as leaf node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent</td><td>The parent node if any. For root nodes, it will be a nullptr </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">primitives</td><td>Primitives of the node itself </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">depth</td><td>Depth of current node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">leftPrimitives</td><td>Primitives for left child node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rightPrimitives</td><td>Primitives for right child node </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#ae8fea9ed6b51759b86a8bab4a223f9e1">SAHKDTreeFactory</a>.</p>

</div>
</div>
<a id="a2ffeb366f3239f47ae0f8aad14e69a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffeb366f3239f47ae0f8aad14e69a0a">&#9670;&nbsp;</a></span>buildRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> * SimpleKDTreeFactory::buildRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively build a KDTree for given primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent node if any. For root nodes, it must be a nullptr </td></tr>
    <tr><td class="paramname">left</td><td>True if given node is a left child, false otherwise. If the node is a root node, it should be false. If node is not a root node and left is true, it means it is a left child. If node is not a root node and left is false, it means it is a right child </td></tr>
    <tr><td class="paramname">primitives</td><td>Primitives to build KDTree splitting them </td></tr>
    <tr><td class="paramname">depth</td><td>Current depth at build process. Useful for tracking recursion level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Built KDTree node </dd></dl>

</div>
</div>
<a id="a259a3500ce239f33914d5da0c694b427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259a3500ce239f33914d5da0c694b427">&#9670;&nbsp;</a></span>computeKDTreeStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::computeKDTreeStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyze KDTree computing its max depth and the minimum and maximum number of primitives considering all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node to compute stats for given <a class="el" href="../../d0/d64/classKDTreeNodeRoot.html" title="Class representing the root node of a KDTree. ">KDTreeNodeRoot</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15">SAHKDTreeFactory</a>.</p>

</div>
</div>
<a id="abbc932ae3ef28f324a656add6c1ac5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc932ae3ef28f324a656add6c1ac5bd">&#9670;&nbsp;</a></span>computeNodeBoundaries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::computeNodeBoundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute min and max position and surface area of bounding cuboid for given node. </p>
<p>Surface area for a cuboid can be computed considering \(l_i\) is the length of \(i-th\) axis.</p>
<p>For instance, surface area of root node \(R\) in \(\mathbb{R}^2\) can be computed as follows:</p>
<p class="formulaDsp">
\[ S_A(R) = l_x l_y \]
</p>
<p>Analogously, the surface area of root node \(R\) in \(\mathbb{R}^3\) can be computed as follows:</p>
<p class="formulaDsp">
\[ S_A(R) = 2(l_x l_y + l_x l_z + l_y l_z) \]
</p>
<p>The boundaries for the root node are taken from min and max vertex of given set of primitives. Surface area and min and max boundaries for children nodes are just taken proportionally to \(r\) where \(p\) is the split position and \(a\) and \(b\) are the min and max positions respectively:</p>
<p class="formulaDsp">
\[ r = \frac{p-a}{b-a} \]
</p>
<p>For the sake of understanding, surface area for children nodes is explained in detail. For this purpose, notice that \(p \in [a, b]\). Now lets define left and right children surface area respectively, namely \(S_A(L_b)\) and \(S_A(R_b)\) where \(S_A(P)\) is the surface area of the parent node itself:</p>
<p class="formulaDsp">
\[ \left\{\begin{array}{lllll} S_A(L_b) &amp;=&amp; r S_A(P) &amp;=&amp; \frac{p-a}{b-a} S_A(P) \\ S_A(R_b) &amp;=&amp; (1-r) S_A(P) &amp;=&amp; \left(1 - \frac{p-a}{b-a}\right) S_A(P) \end{array}\right. \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Root node which surface area must be computed </td></tr>
    <tr><td class="paramname">parent</td><td>The parent node if any. For root nodes, it will be a nullptr </td></tr>
    <tr><td class="paramname">left</td><td>True if given node is a left child, false otherwise. If the node is a root node, it should be false. If node is not a root node and left is true, it means it is a left child. If node is not a root node and left is false, it means it is a right child </td></tr>
    <tr><td class="paramname">primitives</td><td>Vector of primitives inside given root node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3ed0e048fd2e9ae62fdd324e32153c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ed0e048fd2e9ae62fdd324e32153c5">&#9670;&nbsp;</a></span>defineSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::defineSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define the split axis and position for current node. </p>
<p>The simple KDTree factory defines the split point as the position of the median which splits primitives along split axis into two nodes which tend to have the same number of primitives. To illustrate this, let \(d\) be the depth of the node and \(n\) be the space dimensionality. Therefore, the split axis can be defined as \(a = d \mod n\). If \(P=\left\{p_1, \ldots, p_n\right\}\) is the set of all primitives contained in the node where \(\forall i, p_i=(p_{i1}, \ldots, p_{in})\), the split position \(s\) can be used to define following sets: </p><p class="formulaDsp">
\[ \alpha = \left\{ p_i : p_{ia} \leq s \right\} \\ \beta = \left\{ p_i : p_{ia} &gt; s \right\} \]
</p>
<p>But if \(s\) is the median of primitives distribution along \(a\)-axis, then if there are no equal primitives it will be satisfied that \(0 \leq |\alpha| - |\beta| \leq 1\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Node which split axis and split position are going to be defined </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent</td><td>The parent node if any. For root nodes, it will be a nullptr </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">primitives</td><td>Primitives of node which split must be defined </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">depth</td><td>Depth of node which split must be defined </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d">SAHKDTreeFactory</a>, and <a class="el" href="../../df/d30/classAxisSAHKDTreeFactory.html#a1a938aa8914f624692228217428c157a">AxisSAHKDTreeFactory</a>.</p>

</div>
</div>
<a id="af15ff698fd31b9b6476778c76ddcad31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15ff698fd31b9b6476778c76ddcad31">&#9670;&nbsp;</a></span>makeFromPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> * SimpleKDTreeFactory::makeFromPrimitives </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a simple KDTree from given primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitives</td><td>Primitives to build simple KDTree splitting them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to root node of built simple KDTree </dd></dl>

<p>Implements <a class="el" href="../../d5/dd0/classKDTreeFactory.html#a87d961d1bd980133318421f5de71a4df">KDTreeFactory</a>.</p>

</div>
</div>
<a id="ab3a2b1d37c6dfe2b97a502a85e6154c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a2b1d37c6dfe2b97a502a85e6154c5">&#9670;&nbsp;</a></span>populateSplits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::populateSplits </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>splitAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>splitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate list of primitives for left and right splits from given primitives of node being splitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">primitives</td><td>Primitives of node being splitted </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splitAxis</td><td>Index of axis defining the split </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splitPos</td><td>Position on given axis of the split point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">leftPrimitives</td><td>Where primitives of left split must be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rightPrimitives</td><td>Where primitives of right split must be stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afebd1f880d9171e68537df4e2485e06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebd1f880d9171e68537df4e2485e06c">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a simple KDTree factory to a stream of bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>Type of rendering </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Specific rendering for the stream of bytes </td></tr>
    <tr><td class="paramname">version</td><td>Version number for the simple KDTree factory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/adt/kdtree/<a class="el" href="../../da/da3/SimpleKDTreeFactory_8h_source.html">SimpleKDTreeFactory.h</a></li>
<li>src/adt/kdtree/SimpleKDTreeFactory.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html">SimpleKDTreeFactory</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
