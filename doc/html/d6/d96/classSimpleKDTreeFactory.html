<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios++: SimpleKDTreeFactory Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Helios++
   </div>
   <div id="projectbrief">Helios software for LiDAR simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d6/d96/classSimpleKDTreeFactory.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../de/dc3/classSimpleKDTreeFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimpleKDTreeFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class providing building methods for simple k-dimensional trees.  
 <a href="../../d6/d96/classSimpleKDTreeFactory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../da/da3/SimpleKDTreeFactory_8h_source.html">SimpleKDTreeFactory.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SimpleKDTreeFactory:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/daa/classSimpleKDTreeFactory__inherit__graph.png" border="0" usemap="#SimpleKDTreeFactory_inherit__map" alt="Inheritance graph"/></div>
<map name="SimpleKDTreeFactory_inherit__map" id="SimpleKDTreeFactory_inherit__map">
<area shape="rect" id="node3" href="../../df/d86/classMultiThreadKDTreeFactory.html" title="Decorator for any KDTree factory which provides support for multi thread KDTree building. " alt="" coords="34,155,213,181"/>
<area shape="rect" id="node5" href="../../db/d58/classSAHKDTreeFactory.html" title="Class providing building methods for k&#45;dimensional trees with surface area heuristic (SAH) ..." alt="" coords="250,155,389,181"/>
<area shape="rect" id="node2" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k&#45;dimensional trees..." alt="" coords="159,5,269,32"/>
<area shape="rect" id="node4" href="../../dd/d95/classMultiThreadSAHKDTreeFactory.html" title="Decorator for any SAH KDTree which provides support for multi thread KDTree building. " alt="" coords="5,229,212,256"/>
<area shape="rect" id="node6" href="../../df/d30/classAxisSAHKDTreeFactory.html" title="Class providing building methods for k&#45;dimensional trees with surface area heuristic and greedy selec..." alt="" coords="237,229,402,256"/>
<area shape="rect" id="node7" href="../../d0/d0e/classFastSAHKDTreeFactory.html" title="Class providing building methods for k&#45;dimensional trees with a fast strategy to approximate Surface ..." alt="" coords="426,229,591,256"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SimpleKDTreeFactory:</div>
<div class="dyncontent">
<div class="center"><img src="../../db/daf/classSimpleKDTreeFactory__coll__graph.png" border="0" usemap="#SimpleKDTreeFactory_coll__map" alt="Collaboration graph"/></div>
<map name="SimpleKDTreeFactory_coll__map" id="SimpleKDTreeFactory_coll__map">
<area shape="rect" id="node2" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k&#45;dimensional trees..." alt="" coords="189,353,300,380"/>
<area shape="rect" id="node3" href="../../dd/d04/classLightKDTreeNodeBlockAllocator.html" title="Block allocator for LightKDTreeNode instances. " alt="" coords="139,264,350,291"/>
<area shape="rect" id="node4" href="../../d9/d47/classBlockAllocator.html" title="BlockAllocator\&lt; LightKDTree\lNode \&gt;" alt="" coords="149,173,340,215"/>
<area shape="rect" id="node5" href="../../dd/d79/classLightKDTreeNode.html" title="Class representing a light KDTree node. It is, the basic representation of a KDTree node with uses le..." alt="" coords="5,83,132,109"/>
<area shape="rect" id="node6" href="../../d7/d98/classIBinaryTreeNode.html" title="Binary tree node interface that must be implemented by any class providing binary tree node based fun..." alt="" coords="9,5,129,32"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac0b2d556d61c2e301de1eb2f9bda823"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aac0b2d556d61c2e301de1eb2f9bda823">SimpleKDTreeFactory</a> ()</td></tr>
<tr class="memdesc:aac0b2d556d61c2e301de1eb2f9bda823"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k-dimensional trees. ">SimpleKDTreeFactory</a> default constructor.  <a href="#aac0b2d556d61c2e301de1eb2f9bda823">More...</a><br /></td></tr>
<tr class="separator:aac0b2d556d61c2e301de1eb2f9bda823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3252f0348c7fd5d40b84e52dd9144fad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a3252f0348c7fd5d40b84e52dd9144fad">makeFromPrimitivesUnsafe</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives) override</td></tr>
<tr class="memdesc:a3252f0348c7fd5d40b84e52dd9144fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a simple KDTree from given primitives.  <a href="#a3252f0348c7fd5d40b84e52dd9144fad">More...</a><br /></td></tr>
<tr class="separator:a3252f0348c7fd5d40b84e52dd9144fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:ad905f937a8e13e78f18e659d0732a7a5 inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a id="ad905f937a8e13e78f18e659d0732a7a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#ad905f937a8e13e78f18e659d0732a7a5">KDTreeFactory</a> ()</td></tr>
<tr class="memdesc:ad905f937a8e13e78f18e659d0732a7a5 inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">K dimensional tree factory default constructor. <br /></td></tr>
<tr class="separator:ad905f937a8e13e78f18e659d0732a7a5 inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c0c7761a500d0d0871369ac5f6c4f9 inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a90c0c7761a500d0d0871369ac5f6c4f9">makeFromPrimitives</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives)</td></tr>
<tr class="memdesc:a90c0c7761a500d0d0871369ac5f6c4f9 inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe wrapper from makeFromPrimitivesUnsafe which handles a copy to make from primitives by default. This function behavior might be overridden by any derived/child class. It is expected that any implementation of makeFromPrimitives provides a way to implement the makeFromPrimitivesUnsafe method without modifying vector of input primitives. Notice this does not mean primitives themselves cannot be modified, that depends on the type of <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a>. It only means that the vector itself will not be modified, for instance due to sorting purposes.  <a href="../../d5/dd0/classKDTreeFactory.html#a90c0c7761a500d0d0871369ac5f6c4f9">More...</a><br /></td></tr>
<tr class="separator:a90c0c7761a500d0d0871369ac5f6c4f9 inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dd08e1de4ceeee1e028df1eb9acc8e inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a07dd08e1de4ceeee1e028df1eb9acc8e">isBuildingLightNodes</a> ()</td></tr>
<tr class="memdesc:a07dd08e1de4ceeee1e028df1eb9acc8e inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> is building light nodes.  <a href="../../d5/dd0/classKDTreeFactory.html#a07dd08e1de4ceeee1e028df1eb9acc8e">More...</a><br /></td></tr>
<tr class="separator:a07dd08e1de4ceeee1e028df1eb9acc8e inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998f586e172af6066c63d3d3a251860e inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a998f586e172af6066c63d3d3a251860e">setBuildingLightNodes</a> (bool const <a class="el" href="../../d5/dd0/classKDTreeFactory.html#aa6ede7a422802db8e6cbf537861d5f56">buildLightNodes</a>)</td></tr>
<tr class="memdesc:a998f586e172af6066c63d3d3a251860e inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> so it build light nodes (true) or not (false)  <a href="../../d5/dd0/classKDTreeFactory.html#a998f586e172af6066c63d3d3a251860e">More...</a><br /></td></tr>
<tr class="separator:a998f586e172af6066c63d3d3a251860e inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794e82f978b631abf55b85f6ac72ea01 inherit pub_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a794e82f978b631abf55b85f6ac72ea01">setChild</a> (<a class="el" href="../../dd/d79/classLightKDTreeNode.html">LightKDTreeNode</a> *&amp;child, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node)</td></tr>
<tr class="memdesc:a794e82f978b631abf55b85f6ac72ea01 inherit pub_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set child to given node if and only if node is not null. It must be used to assign children nodes in a thread-safe way.  <a href="../../d5/dd0/classKDTreeFactory.html#a794e82f978b631abf55b85f6ac72ea01">More...</a><br /></td></tr>
<tr class="separator:a794e82f978b631abf55b85f6ac72ea01 inherit pub_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a07231a87a91c5168efcb91308c60adf8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a07231a87a91c5168efcb91308c60adf8">buildRecursive</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, int const depth)</td></tr>
<tr class="memdesc:a07231a87a91c5168efcb91308c60adf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively build a KDTree for given primitives.  <a href="#a07231a87a91c5168efcb91308c60adf8">More...</a><br /></td></tr>
<tr class="separator:a07231a87a91c5168efcb91308c60adf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259a3500ce239f33914d5da0c694b427"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a259a3500ce239f33914d5da0c694b427">computeKDTreeStats</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root) const</td></tr>
<tr class="memdesc:a259a3500ce239f33914d5da0c694b427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze KDTree computing its max depth and the minimum and maximum number of primitives considering all nodes.  <a href="#a259a3500ce239f33914d5da0c694b427">More...</a><br /></td></tr>
<tr class="separator:a259a3500ce239f33914d5da0c694b427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5466631a7dc4fd2102c338645ff2af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a0f5466631a7dc4fd2102c338645ff2af">reportKDTreeStats</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:a0f5466631a7dc4fd2102c338645ff2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report KDTree stats of given root node at INFO logging level.  <a href="#a0f5466631a7dc4fd2102c338645ff2af">More...</a><br /></td></tr>
<tr class="separator:a0f5466631a7dc4fd2102c338645ff2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ed0e048fd2e9ae62fdd324e32153c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#aa3ed0e048fd2e9ae62fdd324e32153c5">defineSplit</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;primitives, int const depth) const</td></tr>
<tr class="memdesc:aa3ed0e048fd2e9ae62fdd324e32153c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the split axis and position for current node.  <a href="#aa3ed0e048fd2e9ae62fdd324e32153c5">More...</a><br /></td></tr>
<tr class="separator:aa3ed0e048fd2e9ae62fdd324e32153c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a2b1d37c6dfe2b97a502a85e6154c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#ab3a2b1d37c6dfe2b97a502a85e6154c5">populateSplits</a> (vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const splitAxis, double const splitPos, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives) const</td></tr>
<tr class="memdesc:ab3a2b1d37c6dfe2b97a502a85e6154c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate list of primitives for left and right splits from given primitives of node being splitted.  <a href="#ab3a2b1d37c6dfe2b97a502a85e6154c5">More...</a><br /></td></tr>
<tr class="separator:ab3a2b1d37c6dfe2b97a502a85e6154c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f57b35097966c0884d0373a71b382d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#ab1f57b35097966c0884d0373a71b382d">buildChildrenNodes</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives, int const depth, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;leftPrimitives, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;rightPrimitives)</td></tr>
<tr class="memdesc:ab1f57b35097966c0884d0373a71b382d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build children nodes for given node. If no children nodes must be built, then the node is configured as a leaf node.  <a href="#ab1f57b35097966c0884d0373a71b382d">More...</a><br /></td></tr>
<tr class="separator:ab1f57b35097966c0884d0373a71b382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc932ae3ef28f324a656add6c1ac5bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abbc932ae3ef28f324a656add6c1ac5bd">computeNodeBoundaries</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node, <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *parent, bool const left, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;primitives) const</td></tr>
<tr class="memdesc:abbc932ae3ef28f324a656add6c1ac5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute min and max position and surface area of bounding cuboid for given node.  <a href="#abbc932ae3ef28f324a656add6c1ac5bd">More...</a><br /></td></tr>
<tr class="separator:abbc932ae3ef28f324a656add6c1ac5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:a837bf89fb39600314e02f9fa9d05ec9b inherit pro_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a837bf89fb39600314e02f9fa9d05ec9b">lighten</a> (<a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *root)</td></tr>
<tr class="memdesc:a837bf89fb39600314e02f9fa9d05ec9b inherit pro_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuild all children of given root KDTree node as LightKDTeeeNode nodes.  <a href="../../d5/dd0/classKDTreeFactory.html#a837bf89fb39600314e02f9fa9d05ec9b">More...</a><br /></td></tr>
<tr class="separator:a837bf89fb39600314e02f9fa9d05ec9b inherit pro_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0db942ba81564682211127cc1d21c3 inherit pro_methods_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../dd/d79/classLightKDTreeNode.html">LightKDTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#aad0db942ba81564682211127cc1d21c3">_lighten</a> (<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *node)</td></tr>
<tr class="memdesc:aad0db942ba81564682211127cc1d21c3 inherit pro_methods_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assist <a class="el" href="../../d5/dd0/classKDTreeFactory.html#a837bf89fb39600314e02f9fa9d05ec9b" title="Rebuild all children of given root KDTree node as LightKDTeeeNode nodes. ">KDTreeFactory::lighten</a> function by handling the lighten of a given non-root node.  <a href="../../d5/dd0/classKDTreeFactory.html#aad0db942ba81564682211127cc1d21c3">More...</a><br /></td></tr>
<tr class="separator:aad0db942ba81564682211127cc1d21c3 inherit pro_methods_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0d728d4a070ec3235cdbc4988e61ad41"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *(<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *, bool const, vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> * &gt; &amp;, int const)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a0d728d4a070ec3235cdbc4988e61ad41">_buildRecursive</a></td></tr>
<tr class="memdesc:a0d728d4a070ec3235cdbc4988e61ad41"><td class="mdescLeft">&#160;</td><td class="mdescRight">The member function as attribute used to recursively build KDTree nodes. By default it will be assigned to the buildRecursive member function but it might be overridden by other implementations. For instance, to wrap the buildRecursive behavior to handle parallel building of KDTrees.  <a href="#a0d728d4a070ec3235cdbc4988e61ad41">More...</a><br /></td></tr>
<tr class="separator:a0d728d4a070ec3235cdbc4988e61ad41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba2468b2987b4bd93e3e832bdf52f00"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#abba2468b2987b4bd93e3e832bdf52f00">minSplitPrimitives</a></td></tr>
<tr class="memdesc:abba2468b2987b4bd93e3e832bdf52f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many primitives are required for a node to be splitted.  <a href="#abba2468b2987b4bd93e3e832bdf52f00">More...</a><br /></td></tr>
<tr class="separator:abba2468b2987b4bd93e3e832bdf52f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classKDTreeFactory"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classKDTreeFactory')"><img src="../../closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="../../d5/dd0/classKDTreeFactory.html">KDTreeFactory</a></td></tr>
<tr class="memitem:aa6ede7a422802db8e6cbf537861d5f56 inherit pro_attribs_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#aa6ede7a422802db8e6cbf537861d5f56">buildLightNodes</a> = true</td></tr>
<tr class="memdesc:aa6ede7a422802db8e6cbf537861d5f56 inherit pro_attribs_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">When it is true, the <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> is expected to build light nodes. It is, built KDTree must have a KDTreeRootNode which children are all <a class="el" href="../../dd/d79/classLightKDTreeNode.html" title="Class representing a light KDTree node. It is, the basic representation of a KDTree node with uses le...">LightKDTreeNode</a>. When it is false, <a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> is allowed to build KDTree with <a class="el" href="../../d8/d94/classKDTreeNode.html" title="Class representing a KDTree node. ">KDTreeNode</a> children, which might require more memory.  <a href="../../d5/dd0/classKDTreeFactory.html#aa6ede7a422802db8e6cbf537861d5f56">More...</a><br /></td></tr>
<tr class="separator:aa6ede7a422802db8e6cbf537861d5f56 inherit pro_attribs_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5316cf17aff5dd178d2a84d31410e213 inherit pro_attribs_classKDTreeFactory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d04/classLightKDTreeNodeBlockAllocator.html">LightKDTreeNodeBlockAllocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classKDTreeFactory.html#a5316cf17aff5dd178d2a84d31410e213">lkdtnBlockAllocator</a></td></tr>
<tr class="memdesc:a5316cf17aff5dd178d2a84d31410e213 inherit pro_attribs_classKDTreeFactory"><td class="mdescLeft">&#160;</td><td class="mdescRight">The block allocator to speed-up lighten of KDTree by reducing allocation calls when instantiating multiple <a class="el" href="../../dd/d79/classLightKDTreeNode.html" title="Class representing a light KDTree node. It is, the basic representation of a KDTree node with uses le...">LightKDTreeNode</a>.  <a href="../../d5/dd0/classKDTreeFactory.html#a5316cf17aff5dd178d2a84d31410e213">More...</a><br /></td></tr>
<tr class="separator:a5316cf17aff5dd178d2a84d31410e213 inherit pro_attribs_classKDTreeFactory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afebd1f880d9171e68537df4e2485e06c"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:afebd1f880d9171e68537df4e2485e06c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#afebd1f880d9171e68537df4e2485e06c">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="memdesc:afebd1f880d9171e68537df4e2485e06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a simple KDTree factory to a stream of bytes.  <a href="#afebd1f880d9171e68537df4e2485e06c">More...</a><br /></td></tr>
<tr class="separator:afebd1f880d9171e68537df4e2485e06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2cd36fb2add7c5f0ce882d85379f6087"><td class="memItemLeft" align="right" valign="top"><a id="a2cd36fb2add7c5f0ce882d85379f6087"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MultiThreadKDTreeFactory</b></td></tr>
<tr class="separator:a2cd36fb2add7c5f0ce882d85379f6087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top"><a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::serialization::access</b></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class providing building methods for simple k-dimensional trees. </p>
<dl class="section author"><dt>Author</dt><dd>Alberto M. Esmoris Pena </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/dd0/classKDTreeFactory.html" title="Class that must be extended by any class which provides factory methods for k-dimensional trees...">KDTreeFactory</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aac0b2d556d61c2e301de1eb2f9bda823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0b2d556d61c2e301de1eb2f9bda823">&#9670;&nbsp;</a></span>SimpleKDTreeFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimpleKDTreeFactory::SimpleKDTreeFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html" title="Class providing building methods for simple k-dimensional trees. ">SimpleKDTreeFactory</a> default constructor. </p>
<p>The buildRecursive member function is assigned to the _buildRecursive function as member attribute </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab1f57b35097966c0884d0373a71b382d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f57b35097966c0884d0373a71b382d">&#9670;&nbsp;</a></span>buildChildrenNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::buildChildrenNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build children nodes for given node. If no children nodes must be built, then the node is configured as a leaf node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Node which children will be built if possible and, if not, then will be configured as leaf node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent</td><td>The parent node if any. For root nodes, it will be a nullptr </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">primitives</td><td>Primitives of the node itself </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">depth</td><td>Depth of current node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">leftPrimitives</td><td>Primitives for left child node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rightPrimitives</td><td>Primitives for right child node </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#a3f890774977516b4212e314333cdc7a7">SAHKDTreeFactory</a>.</p>

</div>
</div>
<a id="a07231a87a91c5168efcb91308c60adf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07231a87a91c5168efcb91308c60adf8">&#9670;&nbsp;</a></span>buildRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> * SimpleKDTreeFactory::buildRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively build a KDTree for given primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent node if any. For root nodes, it must be a nullptr </td></tr>
    <tr><td class="paramname">left</td><td>True if given node is a left child, false otherwise. If the node is a root node, it should be false. If node is not a root node and left is true, it means it is a left child. If node is not a root node and left is false, it means it is a right child </td></tr>
    <tr><td class="paramname">primitives</td><td>Primitives to build KDTree splitting them </td></tr>
    <tr><td class="paramname">depth</td><td>Current depth at build process. Useful for tracking recursion level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Built KDTree node </dd></dl>

<p>Reimplemented in <a class="el" href="../../df/d86/classMultiThreadKDTreeFactory.html#a2e3a8ea91910658ee9ff6f012e196b11">MultiThreadKDTreeFactory</a>.</p>

</div>
</div>
<a id="a259a3500ce239f33914d5da0c694b427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259a3500ce239f33914d5da0c694b427">&#9670;&nbsp;</a></span>computeKDTreeStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::computeKDTreeStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyze KDTree computing its max depth and the minimum and maximum number of primitives considering all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node to compute stats for given <a class="el" href="../../d0/d64/classKDTreeNodeRoot.html" title="Class representing the root node of a KDTree. ">KDTreeNodeRoot</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aca4a9fd27edb126bcbc9fc5020ef9f15">SAHKDTreeFactory</a>, and <a class="el" href="../../df/d86/classMultiThreadKDTreeFactory.html#a52a5bf891500e9e7a4cf264cd8c9580a">MultiThreadKDTreeFactory</a>.</p>

</div>
</div>
<a id="abbc932ae3ef28f324a656add6c1ac5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc932ae3ef28f324a656add6c1ac5bd">&#9670;&nbsp;</a></span>computeNodeBoundaries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::computeNodeBoundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute min and max position and surface area of bounding cuboid for given node. </p>
<p>Surface area for a cuboid can be computed considering \(l_i\) is the length of \(i-th\) axis.</p>
<p>For instance, surface area of root node \(R\) in \(\mathbb{R}^2\) can be computed as follows:</p>
<p class="formulaDsp">
\[ S_A(R) = l_x l_y \]
</p>
<p>Analogously, the surface area of root node \(R\) in \(\mathbb{R}^3\) can be computed as follows:</p>
<p class="formulaDsp">
\[ S_A(R) = 2(l_x l_y + l_x l_z + l_y l_z) \]
</p>
<p>The boundaries for the root node are taken from min and max vertex of given set of primitives. Surface area and min and max boundaries for children nodes are just taken proportionally to \(r\) where \(p\) is the split position and \(a\) and \(b\) are the min and max positions respectively:</p>
<p class="formulaDsp">
\[ r = \frac{p-a}{b-a} \]
</p>
<p>For the sake of understanding, surface area for children nodes is explained in detail. For this purpose, notice that \(p \in [a, b]\). Now lets define left and right children surface area respectively, namely \(S_A(L_b)\) and \(S_A(R_b)\) where \(S_A(P)\) is the surface area of the parent node itself:</p>
<p class="formulaDsp">
\[ \left\{\begin{array}{lllll} S_A(L_b) &amp;=&amp; r S_A(P) &amp;=&amp; \frac{p-a}{b-a} S_A(P) \\ S_A(R_b) &amp;=&amp; (1-r) S_A(P) &amp;=&amp; \left(1 - \frac{p-a}{b-a}\right) S_A(P) \end{array}\right. \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Root node which surface area must be computed </td></tr>
    <tr><td class="paramname">parent</td><td>The parent node if any. For root nodes, it will be a nullptr </td></tr>
    <tr><td class="paramname">left</td><td>True if given node is a left child, false otherwise. If the node is a root node, it should be false. If node is not a root node and left is true, it means it is a left child. If node is not a root node and left is false, it means it is a right child </td></tr>
    <tr><td class="paramname">primitives</td><td>Vector of primitives inside given root node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3ed0e048fd2e9ae62fdd324e32153c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ed0e048fd2e9ae62fdd324e32153c5">&#9670;&nbsp;</a></span>defineSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::defineSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define the split axis and position for current node. </p>
<p>The simple KDTree factory defines the split point as the position of the median which splits primitives along split axis into two nodes which tend to have the same number of primitives. To illustrate this, let \(d\) be the depth of the node and \(n\) be the space dimensionality. Therefore, the split axis can be defined as \(a = d \mod n\). If \(P=\left\{p_1, \ldots, p_n\right\}\) is the set of all primitives contained in the node where \(\forall i, p_i=(p_{i1}, \ldots, p_{in})\), the split position \(s\) can be used to define following sets: </p><p class="formulaDsp">
\[ \alpha = \left\{ p_i : p_{ia} \leq s \right\} \\ \beta = \left\{ p_i : p_{ia} &gt; s \right\} \]
</p>
<p>But if \(s\) is the median of primitives distribution along \(a\)-axis, then if there are no equal primitives it will be satisfied that \(0 \leq |\alpha| - |\beta| \leq 1\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Node which split axis and split position are going to be defined </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent</td><td>The parent node if any. For root nodes, it will be a nullptr </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">primitives</td><td>Primitives of node which split must be defined </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">depth</td><td>Depth of node which split must be defined </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../db/d58/classSAHKDTreeFactory.html#aa22c06947f61f871156922122c41084d">SAHKDTreeFactory</a>, and <a class="el" href="../../df/d30/classAxisSAHKDTreeFactory.html#a1a938aa8914f624692228217428c157a">AxisSAHKDTreeFactory</a>.</p>

</div>
</div>
<a id="a3252f0348c7fd5d40b84e52dd9144fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3252f0348c7fd5d40b84e52dd9144fad">&#9670;&nbsp;</a></span>makeFromPrimitivesUnsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> * SimpleKDTreeFactory::makeFromPrimitivesUnsafe </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>primitives</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a simple KDTree from given primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitives</td><td>Primitives to build simple KDTree splitting them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to root node of built simple KDTree </dd></dl>

<p>Implements <a class="el" href="../../d5/dd0/classKDTreeFactory.html#a06b1ebdfb108a2c5a389ee390f534197">KDTreeFactory</a>.</p>

</div>
</div>
<a id="ab3a2b1d37c6dfe2b97a502a85e6154c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a2b1d37c6dfe2b97a502a85e6154c5">&#9670;&nbsp;</a></span>populateSplits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::populateSplits </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>splitAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>splitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leftPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rightPrimitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate list of primitives for left and right splits from given primitives of node being splitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">primitives</td><td>Primitives of node being splitted </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splitAxis</td><td>Index of axis defining the split </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splitPos</td><td>Position on given axis of the split point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">leftPrimitives</td><td>Where primitives of left split must be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rightPrimitives</td><td>Where primitives of right split must be stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f5466631a7dc4fd2102c338645ff2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5466631a7dc4fd2102c338645ff2af">&#9670;&nbsp;</a></span>reportKDTreeStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::reportKDTreeStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d64/classKDTreeNodeRoot.html">KDTreeNodeRoot</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>primitives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report KDTree stats of given root node at INFO logging level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node which stats must be reported </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../df/d86/classMultiThreadKDTreeFactory.html#aaa41155c2cff4d446839bab62dc2bd3a">MultiThreadKDTreeFactory</a>.</p>

</div>
</div>
<a id="afebd1f880d9171e68537df4e2485e06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebd1f880d9171e68537df4e2485e06c">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleKDTreeFactory::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a simple KDTree factory to a stream of bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>Type of rendering </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Specific rendering for the stream of bytes </td></tr>
    <tr><td class="paramname">version</td><td>Version number for the simple KDTree factory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0d728d4a070ec3235cdbc4988e61ad41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d728d4a070ec3235cdbc4988e61ad41">&#9670;&nbsp;</a></span>_buildRecursive</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *( <a class="el" href="../../d8/d94/classKDTreeNode.html">KDTreeNode</a> *, bool const, vector&lt;<a class="el" href="../../df/de1/classPrimitive.html">Primitive</a> *&gt; &amp;, int const )&gt; SimpleKDTreeFactory::_buildRecursive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The member function as attribute used to recursively build KDTree nodes. By default it will be assigned to the buildRecursive member function but it might be overridden by other implementations. For instance, to wrap the buildRecursive behavior to handle parallel building of KDTrees. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html#a07231a87a91c5168efcb91308c60adf8" title="Recursively build a KDTree for given primitives. ">SimpleKDTreeFactory::buildRecursive</a> </dd></dl>

</div>
</div>
<a id="abba2468b2987b4bd93e3e832bdf52f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba2468b2987b4bd93e3e832bdf52f00">&#9670;&nbsp;</a></span>minSplitPrimitives</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SimpleKDTreeFactory::minSplitPrimitives</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How many primitives are required for a node to be splitted. </p>
<p>If number of primitives is equal or greater than, then node might be splitted if necessary criterion is satisfied. Otherwise, no matter if other splitting criterion is satisfied, node will never be splitted. It is mainly useful to prevent too deep KDTrees which might lead to consuming a high amount of memory without significant performance improvement. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/adt/kdtree/<a class="el" href="../../da/da3/SimpleKDTreeFactory_8h_source.html">SimpleKDTreeFactory.h</a></li>
<li>src/adt/kdtree/SimpleKDTreeFactory.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/d96/classSimpleKDTreeFactory.html">SimpleKDTreeFactory</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
